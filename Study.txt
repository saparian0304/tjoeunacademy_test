====================================
22.04.25 월 (선행 1일차)

환경변수(변할 수 있는 수)
JAVA_HOME
-> 자바 설치된 경로

Path
-> 어디서든 해당경로의 파일 실행
%JAVA_HOME%\bin 
	(변환)-> 자바 설치경로\bin\java.exe

GUI : Graphic User Interface
Inter + face
 ~사이에 + 표면

CLI : Command Line Interface

자료형 변수명;

변수/메서드/클래스 명명 규칙
1. 클래스명 첫자를 대문자로
2. 여러 단어로 이루어진 경우 
-> 두번째 이후 단어의 첫자 : 대문자
학생번호 : studentNumber (Camel 표기법, 주로 class명, 메서드명)
-> 단어와 단어 사이에 '_'
학생번호 : student_number (Snake 표기법, 주로 변수명)
3. 상수(항상 같은 수)는 모두 대문자
-> 원주율 : PI


자료형
자료 : 데이터
형 : 타입
데이터타입, 타입, 데이터형, 자료타입, 형...

기본자료형
- 정수(-,+,0), 실수(소수점 있는 수), 논리(참/거짓)
정수 (byte, short, int, long, char)
int : -21억 ~ +21억
long : 21억이 넘는다(긴)
실수 (double)
논리 (boolean) : true/false 둘 중 하나의 값

char (character)
- 문자
- 작은따옴표(')로 감싸서 표현

참조(reference)자료형


줄바꿈이 포함된 상태
안녕하세요
반갑습니다

저는 "홍길동"입니다.

====================================
22.04.26 화 (선행 2일차)

파일의 종류
 - 텍스트
 - 바이너리

변수 (variable, 變數)
vary + able, variety


구조(structure)

int < long < double 


ctrl + d : 코드 한줄 삭제
ctrl + alt + 방향키 : 선택영역 코드 복사

★★
비교연산자 : 결과값은 항상 boolean(true/false)으로 나옴

a == b 같은지 비교
a != b 같지 않은지 비교

&&와 &의 차이
&& : 좌측항이 false이면 무조건 false이기때문에 우측항은 연산하지 않음
&& : 좌측항이 false여도 우측항을 연산하고 결과값 리턴

||와 |의 차이
|| : 좌측항이 true이면 무조건 true이기때문에 우측항은 연산하지 않음
| : 좌측항이 true여도 우측항을 연산하고 결과값 리턴

=====================================
22.04.27 수 (선행 3일차)

연산
* 대입연산
=, +=, -=, *=, /= ....

* 산술연산
+, -, *, /, %

* 증감연산
++, --

* 비교연산
<, >, <=, >=, ==, !=

* 논리연산
&&, ||, !

* 삼항연산
조건 ? 값1(true) : 값2(false)


if문
if (조건문1-결과값이 boolean!) {
    실행문 1
} else if (조건문2 - 결과값boolean) {
    실행문 2
} else {
    실행문 3
}

else문은 있을 수도 있고, 없을 수도 있음


자동 import 단축키 : ctrl + shift + O (알파벳 O)

폰트 : D2 coding  (Il1| 구분이 쉬움)

자바 버전
1.0
1.2 -> java2
1.5 -> java5
1.7 -> java7 (아직 쓰고 있는 곳 많음)
1.8 (★) (제일 많이 쓰고 있음)
9
10
11 (★)
...
18


for문 구조

for (초기화식(1) ; 조건식(2) ; 증감식(4)) { 
    실행문(3)
}

for문 순서
(1) -> (2) -> (3) -> (4)
    -> (2) -> (3) -> (4)
    -> (2) -> (3) -> (4)
    -> (2) -> (3) -> (4) (조건식이 true일 동안 반복)


while문 구조

while (조건식) {
    실행문	(조건식이 true일 동안 반복)
}

자칫하면 무한반복(loop)에 빠질 수 있음


for : 반복횟수가 정해져 있을 때
while : 반복횟수가 정해져 있지 않을 때


반복문 이름 부여
outer : 
for ( ; ; ) { 

    inner :
    for(   ){
    break outer;
    }

}

for문에 이름을 부여(outer, inner)해서 break문을 사용할 경우 중첩 for문을 한꺼번에 나갈 수 있음

===================================
22.04.28 목 (선행 4일차)
복습방법
클라우드스터딩 : https://cloudstudying.kr/
강의 -> "자바 입문하기!"

컴퓨터 과학 (CS, Computer Science)
 - 네트워크, 자료구조, 알고리즘, 데이터베이스


컴퓨터언어 (compile, interpreter)
compile
 - 소스 -> 기계어(실행)
 - C, C++
 - 속도가 빠름
 - 유지보수 어려움, 번거롭다 (코드 하나 수정해도 "컴파일->실행" 과정을 거쳐야함)

JIT (Just In Time) : Java가 여기에 속함 (+ 현재 버전의 Python, JavaScript)
 - 소스 -> 컴파일(바이너리) -> JVM(실행)
 - compile 장점 + interpreter 장점
 - compile 단점 + interpreter 단점

interpreter
 - 소스(실행) => 소스의 한줄씩 번역해서 실행
 - Python, JavaScript
 - 속도가 느림
 - 유지보수가 쉬움 (compile 언어에 비해서)


여러줄 주석 단축키 : Ctrl+Shift+'/' -> 잘 안씀 (그냥 Ctrl+'/' 를 사용함)

웹개발시에는 패키지를 꼭 만들어야한다! (default package 사용X)

메서드 실행(호출) = method call (같은 의미)

===================================
===================================
22.05.02 국비 첫 수업


취업지원센터 김지은 (070-4907-5726, kimje1415@tjoeun.co.kr)
취업지원서비스는 훈련종료 한달 전부터 진행함 (출결 조건을 만족해야함)

오리엔테이션
서류 작성해서 금일 제출 (훈련생 서약서, 개인정보 동의서, 안전수칙 준수 서약서)


지각, 외출, 조퇴 3번시 결석 1번
수업시간 50%를 만족하지 못하면 당일 결석처리됨
출결방법 불일치시 결석처리 (예 - 카드출석+QR퇴실)
9:40까지 정상입실
6:20부터 정상퇴실 (마지막시간 입력시간으로 퇴실 체크됨)
 - 학원 10시30분까지 운영함

공가처리 (단위기간 출석일수의 10% )
 - 병원 진료확인서 (진단서 필요X, 진료확인서는 무료or 2~3,000원, 다음날까지 제출)
 - 입사시험(면접)
 - 훈련 관련 자격증시험

훈련장려금 : 단위기간 기준 15일 이내 지급

교육과정 설계 취지
 - 자바 개발, 데이터 분석을 구분해서 나누지않고 하나의 범위로 구분
 - 데이터 분석이 가능한 자바 웹 개발자
 - 자바 백엔드 개발자 + 데이터 분석
 - 최근 각광받고 있는 엘라스틱 서치 기술 학습

자바
Java - 기본문법, 연산, 제어문, 객체지향 프로그래밍, 클래스와 객체, 자료구조, 자바API, IO, 쓰레드, 네트워크
SQL - (Oracle, MySQL, 데이터모델링, ERD, DML, DDL 데이터조회, 조인, 서브쿼리)
HTML / CSS / JavaScript - HTML 태그, 속성, CSS 사용법, 선택자, JavaScript 문법, jQuery, Ajax
JSP / Servlet - JSP 문법, 내장 객체, Servlet 설정, 매핑, 세션, 쿠키, EL, JSTL, JDBC
Spring Framework - 의존성 주입(DI, Autowired), AOP, Interceptor, 모델2/MVC구조, MyBatis 연동, RestAPI
Util - Git(소스 버전 관리), Maven(빌드 도구), Junit(테스트 도구)
서버 배포 - AWS 서버 구축, java, tomcat, mysql 설치, 웹 어플리케이션 배포/구동

빅데이터
SQL, 파이썬, 데이터 수집, 데이터 전처리, 데이터 시각화, 기초수학, 머신러닝, 딥러닝, NoSQL, API

SQL - RDBMS 데이터 분석
파이썬 - 기본뭄법, 연산, 제어문, 객체지향프로그래밍, 클래스와 객체, 자료구조, 입출력, 모듈/패키지
데이터 수집 - API, 웹 크롤링, 데이터베이스 연동
데이터 전처리 - Numpy, Pandas, excel/csv 파일 다루기, JSON 파일처리, 결측값, 이상값 처리
데이터 시각화 - matplotlib, seaborn, 시각화 종류 및 시각화 실습
머신러닝 - Tensorflow, ~
API - Flask(파이썬 웹 프레임워크 )서버 구축, API 서버 구현


중요함!!  - Java, SQL, SpringFramework

엘라스틱 서치
 - 오픈소스 검색엔진, 대용량 데이터 저장소
 - 단순 RDBMS 검색이 아닌 비정형 텍스트 색인 검색기능
 - 자동완성 및 초성 검색기능


프로젝트
자바 웹 프로젝트, 데이터 분석, 검색엔진


여유가 있을 때 개인프로젝트 진행하자

SQL 교재 (Do it! 오라클로 배우는 데이터베이스 입문)
★★★ 둘째 마당 : 중요함 
셋째 마당 : 이해정도만 하면 됨
넷째 마당 : SQL로 프로그래밍 하는 법 (수업 X)

dataq.or.kr : 데이터 자격검정 홈페이지

용어 암기 (★★★)
 - 개체(entity) 
 - 속성(attribute)
 - 관계(relationship)

~/workspace/tjoeunacademy_test/ABC쇼핑몰.xlsx
ABC쇼핑몰.xlsx (파일) => DB (schema)
회원(시트) => table
홍길동(데이터) => record, row....


entity(개체) : 데이터화 하려는 사물, 개념의 단위 (회원, 주문내역, 상품리스트) => table
atrribute(속성, 특징) : 엔티티(entity)가 가지는 항목 => 열(column)
relationship(관계) : 개체와 개체간의 연관성 => fk (foreign key, 외래키) 외 다양하게 구현


독립성(independency) <-> 의존성(dependency)
 독립성 : 하위스키마를 변경하더라도 상위스키마가 영향을 받지 않는 특성
특정 스키마가 변경되더라도 다른 계층의 스키마는 변경할 필요가 없음
 
무결성(integrity)
 - 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말함

면접시 물어볼 수 있는 SQL의 분류
 - DQL (Data Query Language) : 데이터를 원하는 방식으로 조회하는 명령어 (DML에 포함되기도 함)
 - DML (Data Manipulation Language) : 데이터를 저장, 수정, 삭제하는 명령어
 - DDL (Data Definition Language) : 데이터 관리를 위해 테이블을 포함한 여러 객체를 생성, 수정, 삭제하는 명령어
 - TCL (Transaction Control Language) : 트랜잭션 데이터의 영구 저장, 취소 등과 관련된 명령어
 - DML (Data Control Language) : 데이터 사용 권환과 관련된 명령어


행 = row = record = tuple(튜플) (실무에서는 row라는 표현을 많이 씀)
열 = column = field = attribute (실무에서는 colums이라는 표현을 많이 씀)

열(column) : 데이터의 종류(자료형), 저장가능한 값의 최대길이 등 저장 조건과 범위를 지정할 수 있음


row, raw 혼동하기 쉬움


기본키 (PK, Primary key) - ★★
보조키
외래키 (FK, Foreign key) - ★★

기본키
- 저장된 행을 식별할 수 있는 유일한 값
- 가장 중요한 키로서 한 table에서 중복되지 않는 값만 가지는 키
- Null 값을 가질 수 없음

보통 개인정보 노출이 가장 적은 데이터를 기본키로 지정함
 - 학번, 아이디, 주민번호 => 학번을 기본키로 지정
 - 일반 웹사이트 => 식별을 위한 회원번호를 기본키로 사용 (외부에 노출은 안하고 내부적으로만 사용함)

보조키 = 대체키(alternate key) = 후보키(candidate key)
 - 기본키가 될 수 있는 후보키, null값이 없는 키

외래키(FK)
 - 특정 테이블에 포함되어있으면서 다른 테이블의 기본키로 지정된 키
 - 데이터의 중복을 피하기 위해서 필요함.

실무에서는 보통 테이블이 수십개에서 수백개, 데이터는 억단위를 넘는 경우가 흔함

일부러 외래키를 정의하지 않고 테이블간에 관계를 "느슨하게" 설계하는 경우도 있음
 -> ex) 회원정보 삭제시 지난주문내역 삭제가 발생하는 것을 막기위함

주민등록번호는 법적으로 수집이 금지되었음 (암호화하더라도 수집하면 안됨)

자료형(Data type) 
 - 주로 쓰는 자료형(★★★) : VARCHAR2, NUMBER, DATE
 - 블로그에 내용을 쓰는 경우(★★) : CLOB ( VARCHAR2는 용량에 한계가 있음)

char(character) - 고정문자열
varchar(variable character) - 가변문자열

scalar(0차원) - vector(1차원) - matrix(2차원, 행렬) - tensor(3차원 이상)
scalar : 

이 외에도 여러가지 자료형이 있음 (컬렉션형 - VARRAY, NESTED TABLE)


객체(Object) - SQL 언어에서는 그저 하나의 단위 정도로 생각하자
p40~41 단어 알아야함 - table, index, view, sequence, synosym, procedure, function, package, trigger

PL/SQL - 변수, 조건문, 반복문과 같은 프로그래밍 언어를 사용할 수 있음
최근 PL/SQL을 안쓰려고 하는 추세임 (사용하는 경우 Oracle에 종속되기 때문, 다른 RDBMS로 갈아타기 어려움)


오라클 데이터베이스 설치 
oracle.com -> Resources -> Downloads -> DB Express -> Oracle Database 21c Express Edition 윈도우 64비트 버전 설치
D:\kdigital_a\oraclexe
비밀번호 : sys1234

Oracle DB는 삭제하는 과정이 복잡함
- 일반적인 삭제 과정을 거친 후 레지스트리 삭제 프로그램으로 청소 진행할 것

SQL developer 설치
oracle.com -> Resources -> Downloads -> SQL Developer (자바 포함된 버전으로)
설치 X, 압축만 풀면 됨

SQL Developer
새로만들기 
- 사용자 이름 : sys
- 롤 : sysdba  (최고관리자 권한)
- 비밀번호 : sys1234
- 호스트 : localhost
- 포트 : 1521
- SID : xe (서비스아이디, 무료버전이라 xe로 고정되어있음)
(위 정보들이 있어야 DB에 접속할 수 있음.)

보기 -> DBA -> 하단 창 추가
DBA 창 -> '+'버튼 -> 이전에 추가한 사용자 이름으로 접속
sys -> 저장영역 -> 테이블스페이스(우클릭) -> 새로만들기
- 파일이름 : TEST
- 파일크기 : 500M
- 자동확장 설정 : 체크표시 (다음크기 100M : 용량이 차면 자동으로 용량 확장하는 설정, 최대크기 : 제한없음)


계정 추가
'다른 사용자' 우클릭 -> 사용자 생성
- 사용자 이름 : TESTUSER (대문자로 해야함)
- 비밀번호 : test1234
- 기본 테이블스페이스 : TEST 선택
- 임시 테이블스페이스 : TEMP 선택
- 부여된 롤 : CONNECT, RESOURCE
- 할당량 : TEST -> '무제한'

적용 클릭시 에러발생
- 원인 : 계정명 앞에 "C##" 시작하는 계정명만 가능
일반이름으로 생성시키는 방법 ↓↓↓
- sys 워크시트에서 명령어 실행 - alter session set "_oracle_script"=true;


새로운 접속정보 생성
새로만들기 
- 사용자이름 : testuser
- 비밀번호 : test1234
- 롤은 그대로 (기본값)

사용해본 명령어
- desc emp;
- select * from emp;

sql은 대소문자 구별 없음
워크시트 내용 저장할 필요 없음

========================================
22.05.03 화 - 2일차

SQL 주석 
방법 1 : -- 한줄 주석
방법 2
/*
여러줄 주석
*/


SQL문 실행에 띄어쓰기/줄바꿈은 아무런 문제가 없다.

(가독성을 위해서)
보통 SQL명령문은 대문자, 그외(테이블명, 열이름)는 소문자로 쓴다 
줄바꿈/들여쓰기를 한다
실무에서 프로그래밍언어와 구분하기 위해 SQL문 전체를 대문자로 사용하는 경우도 있음.


DML (Data Manipulation Language) : 데이터 관련 명령어
- 데이터 조작 언어
- 데이터를 조회(DQL), 등록, 수정, 삭제

DDL (Definition) : 테이블 관련 명령어
- 데이터 정의 언어
- 테이블 생성, 변경, 삭제

DCL (Control) : 데이터베이스 권한 관련 명령어
- 데이터 제어 언어
- 데이터베이스 접근권한 제어

TCL (Transaction Control Language)
- 트랜잭션(논리적 작업 단위) 제어
(트랜잭션 : 논리적 기능을 수행하기 위에 한번에 작업되어야 하는 일련의 연산단위(?))


4-1 SELECT문
SELECT : 데이터를 조회하는 데 사용되는 명령어

테이블 탭에서 중요하게 봐야할 하위탭 : "데이터", "제약조건"

JOIN : 테이블끼리 또는 테이블과 같은 다른 요소(뷰, view)를 활용하여 JOIN문을 활용할 수 있음.

Select문 사용할 때 고려사항
- 어디에서 가져올 것인지 (어떤 table)
- 어떻게 가져올지 (전체, 일부 column)
- 어떤 값을 출력할지 (where)

기본구조
SELECT 열이름 [AS 별칭], .... 
FROM 테이블명
[WHERE 조건식]
[ORDER BY 열이름 [ASC or DESE]]

[ ] : 생략이 가능(모든 경우는 아니나 생략이 가능하다는 뜻으로 사용되는 경우가 많음)

";" : 문장 구분을 위해서 필요함 (한개의 문장을 실행할 때에는 ';' 가 없어도 됨)


DISTINCT : 조회할 때 중복값을 제거

SELECT 컬럼 FROM 테이블 GROUP BY 그룹화할 컬럼;   -> 잘 안씀

select ename, sal, comm, sal*12+comm as 연봉 from emp;  
-- as 별칭을 부여할 때 사용 
-- comm값에 null값이 포함되어서 null값으로 출력됨 (null 값은 연산 불가)

-- null이면 0으로 처리해주는 함수 : NVL(a , b)    (a = 열 이름, b= null값이 반환할 값)
select ename, sal, comm, sal*12+NVL(comm, 0) as 연봉 from emp;
select comm, nvl(comm, 0) from emp;

as (별칭, alias)
- 별칭에 띄어쓰기가 있는 경우 큰따옴표(" ")로 묶어서 사용
- 써도 되고 안써도되나 가독성 때문에 잘 안씀


ORDER BY
- 정렬의 기본값은 ASC (오름차순)

SELECT *
FROM emp
ORDER BY deptno ASC, sal DESC;
 - 선언한 순서대로 정렬 1순위, 2순위

정렬을 사용(ORDER BY)하는 것이 속도를 깎아먹는 주 요인임 => index를 사용하는 경우 일정부분 해소가 가능함
그러나 정렬을 하지 않는 경우는 거의 없음

ORDER BY는 항상 문장 맨 끝에 와야함


2022 개발자 설문조사
https://programmers.co.kr/pages/2022-dev-survey

프로그래머스 코딩테스트 -> SQL 고득점 Kit


쇼핑몰, 금융권, 교육기관 : 프로젝트를 해본 경험이 있는게 좋음

WHERE 조건식 : 해당 조건에 true인 것만 선택해서 출력함
SELECT * FROM emp WHERE deptno = 30;

AND / OR
WHERE문에 여러개의 조건식을 사용할 수 있다.

AND (그리고)
A AND B : A가 참이고 B도 참이면 결과는 참 (둘다 참 -> 참)
OR (또는)
A OR B : A가 참이거나 또는 B가 참이면 결과 참 (둘 중 하나 이상이 참 -> 참)

성별이 여자 AND 나이가 30 이상 = 여자이면서 30 이상
성별이 여자 OR 나이가 30 이상 = 여자/30미만(30이상), 남자/30이상

SELECT * FROM emp WHERE deptno = 30 AND job = 'SALESMAN';
테이블 안에 들어있는 문자열 데이터는 대,소문자를 구별한다!
 - 데이터 값이 대문자이면 대문자로 조건문 작성, 소문자이면 소문자로 조건문 작성


SQL문은 나머지연산을 제공하지 않음. 사칙연산(+, -, *, /)만 가능


!=, <>, ^= : 같은 의미로 사용되는 연산자 (A != B : A와 B가 같지 않는 경우)
"NOT 조건식" 의 형태가 사용되기도 함

IN 연산자 : OR 연산자의 중복사용을 막을 수 있음

BETWEEN 연산자 a AND b 
- a와 b 사이의 값 (a값, b값 포함됨)

-날짜 검색도 BETWEEN 연산으로 가능하다
1981년 입사한 직원
SELECT * FROM emp WHERE hiredate BETWEEN '1981-01-01' and '1981-12-31';

날짜 표시형식 변경방법
 - 도구 -> 환경설정 -> 데이터베이스 -> NLS -> 날짜형식 변경
RR/MM/DD 또는 RRRR-MM-DD 등 가능


AND -> BETWEEN
OR -> IN


LIKE (★★)
- 텍스트 검색할때 주로 사용되는 연산자 ( '_', '%')
- 주로 % 만 사용됨
- 데이터 조회 속도가 느려지는 원인이 됨

김
김구
김구라

LIKE '김_'  -> 조회 데이터 (김구)
LIKE '김%' -> 조회 데이터 (김, 김구, 김구라)



-- NULL 값인 것만 출력하기 (IS NULL)    ★★★
SELECT ename, sal, comm FROM emp WHERE comm IS NULL;

-- NULL 값 제외하고 출력하기 (IS NOT NULL)   ★★★
SELECT ename, sal, comm FROM emp WHERE comm IS NOT NULL;

에러가 나지 않기때문에 SQL문이 잘못됐는지 확인하기 어렵다
사용법을 제대로 익혀두자

집합연산자 (UNION, UNION ALL, MINUS, INTERSECT)

UNION : 합집합, 중복제거
UNION ALL: 합집합, 중복값 출력 (실무에서는 UNION ALL을 많이 씀)
MINUS : 차집합
INTERSECT : 교집합

자유게시판, 유머게시판

최근게시물
제목, 작성일이 같아도 둘다 출력되게끔함! (자유게시판, 유머게시판)


6장 함수
SQL은 거의 동일하지만 함수는 DB마다 다른 경우들이 있음.
함수도 대소문자 구분 X

UPPER()
LOWER()
LENGTH()

dual 테이블  -> 더미(dummy) 테이블 (임시연산이나 함수의 결과값 확인을 위해 사용됨)
SELECT sysdate from dual; 
- 현재 날짜를 보고 싶을 때 dual 테이블을 이용해서 간편하게 확인함

SUBSTR()   -> (substr/ing)
"안녕하세요"
"안녕", "안녕하"

SUBSTR(문자열 데이터, 시작위치, 추출길이)
SUBSTR(문자열 데이터, 시작위치)

INSTR() -> 문자열 데이터 안에서 특정 문자 위치를 찾는 함수
Oracle index는 1부터 시작함!

REPLACE() : 자주 사용됨 (프로그래밍 언어에서도 사용됨)
- 특정 문자를 바꾸는데 사용

TRIM, LTRIM, RTRIM
-- 원래 특정 문자를 trim하는 용도로 사용함 (잘 사용 안함)
-- 주로 공백을 제거하는 용도로 사용됨
TRIM
-- both : 왼쪽+오른쪽, leading : 왼쪽, trailing : 오른쪽
'서울시'
'       서울시'
'서울시         '

LPAD, RPAD : 빈공간을 특정 문자로 채워줌

CONCAT : 두 문자열을 합치는 함수
 - oracle에서는 '||' 연산자가 동일한 기능을 함, 매우 편리하나 사용하지 않는게 좋음


=============================================
22.05.04 수 - 3일차

SQLD 문제집 자료 - 클래스룸
과목 1, 2만 공부하면 됨
과목3은 할 필요 없음 (SQLP 과정)

숫자 관련 함수 
1. ROUND : 특정 위치에서 반올림
2. TRUNC : 특정 위치에서 버림
3. CEIL : 올림
4. FLOOR : 내림
5. MOD : 나머지 값을 반환

날짜 관련 함수
- 날짜 '+'/'-' 숫자 연산 가능
- 날짜끼리 '-' 연산은 가능하나 '+' 연산은 불가능함
1. SYSDATE : Oracle 서버가 놓인 OS의 현재 날짜 및 시간
2. ADD_MONTHS : 몇 개월 이후 날짜
3. MONTHS_NETWEEN : 개월수 차이 
4. NEXT_DAY : 돌아오는 요일 반환
5. LAST_DAY : 달의 마지막 날짜 반환

형 변환 함수
1. TO_CHAR : 숫자/날짜 -> 문자열
2. TO_NUMBER : 문자데이터 -> 숫자형
3. TO_DATE : 문자데이터 -> 날짜 데이터


NULL 처리 함수
1. NVL함수
2. NVL2 함수

조건에 따른 데이터 처리함수
1. DECODE
2. CASE

DECODE : 간단한 경우에 사용, 다른 DB에 없는 경우 있음
CASE
 - 복잡한 경우에 사용 (DECODE가 표현할 수 없는 방식도 지원함)
 - DECODE에 비해 범용적으로 사용이 가능함

랭킹 함수 (★★★★★)
- ROW_NUMBER() : 중복없이 전체 순서 지정       (공동 등수 X)
- RANK() : 중복되면 하위랭킹 제외 후 순서 지정 (공동 1등이면, 다음 순위 3등)
- DENSE_RANK() : 중복되면 하나의 랭킹으로 지정 (공동 1등이면, 다음 순위 2등)

over : (공통 정렬 기준)

SELECT 
    sal, 
    ROW_NUMBER() OVER (ORDER BY sal DESC) AS rank1, 
    RANK() OVER (ORDER BY sal DESC) AS rank2, 
    DENSE_RANK() OVER (ORDER BY sal DESC) AS rank3
FROM emp;


7장 다중행 함수와 데이터 그룹화

SUM()
COUNT()
AVG()
MIN(), MAX()
VARIANCE(), STDDEV

그룹함수는 항상 NULL을 제외하고 리턴함
'*' 사용이유 : NULL값을 포함한 전체 행의 개수를 알고싶을 때는 COUNT(*)을 사용함
또는 Primary_Key 컬럼을 COUNT 하는 방법도 있음


group by : 값이 같은 행끼리 묶어서 그룹핑
~별(월별, 부서별, 연도별 등등) -> group by 사용

HAVING - group by 결과의 조건 지정


SQL문 실행순서!

        어디에서 (FROM)
        어떻게
         - 조건에 해당하는 데이터만 (WHERE)
         - 그룹핑 (GROUP BY)
         - 그룹핑된 조건 (HAVING)
         출력 컬럼 (SELECT)
         정렬 (ORDER BY)
         
         AS (Alias)도 위 순서에 영향을 받음



======================================
22.05.06 금 - 4일차

p195
7.4 그룹화와 관련된 여러 함수 (시험에는 항상 나옴, ★★★★)

사실 잘 쓰지 않음 + oracle에 종속된 함수

- ROLLUP : 데이터의 합계 출력
- CUBE : 결합 가능한 모든 조합의 그룹핑
- GROUPING SETS : 컬럼별 별도 합계

이런 데이터가 필요하면 보통 프로그래밍 언어단에서 처리함

LISTAGG : 잘 사용 X

PIVOT : 엑셀과 동일한 기능
- 행을 열로 바꿔줌 (단순히 바꾸는 것은 아니고 정리해서..)


8장 JOIN

JOIN의 종류
* cross join (크로스 조인) : 가능한 모든 행 조인
* euqi join (등가 조인, ★★) : 조건이 일치하는 결과만 출력 => inner join
* no euqi join (비등가 조인) : 조건이 일치하지 않는 결과 출력
* outer join (외부 조인, ★★) : 양쪽 테이블의 한쪽만 조건이 일치해도 출력 => left join, right join 
* self join (자체 조인) : 자기 자신 테이블 조인


join 그림 - 슬랙 참조 (or 구글에 join 검색)

실제 실무에서는 *을 잘 사용하지 않고 직접 column명을 입력해줌
변경사항이 생겼을 경우 프로그램 수정이 쉽지 않기때문


표준(ansi) 조인방식 
1.  , -> JOIN
2. WHERE -> ON
- JOIN, ON 표현방식에 익숙해지자

시험에 나오는 부분 (★)
- 필요한 조건식의 최소 개수 : 조인 테이블 개수에서 하나를 뺀 값


자체조인
예) 
원하는 출력형태 : 직원번호, 직원명, 상사직원번호, 상사명
-> 상사명은 emp 테이블에 없기때문에 동일한 테이블을 JOIN함

LEFT OUTER JOIN (오라클 방식)
SELECT e1.empno, e1.ename, e1.mgr, e2.ename
FROM emp e1, emp e2
WHERE e1.mgr = e2.empno(+);

LEFT OUTER JOIN (ANSI 방식, 표준)
SELECT 
    e1.empno, e1.ename, e1.mgr, e2.ename
FROM emp e1 LEFT OUTER JOIN emp e2   
ON e1.mgr = e2.empno;


LEFT JOIN : 왼쪽 테이블 데이터가 다 나옴
RIGHT JOIN : 오른쪽 테이블 데이터가 다 나옴


표준문법
- NATURAL JOIN : 자동으로 join 해줌 (기준이 명시되어있지 않아 실무에서는 잘 사용 안함)
- JOIN ~ USING : ON 과 비슷하나 잘 사용 안함
- JOIN ~ ON : WHERE절과 동일함

3개 이상의 테이블 조인은 잘 사용 안함
FROM table1 JOIN table2 ON (조건식) 
JOIN table3 ON (조건식)


기본 구조
1. INNER JOIN
1-1 oracle 형식
FROM t1, t2
WHERE t1.x = t2.x;

1-2 표준형식
FROM t1 JOIN t2
ON t1.x = t2.x;

2. OUTTER JOIN
2-1 oracle 형식
FROM t1, t2
WHERE t1.x = t2.x(+)

2-2 표준형식
FROM t1 LEFT JOIN t2
ON t1.x = t2.x


CONNECT BY (계층형 / 트리구조) 조회 : Oracle에서만 가능
- 시험에서 자주 나옴
-- 기본구조
SELECT
    empno, mgr, ename
FROM emp
START WiTH mgr IS NULL      -- 시작 조건
CONNECT BY PRIOR empno = mgr; -- 조인 조건

-- 추가 구조
SELECT
    level,                  -- 계층형태를 알려줌
    LPAD(' ', 4*(LEVEL -1)) || empno,   -- 계층형태를 눈으로 보기 쉽게 하기 위함
    mgr, ename
FROM emp
START WiTH mgr IS NULL      -- 시작 조건
CONNECT BY PRIOR empno = mgr; -- 조인 조건


 9장(★★★★★) - 서브쿼리

SELECT문을 괄호로 감싼 것 => 서브쿼리

단일행 서브쿼리 ( =, !=, >, <, ....) : 실행값이 1 row인 쿼리
다중행 서브쿼리 (IN, NOT IN, ANY, ALL) : 실행값이 1 row 이상인 쿼리

다중행 서브쿼리
* IN        : 메인쿼리의 데이터가 서브쿼리의 결과값과 하나라도 일치하면 true
* ANY, SOME : 메인쿼리의 조건식을 만족하는 서브쿼리 결과가 하나 이상이면 true
* ALL       : 메인쿼리 조건식을 서브쿼리 결과값 모두가 만족하면 true
* EXISTS    : 서브쿼리의 결과가 하나라도 존재하면 true


/*
뷰(VIEW)
- 가상의(논리적) 테이블
- INLINE VIEW (코드 안에 뷰)
*/

-- SELECT문을 사용해서 가상의 테이블(view)을 만들고 FROM의 대상으로 사용할 수 있음


/*
데이터가 많은 경우
JOIN을 하고 조건을 넣는 것과                       -> 단순 JOIN
데이터를 줄여서 JOIN하는 것과는 속도차이가 있음    -> VIEW를 이용해서 데이터를 줄인 후 JOIN
*/


스칼라 서브쿼리 => 단일행
- SELECT절에 오는 서브쿼리로 반드시 하나의 결과만 반환해야함
- 한 행을 조회할때마다 실행되기때문에 속도가 느림


페이징처리 => rownum 이용, 서브쿼리 2번 사용
- rownum : 행에 번호를 부여해줌
- 2번 감싸야 페이징 처리가 된다 (서브쿼리 안에 서브쿼리)
- 정렬을 하기 위함

SELECT 
    *
FROM (
    SELECT rownum rnum, a.*     -- 넘버를 부여하는 서브쿼리
    FROM (
        SELECT empno, ename     -- 시간대 순으로 정렬하는 서브쿼리
        FROM emp
        ORDER BY hiredate
    ) a
) b
WHERE b.rnum BETWEEN 1 AND 10;  -- 페이징 처리를 위한 BETWEEN 조건절

- 인터넷에 한번만 감싸는 형태로 페이징처리 구현했다고 하지만 그렇게 할 경우 다음페이지 구현이 되지를 않음


서브쿼리 사용 가능한 위치
- WHERE 조건문
- 컬럼 (스칼라 서브쿼리)
- HAVING 조건문
- FROM 뒤에 (INLINE VIEW)

=======================================
22.05.09 월 - 5일차

셋째마당
10장 데이터를 추가, 수정, 삭제하는 데이터 조작어

10-1 테이블에 데이터 추가하기

명령어 
- 테이블 생성 : CREATE
- 테이블 삭제 : DROP  (데이터를 삭제하는 경우에는 DELETE를 사용)

- 테이블에 데이터 추가 (INSERT INTO, VALUES)
INSERT INTO 테이블명 [(열1, 열2, ... 열N) ]
VALUES (열1 데이터, 열2 데이터, ... 열N 데이터);

COMMIT 하지 않으면 실제 DB에 저장되지 않음

데이터 요청순서 흐름
브라우저 -> (tomcat) -> JAVA -> SQL -> DB

데이터 요청 리턴 순서 흐름
브라우저 <- (tomcat) <- JAVA <- SQL <- DB
                                          DB에서 오류를 뱉어내는 경우있음


INSERT시 컬럼명 생략이 가능하나 열에들어갈 모든 데이터를 순서대로 입력해줘야함

NULL값의 경우 tool에 따라 공백으로 보일 수 있음 (시험에서는 공백으로 나옴)

NULL값 입력하기
 - NULL 지정
 - 빈 공백 ('')으로 지정  -> 선호되지 않음
 - 컬럼명을 생략
보통 공백으로 NULL값을 입력하기보다는 NULL을 지정하거나 열을 지정하지 않는 방식으로 NULL을 입력함

날짜 데이터 입력하기 -> 날짜 형식에 맞춰서 입력하면 됨
- 날짜형식을 인식하지 못할경우 TO_DATE를 사용해서 날짜표기방식 알려주기
- SYSDATE를 사용하여 날짜 입력


서브쿼리를 이용해서 데이터 입력하기 -> VALUES절을 사용하지 않음
INSERT INTO 테이블명 (컬럼명, ...) SELECT ~~  ;


데이터 수정하기 (UPDATE)
- UPDATE 테이블명 SET 컬럼명=데이터, 컬럼명=데이터 WHERE ~ 
- WHERE절은 생략가능하나 없을경우 테이블 안에 모든 데이터가 바뀜 (조심해서 다뤄야함! ★★★★)

롤백 (ROLLBACK;) 
- 수정한 내용을 원상태로 되돌림, TCL명령어 중 하나 (INSERT, UPDATE, DELETE 실행 취소)
- CREATE문을 하는 순간 자동으로 commit이 됨 -> CREATE 이전 실행문들은 롤백이 안됨

서브쿼리를 사용해서 데이터 수정하기
 - UPDATE문에 사용 가능
 - WHERE문에 사용 가능

실수하지 않는 방법 : 조건 확인한 후에 수정 진행할 것

데이터 삭제하기 (DELETE)
 - DELECT FROM 테이블명 WHERE 조건
 - WHERE절을 쓰지않는 경우 테이블에 있는 전체 데이터가 삭제됨



11장 트랜잭션 제어와 세션 

트랜잭션 : 더 이상 분할할 수 없는 최소 수행단위

ALL or NOTHING
- 하나의 트랜잭션 내에 있는 여러 명령어를 한번에 수행하여 작업을 완료하거나 모든 작업을 취소한다.

TCL : 트랜잭션을 제어하기 위해 사용하는 명령어 ( 명령어 예 - COMMIT, ROLLBACK)

ROLLBACK : 하나에 트랜잭션에 속해있는 모든 작업들을 취소하는 명령어
COMMIT : 트랜잭션을 영원히 반영하는 명령어
- COMMIT으로 반영된 내용은 되돌릴 수 없으므로 신중하게 진행해야함!!

SAVEPOINT (시험에 나옴★)
 - ROLLBACK 명령어로 작업을 취소할 때 취소할 지점을 지정할 수 있음 (ROLLBACK TO ~)

세션이란 접속되어있는 상태를 뜻한다
세션(session) : 접속 시작부터 접속 종료까지의 전체기간
- "세션이 여러개" : 현재 서버에 접속해 있는 연결이 여러개라는 의미
- 같은 계정이라도 접속방법이 다르면 다른 세션임

★★
조회 일관성(Read Consistency) : 트랜잭션이 완료되기 전까지 다른 세션에서는 데이터 조작 전 상태의 내용이 일관적으로 조회, 출력, 검색되는 특성

LOCK : 하나의 데이터를 여러 곳에서 동시에 조작하려 할 때 발생할 혼란을 막기 위한 요소

행 레벨 록 (row level lock) 
 - where절을 통해 특정 데이터를 조작할 경우 해당 조건에 속하는 행만 lock이 걸림
 - table 전체 행이 lock이 걸린 경우에도 insert문은 수행이 가능함

테이블 레벨 록 (table level lock)
 - 행의 수와 상관없이 데이터가 변경 중인 테이블은 table 자체에 lock이 걸림 (table단위 잠금)


12장 데이터 정의어(DDL) - (테이블 관련 데이터 정의어)

CREATE, ALTER, DROP 와 같은 DDL 실행은 COMMIT와 같은 효과를 나타냄


NUMBER(7, 2) : 소수점 이하 2번째 자리를 포함한 7자리 숫자를 저장 => 12345.78 (자연수는 5자리까지 가능함)

ALTER : 테이블을 변경하는 명령어
- ADD : 열 추가
- RENAME : 열 이름 변경
- MODIFY : 열의 자료형 변경
- DROP COLUMN : 열 삭제

TRUNCATE : 테이블 데이터를 삭제함 -> DELETE와 결과는 동일함
차이점 
1. TRUNCATE는 DDL이므로 삭제 후 롤백 불가, DELETE는 롤백 가능
2. 테이블 용량이 초기화 됨, DELETE는 용량이 사라지지 않음
3. DROP TABLE : 테이블 자체를 삭제



SQL Developer는 Oracle과 원격형태(Remote, localhost)로 접속하는 과정임
Oracle이 외부접속을 차단하는 경우 SQL developer와 같은 툴이 아닌 터미널을 이용한 방식으로 조작해야함 (명령어 이용, GUI형태는 이용X)


13장 객체 종류 
인덱스 (★★★★★)
-- PK(기본키) or 고유키(Unique key)일 경우에 인덱스는 자동으로 생성됨
인덱스 : 데이터를 빠르게 검색하기 위한 색인 기술
B-tree(Balanced tree) 자료구조(이진트리의 변형된 알고리즘) 사용

장점
- 검색속도 빨라짐
- 시스템 부하를 줄여줌 (성능 향상)

단점 
- 추가 저장공간 필요
- 인덱스 생성 기간 필요
- DML(INSERT, UPDER, DELETE) 작업시 성능 저하장점

/*
인덱스를 적용할 컬럼 (?)
- WHERE 조건절에서 자주 사용되는 컬럼
- 조인 조건에 사용되는 컬럼
- 두개 이상의 조건이 포함되는 경우 -> 복합 인덱스 지정
- 복합 인덱스는 조회 조건이 모든 컬럼이 동시에 지정되어야 함 (복합인덱스 - empno, sal => 조건 - empno, sal)

* 주의사항
- PK, UNIQUE 제약조건에서는 자동 생성
- 해당 컬럼을 가공하기 전 상태에서 조건 지정해야함 -> 함수를 사용해서 데이터를 가공한 결과값은 인덱스 X
- 인덱스 여부도 데이터 모델링 시 고려 필요함
- LIKE는 인덱스 미적용 가능성 높음(예 - %s%)
*/


unique scan
range scan
full scan

인덱스스캔 유도

복합인덱스 사용법
 - 복합인덱스 사용시 조건의 앞에다가 PK로 지정해야 효과가 있음




뷰(VIEW)

정규화 : 테이블을 쪼개는 행위  (시험에 나오는 내용, 따로 공부할 것)
- join을 해야함
1차 정규화 : 
2차 정규화 : 
3차 정규화 : 

반정규화 : 테이블을 합치는 행위
- join할 필요가 없음
- 중복을 줄이고, 조회속도를 향상시킴

테이블을 join하면 속도가 느려지는 단점이 있음 
따라서 초기에 view를 만들어줘서 매번 join을 해야하는 것을 막음 (속도 개선효과)

뷰의 사용 목적 
1. 편리성
2. 보안성 (각 테이블에 대한 접근권한 X, 만들어진 view 테이블에만 접근권한이 있음)
3. 속도개선

-- 권한 부여 (GRANT)
-- 권한 회수 (REVOKE)

시퀀스
-현재값 : currval
-다음값 : nextval

14장
제약조건

종류
- NOT NULL : null값 허용하지 X
- UNIQUE : 중복 X
- PRIMARY KEY : not null + unique + index 지정
- FOREIGN KEY : 다른 테이블의 열을 참조하는 키
- CHECK : 설정한 조건식은 만족하는 데이터만 입력 가능
- DEFAULT : 기본값을 정할 수 있음


데이터 무결성(Data intefrity) : 데이터의 정확성과 일관성을 보장
- 영역 무결성(domain integrity) 
- 개체 무결성(entity integrity) 
- 참조 무결성(referential integrity)


외래키 (Foreign key)
CASCADE : 열 데이터를 삭제할 때 참조하고 있는 데이터도 함께 삭제
- CONSTRAINT [제약조건 이름] REFERENCES 참조테이블 (참조할 열) ON DELETE CASCADE 

SET NULL : 열 데이터를 삭제할때 참조하고 있는 데이터를 NULL로 수정
- CONSTRAINT [제약조건 이름] REFERENCES 참조테이블 (참조할 열) ON DELETE SET NULL


15장 권한

시스템권한, 객체권한

WITH ADMIN OPTION (시험★) : GRANT문을 통해 부여받은 권한을 다른 사용자에게 부여할 수있는 권한도 함께 부여받음.


롤 : 여러 권한을 한번에 부여하고 해제할 수 있도록 여러 권한을 묶어놓은 그룹


요구사항 -> 기획 -> 스토리보드, 화면설계 -> DB 설계

=======================================
22.05.10 화 - 6일차

****************
SQL 총 복습

SELECT
    컬럼명..
FROM 테이블
WHERE 조건
GROUP BY 컬럼명
HAVING 조건
ORDER BY 컬럼 ASC/DESC


JOIN 
- 두개 이상의 테이블에서 조회
FROM a, b
WHERE a.컬럼명 = b.컬럼명

FROM a JOIN B
ON a.컬럼명 = b.컬럼명

INNER JOIN
LEFT/RIGHT OUTER JOIN


Subquery
- query 안에 query


INSERT INTO 테이블명 (컬럼명...) VALUES (값...)
UPDATE 테이블명 SET 컬럼명 = 값... WHERE 조건
DELETE FROM 테이블명 WHERE 조건

********************

데이터 모델링(설계)
- 현실세계에서 일어나는 사건들을 데이터화하는 과정
- 실제 현실은 너무 복잡해서 개념화(추상화)하여 단순하게 표현
- * 추상화, 단순화, 명확화

모델링 단계
개념적 모델링 -> 논리적 모델링 -> 물리적 모델링

개념적 모델링
- ERD(Entity Relationship Diagram)를 만드는 과정
- 엔티티와 속성을 도출

논리적 모델링
- 관계(Relation) 정의, 식별자 정의
- 정규화 수행

물리적 모델링
- 실제 DB에 정의

엔티티/엔터티(Entity) -> 테이블(table)
속성(attribute) -> 컬럼(column)

엔터티
- 관리되어져야하는 데이터의 집합
- 개념, 사건, 장소...
- 유일한 식별자가 있어야 함
- 2개 이상의 인스턴스(행, 데이터)가 있어야함
- 한개 이상의 속성 (식별자 외 1개 이상), 식별자 포함 2개 이상

속성
- 데이터의 가장 작은 논리적 단위
- 엔터티는 반드시 한개 이상의 속성(식별자 제외 1개 이상)으로 이루어져 있음
- 엔터티의 특성, 특징, 속성
- 기본속성, 설계속성, 파생속성

예) 부서 엔터티의 속성 : 부서번호, 부서명


관계(Relationship)
관계차수(Relationship Cardinality)
1:1, 1:N (일대다), N:M (다대다)
식별관계(실선) : 외래키(FK), 데이터 삭제 불가
비식별관계(점선) : 데이터 삭제 가능

ERD툴 사이트 : https://www.erdcloud.com/
- 무료
- 팀간 협업 가능

Mysql 설치

https://www.mysql.com/

다운로드 -> MySQL Community (GPL) Downloads -> MySQL Community Server -> Installer MSI 프로그램 다운 및 설치 -> Setup type : Developer Default

기본포트 번호
- Oracle : 1521
- MySQL : 3306
- MariaDB : 3306
동일한 포트번호를 쓸 수 없음 -> 마리아DB와 MySQL 동시설치시 하나는 포트번호를 바꿔야함 


최고계정 : Root
비밀번호 : root1234

- 최고계정 : 윈도우-Administrator, Oracle-sys, MySQL-Root

MySQL Workbench : 오라클의 sql developer와 동일한 프로그램

sakila -> 샘플 DB
MySQL 
- Schema : 다른 툴에서는 DB로 표현됨

새로운 테이블 생성
- Name : testdb
- Charset/Collation : utf8, utf8_general_ci

계정 생성
Administration 탭 -> Users and Privileges -> Add Account
- Login Name : testuser
- Limit to Hosts Matching (특정 위치에서만 접속이 되게 할 수 있음) : % (아무곳에서나 가능)
- Password : test1234
Schema Privileges -> add Entry -> selected schema(testdb) -> select all -> apply

계정 접속
Connection Name : 즐겨찾기 이름
Username : 생성한 계정 이름 (testuser)
Password : Store in Vault (test1234)


CMD에서 mysql 실행하기
mysql 설치경로 : C:\Program Files\MySQL\MySQL Server 8.0\bin
명령어 : 
실행 : 'mysql -u계정이름 -p' 엔터 후 비밀번호 이름 입력
데이터베이스 보기 : show databases;
테이블 선택 및 사용 : use testdb;
이후 sql 쿼리 작성 
- 예시 : select * from emp;
종료 : \q


=======================================
22.05.11 수 - 7일차
자바프로그래밍
3장 변수

자료형 변수명;  => 변수 선언
예) int a;
변수명 = 초기값; => 변수 초기화
예) a = 10;
자료형 변수명 = 초기값; => 변수 선언과 초기화를 동시에
예) int a = 10;

변수 명명 규칙
- 변수이름에 의미를 부여하자 (★★★)
- 한글이 안되는 것은 아니나 되도록 피하자
- 사용가능한 특수문자 : _ , $

암묵적인 규칙(★★)
1. 클래스명은 첫자를 대문자로
변수나 메서드는 첫자는 소문자로
예) 클래스 - String, Math, 변수/메서드 - numer, println
2. 여러 단어로 이루어진 경우 : 두번째 단어의 첫글자는 대문자로 사용하여 구분 Or '_'로 구분
- Camel 표기법 : lastIndexOf, parseInt, studentNumber
- snake 표기법 : last_index_of, parse_int, student_number
예) 
게시판 댓글 수 : boardcommentcount -> boardCommentCount / board_comment_count
3. 상수는 모두 대문자 (단어구분은 snake표기법으로)
예) PI, MAX_NUMBER

자료형 - 기본자료형, 참조자료형
기본자료형(Primitive Type) : 변수가 값을 직접 가지고 있는 자료형
4가지 자료형만 기억하자 -> 정수형 : int, long, 실수형 : double, 논리형 : boolean
- long을 사용할 때 -> 정수형인데 21억이 넘는 경우

참조자료형(Reference Type)
참조자료형의 예 : 문자열
값을 직접 저장하는 것이 아니라 메모리에 저장된 위치정보를 저장함

상수 : 변하지 않는 수 ( final 키워드 사용)
리터럴 : 값 자체

제어문자(\) 
\n : 줄바꿈
\t : 탭
\\ : \
\' : '
\" : "

변수의 범위 (scope)
- 변수가 사용가능한 범위는 { }을 기준으로 구분할 수 있음

형변환(casting)
기본자료형들은 boolean(논리자료형)을 제외한 나머지 모든 자료형들은 서로 형변환이 가능!
자동형변환 : 작은 자료형 -> 큰 자료형
강제형변환 : 큰 자료형 -> 작은 자료형 (값의 손실이 발생할 수 있음)



4장 연산
기억해야할 연산자
=, +=, -=, +, -, *, /, %, ++, --, ==, !=, >, >=, <, <=, &&, ||, "조건식 ? 참 : 거짓"

% : 나머지를 구하는 연산
정수형 자료형을 나눗셈 연산시 값의 손실이 발생할 수 있는 것 조심해야함

증감연산 
++, -- : 1씩 증가시키거나 감소시킴

삼항연산자
(조건식 ? 값1 :값2 )
- 조건식이 true이면 값1, false면 값2를 반환
- 간단한 조건식을 구현할 때 if문 대신 사용할 수 있음

문자열연산 + 
정수형을 문자열 변수에 대입하지 못함
형변환 방법
1) String.valueOf() : 정수형 -> String으로 변환해주는 메서드
2) 정수형 + "";  : 문자열 연산을 통해 자동형변환이 되는 것을 이용한 방법

연습문제 4장 3~7번 풀어볼 것 -> 완료


5장 제어문
조건문 : if문, switch문
반복문 : for문, while문, do-while문

조건문
(1) if문
if ( 조건문 ) { 
    실행문
} else if ( 조건문 ) {
    실행문
} else {
    실행문
}

else if문 사용시 조건식의 순서에 주의할 것!

(2) switch문 -> 잘 사용 안함
switch (변수) {
    case 값1 :
        실행문1;
        break;
    case 값2 :
        실행문2;
        break;
    default : 
        실행문
}
각 case 실행문마다 break;를 사용해줘야 한다.


/*******************
이클립스 단축키
- shift + 엔터 : 줄바꿈
- alt + 상하키 : 커서가 존재하는 행 이동
- ctrl + alt + 상하키 : 복사
- ctrl + d : 행 삭제
- ctrl + / : 주석 처리
- ctrl + space : 자동완성
- ctrl + F11 : 자동실행
- ctrl + shift + f : 코드 자동 정렬
- ctrl + shift + o : 자동 import
- ctrl + shift + - : 화면 분할
- ctrl + n : 새로운 파일 만들기 (class, package, ... )
- ctrl + m : 작업영역 최대화
- alt+shift+ s -> r (Source 탭 -> Generate getters and setters) : 변수에 접근할 메서드를 생성해줌 (getter, setter)
*********************/

class를 import를 안해줘도 되는 2가지 경우의 수
- java.lang 패키지에 존재하는 클래스
- 동일한 패키지에 있는 클래스

반복문
(1) for문
for (초기화식①; 조건식②; 증감식④) {
    실행문③;
}

실행순서
 ① -> ② -> ③ -> ④
     -> ② -> ③ -> ④
     -> ② -> ③ -> ④
     -> ② -> ③ -> ④
     -> ②(조건 만족시 종료)
	
(2) while문
while (조건식) {
    실행문; (조건식이 true일 경우에만 실행)
}

(3) do~while문
do {
    실행문;
} while ( 조건식 );

끝에 ; 을 붙여야하는 것 주의
조건식이 false여도 최소한 한번은 실행됨
DB에서 사용하는 경우가 있음

(4) 중첩 반복문 
구구단을 통해 값이 변하는 흐름을 이해하기

반복문의 중지 - break, continue
break : 반복문들 빠져나옴
continue : 실행문을 더이상 실행하지 않고 다음 반복으로 넘어감
- 중첩반복문에서 "break 반복문 이름;"을 통해 해당 반복문을 빠져나갈 수 있음

무한반복문
- for (;;) { 실행문; }
- while (true) { 실행문; }
- do { 실행문; } while (true);

5장 연습문제 완료


=======================================
22.05.12 목 - 8일차
연습문제 풀이 (chapter4장 3번~ chapter5장)

조건문에서 boolean 값은 == 연산자 사용하지 않아도 됨
if (boolean == true)    ->     if (boolean)  /  if (!boolean)

이클립스 단축키 
ctrl + m : 작업영역 최대화

alt+shift+ s -> r (Source 탭 -> Generate getters and setters) : 변수에 접근할 메서드를 생성해줌 (getter, setter)
=======================================
22.05.16 월 - 9일차

6장 배열 (여러 값을 하나의 변수로 저장, Array)

6.1 배열의 선언
데이터타입[] 변수명;  // 데이터타입 변수명[];
예) int[] arrInt;    //    int arrInt[];

지역변수는 초기화를 하지 않으면 사용할 수 없다.
new 연산자로 배열 객체를 생성하면 배열의 값이 기본값으로 초기화된다.

기본자료형의 기본값 : 0 ( char : '\u0000', boolean : false)
참조자료형의 기본값 : null (값의 부재)

- String str = "";    -> 빈문자열이 있음
- String str = null;     -> 값의 부재, 존재하지 않음

6.3 다차원배열
0차원 : 스칼라(scalar)
1차원 : 벡터(vector)
2차원 : 행렬(matrix)
3차원이상 : 텐서(tensor)

6.4 배열 복사
- for문을 이용한 복사
- System.arraycopy() 메서드 이용

6.5 향상된 for문 (인덱스를 사용하지 X)
for (타입 변수 : 배열) {  실행문  }
- 간편하게 사용하기 편함
- 단점 : 인덱스를 사용하지 않아서 값을 읽을 수만 있고 변경할 수 없음.

6.6 참조자료형
참조자료형은 메모리의 주소를 저장하고 있음 : 값은 메모리에 저장됨

7장 클래스
객체지향 프로그래밍(Object Oriented Programming)
- 상속
- 다형성
- 추상화
- 캡슐화

7.2 클래스와 객체
클래스 : 설계도
객체 : 설계도로 만들어진 피조물(제품)

객체 선언 -> 클래스명 변수명;
객체 초기화 -> 변수명 = new 클래스명();

객체 선언과 초기화 동시 -> 클래스명 변수명 = new 클래스명();

7.3 클래스의 구조
 - 필드(field, 멤버변수) -> 클래스 내부 전체에서 사용되는 변수
 - 생성자(constructor) -> 객체를 생성할 때 사용됨 (클래스명과 이름이 같음)
 - 메서드(method)

7.4 필드 (멤버변수)

- 클래스 변수 : 객체를 생성하지 않고도 클래스를 통해 이용할 수 있는 변수, 모든 객체가 공유함
- 인스턴스 변수 : 객체를 생성해야만 이용할 수 있는 변수 (static 키워드가 붙지않음)
- 지역변수 : 메서드 수행문과 같은 클래스 내 별도의 중괄호 블럭 내에서 사용되는 변수

생성시기
- 클래스변수 : 클래스가 메모리에 로드될때
- 인스턴스변수 : 객체가 생성될때

7.5장 메서드
메서드의 구조

접근제한자 리턴타입 메서드명 (매개변수...) {
    실행문
    ....
    return 값;
}

접근제한자, 리턴타입 : 있을 수도 있고, 없을 수도 있음

=======================================
22.05.17 화 - 10일차
메서드의 실행 (p166)
- 클래스 메서드 : 클래스명으로 바로 실행 가능 (메서드 선언부에 static 키워드가 있음)
- 인스턴스 메서드 : 객체를 통해 실행이 가능

메서드 실행순서 : 스택(Stack)
- Last In, First Out (FIFO) : 먼저 실행된 메서드가 나중에 종료됨

메서드 오버로딩 
 - 이름이 같은 메서드가 여러개 있음
 - 매개변수의 자료형, 개수, 순서 중에 하나 이상 달라야함

오버로딩(overloading) : 동일한 이름의 메서드를 여러개 정의하는 것 (매개변수가 다름)
오버라이딩(overriding) : 부모에 존재하는 메서드를 자식클래스에서 새롭게 정의하는 것

7.6 생성자 (constructor)
- new 연산자와 함께 객체를 생성할 때 사용함
- 클래스 이름과 생성자 이름이 동일해야함
- 리턴값이 없음
- 객체가 생성될 때 가장 먼저 실행 됨

생성자의 용도 및 목적 : 객체의 초기화!

모든 클래스에는 생성자가 반드시 하나 이상 존재함
클래스 내에 정의된 생성자가 없으면 컴파일러가 자동으로 기본생성자를 추가해줌

참조자료형의 기본값 : null
기본자료형의 기본값 : 0

필드(static 변수, 인스턴스 변수) : 배열의 경우 따로 초기화를 하지 않아도 자동초기화 됨

7.7 this -> 자기자신

VO (Value Object) = 값 오브젝트 (리터럴값 개념) 읽을수만 있고, 값을 변경할 수 없음
DTO (Data Transfer Object)  = 데이터를 오브젝트로 변환하는 객체 (인스턴스 개념)

Source 탭 -> Generate getters and setters
이클립스 단축키 : alt+shift+ s -> r
클래스 변수에 접근해주는 메서드를 자동으로 생성해줌 (getter, setter)


클래스 -> 인스턴스변수, 메서드, 생성자, 스태틱변수

변수 -> 인스턴스변수, 스태틱변수
메서드 -> 인스턴스메서드, 스태틱메서드

7.8 초기화블록 { } 
- 변수 초기화 목적
- 생성자보다 먼저 실행됨

static {    }
- static 초기화블록 : 클래스가 메모리에 로드될때 한번만 실행됨

{    }
- 인스턴스 초기화블록 : 객체가 생성될 때마다 실행됨

7.9 Package 패키지
도트( . ) : 상위 또는 하위 패키지를 구분하는 기호

import
ctrl + shift + o : 자동 import

패키지명 생략 가능 예
1. 같은 패키지에 존재하는 경우
2. 상단 import 구문에 정의한 경우
3. java.lang 패키지에 있는 클래스인 경우

* 사용시 하위패키지에 있는 클래스는 import되지 않음

module-info.java 
- 다른 프로젝트에 있는 클래스를 import해서 사용할 수 있음

7.10 접근제한자
public : 모든 클래스에서 사용가능
private : 같은 클래스 내에서만 사용 가능

default : 동일 패키지 내에서 사용 가능
protected : 동일 패키지 내 + 상속관계에 있는 경우 사용 가능


클래스내 멤버 위치 : 순서는 크게 상관없지만 관례적인 순서가 있다.
class 클래스명 {
     1. 필드 (변수)
     2. 생성자
     3. static 메서드
     4. 인스턴스 메서드    
}

=======================================
22.05.18 수 - 11일차

7.11 싱글톤 (Singleton)
 - 하나의 객체만 생성하도록 하는 기법
 - 생성자의 접근제한자를 private로 설정 -> new 연산자로 객체 생성을 할 수 없음
 - 클래스 내에 객체 생성
 - static 변수이기때문에 객체 생성은 클래스가 로드될 때 한번만 수행됨
 - 적용 예 = 쓰레드, 회원가입, 주문, 스프링 : 데이터에 엑세스해서 기능하는 클래스를 만들때 사용 (저장할 데이터 정보를 싱글톤 기법으로 저장하지는 않음)

7.12 final

final 클래스 : 상속이 불가능한 클래스
final 메서드 : 오버라이딩이 불가능한 메서드
final 변수 : 값이 변경되지 않는 변수 (생성자를 통해 초기화하는 경우에 변경 가능함)
static final (상수) : 값이 변하지 않고 모든 곳에서 공유되는 값

7.13 javadoc

설명하고자 하는 클래스, 필드 및 메서드 위에서 "/**" + 엔터
필드, 메서드에 대한 설명문구를 작성할 수 있음
@param / @return 등등

8장 상속 (부모에게 물려받는 상속)

8.1 클래스 상속
class 자식클래스 extends 부모클래스 {
    ...
}

1. 단일 상속만 가능
2. 자식 클래스를 객체로 생성할 때, 부모클래스가 먼저 객체화 된다.
3. 모든 클래스는 Object 클래스의 하위 클래스다.

8.2 메서드 재정의 (Override)

1. 부모클래스의 메서드와 자식클래스 메서드의 선언부가 동일해야한다.
2. 자식클래스에서 재정의된 메서드의 접근제한자는 부모클래스 메서드의 접근제한자보다 좁은범위를 적용시킬 수 없다.

annotation : @
@Override : 오버라이딩 하는 메서드임을 표시해줌 
 -> 실수하는 것을 줄일 수 있음

8.3 다형성

추상메서드가 있는 클래스는 반드시 추상 클래스다
추상메서드는 자식 클래스에서 무조건 재정의해줘야한다.

부모클래스를 매개변수로 사용하면 모든 자식클래스를 사용할 수 있다.
 - 예 -> Object를 매개변수로 한 경우 모든 클래스 자료형이 대입될 수 있음

8.4 상속관계에서 접근제한자
protected : 다른 패키지에 있어도 상속관계에 있으면 사용 가능
default : 다른 패키지에 있으면 사용 불가

8.5 추상클래스

추상클래스를 상속받는 자식클래스는 추상클래스의 있는 모든 추상메서드를 구현해야한다. 

8.6 객체를 배열로 처리
8.7 final 제어자

=======================================
22.05.19 목 - 12일차
9장 인터페이스
class 키워드 대신 interface 키워드를 사용함

[public] interface 인터페이스명 {
    [public static final] 자료형 상수명 = 값;
    [public abstract] 리턴타입 추상메서드명();
    [public] default 리턴타입 메서드명(매개변수) {    }
    [public] static 리턴타입 메서드명(매개변수) {    }
}

상수
 - 인터페이스 필드는 상수만 선언할 수 있다.
 - public static final 생략하면 컴파일시 자동으로 생성된다.
 - 선언시 반드시 초기화를 해야한다.

추상메서드

default 메서드, static메서드 
 - 구현부가 있어야하나 잘 사용하지 않는다.

9.3 인터페이스 구현
public class 구현클래스명 implements 인터페이스명 {
    // 인터페이스의 모든 추상메서드 반드시 구현!
    ....
}

구현클래스에서 사용하는 키워드는 implements 이다.
여러개의 인터페이스를 구현할 수 있다. 
클래스는 단일상속(실선 표현), 인터페이스는 다중구현(점선 표현)

@Override : 컴파일러에게 상위클래스의 메서드를 오버라이딩하고 있다고 알려주는 표시(anotation)

익명 구현 객체
 - 한번만 사용하는 경우 인터페이스를 구현한 class 파일을 새로 만드는 것은 불편함
 - 실행 클래스에서 이름이 없는 익명 구현 객체로 객체를 생성할 수 있음
 - 실행클래스 내에서 인터페이스를 직접 구현하는 방식

인터페이스 객체명 = new 인터페이스() {
    // 인터페이스의 모든 추상 메서드 구현
};
끝에 ";"를 붙여줘야한다.

매개변수의 다형성

intanceof : 객체의 상속 관계를 확인(?)할 수 있는 연산자
객체 instanceof 클래스(인터페이스)

9.5 default 메서드와 static 메서드
자바 8버전 이후부터 default 메서드와 static 메서드를 인터페이스에서 정의할 수 있도록 개선됨
하지만 잘 사용하지 않는 편임

=====================================================
eclipse 내 컴파일러 버전 바꾸는 법 (자바 버전 바꾸기)
project -> Propertise -> Java Compiler -> Compiler compliance level 수정
=====================================================

9.6 어노테이션(Annotation)
어노테이션 : 프로그램에 추가적인 정보를 제공해주는 메타데이터(metadata)

@Override : 오버라이딩 되지 않으면 에러
@FunctionalInterface : 함수형 인터페이스로 추상메서드가 한개만 가능하도록 설정

어노테이션 정의하기
public @interface 어노테이션명 {
    자료형 요소명() [default 기본값];
}

10장 내부클래스 (중첩클래스)

class 클래스명 {
    class 내부클래스명 {
        ...
    }
}

멤버클래스의 파일명
외부클래스명$내부클래스명.class

로컬클래스의 파일명
외부클래스명$1내부클래스명.class

11장 예외처리 (에러를 미리 대비하자)
오류 : 에러와 예외 포함

에러(error) : 프로그램 코드에 의해서 해결할 수 없는 심각한 오류

예외(exception) : 특수한 상황이 발생하면 프로그램이 중단되는 현상으로 프로그램 코드에 의해서 해결할 수 있는 오류

컴파일 에러 : 컴파일 중에 발생하는 에러
런타임 에러 : 프로그램 실행 중에 발행하는 에러
- 컴파일러가 기본적으로 컴파일 에러를 잡아주지만 런타임 에러는 경우의 수를 예측하여 준비해야한다.

11.3 예외처리
try {  } catch (    ) {    } finally {    }

try {
    에외가 발생할 가능성이 있는 코드
}    catch ( Exception1 e1 ) {
    예외 e1이 발생할 경우 수행할 문장
} finally {
    항상 실행되는 수행문
}

특별한 경우가 아니면 제일 상위클래스인 Exception 클래스로 예외처리를 한다.

throws : 예외떠넘기기 
throw : 예외 발생시키기

finally 구문 말고 바깥에 코드를 짜도 상관없지 않나?
-> try문에서 return문으로 인해 메서드가 종료되더라도 실행됨 

11.6 사용자정의 예외클래스
잘 사용하지 않음

try-with-resource -> try-catch문의 업그레이드 버전

try ( ) {    } catch (    )  {    }
 - try() 괄호 안에서 생성한 객체가 AutoCloseable 인터페이스를 구현한 클래스라면 예외 발생여부랑 상관없이 close() 메서드를 자동으로 해준다.

12장 기본 API

12.1 java.lang 패키지
Object : 표준 클래스의 최상위 클래스
System : 표준 입출력 관련 클래스
Class : 클래스를 메모리에 로드할 때 사용
String : 문자열
StringBuffer, StringBuilder : 문자열 저장하거나 처리할때 사용
Math : 수학관련 기능
Wrapper : 기본자료형의 데이터 관련 클래스

12.1.1 Object 클래스
모든 클래스의 최상위 클래스
toString() : 객체를 문자열화 할때 사용되는 메서드
clone() : 객체를 복제

12.1.2 System 클래스

System.in : 표준 입력 객체
System.out : 표준 출력 객체

12.1.3 Class 클래스
사용용도
- 클래스를 메모리에 로드
- 클래스나 인터페이스의 이름, 생성자, 필드, 메서드 정보를 확인

12.1.4 String 클래스
- new 키워드 없이 "=" 연산자만으로 객체를 생성할 수 있음
- 더하기 연산이 가능함

String은 값을 바꿀 수 없음
String타입 변수 : str
str.indexOf() : ~의 인덱스 -> 활용해서 특정 단어를 포함됐는지 확인이 가능함
      서울시 종로구     , 서울시 종로구
str.trim().equals(str2)
"2,000"
str.replace(",", "")
"    서  울    시 종  로 구     "
str.replace(" ", "")
"낚시,게임,영화,독서"
str.split(",").length

=======================================
22.05.20 금 - 13일차

String class
indexOf() : 특정단어가 포함되어있는지 여부도 확인이 가능함
trim() : 웹개발단계에서는 잘 사용 안함 (프론트단에서 보통 정제되어오기때문), 빅데이터쪽에서는 사용 할 수 있음
replace() : 공백 제거시에 주로 사용됨
split() : 자주 사용한다

문자열 -> 기본자료형
정수형 : Integer.parseInt(String str)
실수형 : Double.parseDouble(String str)

method chaining
형태 : obj.a().b().c().d()
- 각각의 메서드에 리턴값이 존재해야함.
- 리턴타입이 다음 실행될 메서드를 가진 클래스 타입이어야함

12.1.5 StringBuffer, StringBuilder
String 객체는 immutable 객체이다 
- 문자열 변환할때마다 새로운 객체가 만들어진다

StringBuffer, StringBuilder 객체는 mutable 객체
- 동일한 객체에서 문자열 수정이 가능하다

append() : 문자열을 뒤에 추가해주는 메서드

12.1.7 Wrapper 클래스
auto-boxing : 기본자료형을 참조자료형으로 포장
unboxing : 다시 기본자료형으로 변환

12.2 Java.util 패키지
12.2.1 Random 클래스
Random(long seed) -> 매개변수인 seed 값이 동일하면 랜덤값이 동일하게 나옴

12.2.3 Date 클래스

12.2.4 Calendar 클래스
Date클래스보다 나중에 추가된 클래스
서로 변환 가능 : Date 클래스 < - > Calendar 클래스
싱글톤기법으로 클래스가 구성되어있음 (생성자의 접근제한자 protected)
 - new 연산자로 객체생성 불가

혼동할 수 있는 부분
Calendar.MONTH -> 0부터 시작하기 때문에 1을 더해줘야 한다 (1월이 0, 12월은 11)
Calendar.WEEK_OF_MONTH -> 요일 (DB 또는 서버마다 다른 경우가 많아서 실제로 확인해서 작성하자)

12.2.5 Arrays 클래스 -> 배열에 관계된 내용이 있는 클래스

12.3 java.text 패키지

12.3.1 DecimalFormat 클래스 : 숫자와 관계된 포맷팅 클래스

###,###.## 
 - 입력된 자리수만큼만 출력
 5500 -> 5500

000,000
 - 자리수가 고정되서 출력
 5500 -> 005,500

응용 예 (###,###.00 )
 5500 -> 5500.00

12.3.2 SimpleDateFormat 클래스
날짜 포맷팅 관련된 클래스

12.4 java.util.regex 패키지 (정규표현식을 사용하기 위한 클래스를 모은 패키지)
자바스크립트에서 대부분 정규식을 처리하기때문에 자바는 사용할일이 많지는 않음
데이터 분석시에는 많이 사용함


13장 컬렉션 프레임워크 (★★★ : List - ArrayList, Map - HashMap)
인터페이스를 이용한 다형성 개념을 사용할 수 있다.
객체 저장, 처리를 위한 추가, 삭제, 검색을 할 수 있는 다양한 클래스와 인터페이스들의 모임

Collection
 - List : 데이터의 저장되는 순서 유지, 중복저장 가능 ( ArrayList 중요! )
 - Set : 데이터의 저장되는 순서 유지 안됨, 중복저장 불가
Map : 키(key)와 값(value) 쌍으로 저장, 키는 중복 불가 ( HashMap 중요! )

Collection 인터페이스에 정의된 메서드
 - add()
 - size()

13.2 List 인터페이스
자주 사용되는 메서드
 - add() : 객체 추가
 - get() : 객체 리턴
 - size() : 사이즈 리턴

길이를 자유롭게 변경할 수 있음!

ArrayList - ★★★
 - 접근속도가 빠름
 - 데이터 삭제 및 삽입 속도가 LinkedList보다는 느림

대부분 DB에서 select를 한 것을 다루기때문에 ArrayList를 사용하게 됨

13.3 Set 인터페이스
- 중복이 없고, 순서가 없다.
- 중복을 제거할때 사용하기도 한다.

13.4 Iterator와 Enumeration
Iterator : Collection 프레임워크 객체에 저장된 데이터에 접근할때 사용되는 인터페이스 
- cursor가 한칸씩 이동하면서 저장된 데이터를 읽어온다
- List, Set 모두 Iterator를 가지고 있다 (ArrayList는 for문을 사용할 수 있기 때문에 쓸 필요가 없다.)
- Set의 경우 인덱스가 없기때문에 하나씩 출력할때 Iterator를 사용한다.

13.5 Map 인터페이스 
객체를 (key, value)의 형식으로 저장한다.
 - key : 중복 불가  -> mutable한 값은 key로 사용할 수 없다. -> List 불가, String 가능
 - value : 중복 가능

HashMap (★★★) : key의 순서를 알 수 없음
TreeMap : key의 순서 -> 크기순
LinkedHashMap : key의 순서 -> 저장된 순서

자주 사용할 메서드
 - put() : 저장할때 사용
 - get() : key값을 통해 value를 가져옴
 - size() : 키의 수를 반환
 - keySet() : 모든 키를 Set으로 리턴 (중복되지 않기때문에 가능함)

put() 
- 존재하는 키는 value 수정
- 존재하지 않는 키는 value 추가

Map을 출력하는 방법은 여러가지 있음
대부분 아래와 같이 사용하는게 간편함
Set<타입명> keys = map.ketSet();
for ( 타입명 key  : keys ) {
    System.out.println( key );
}

Properties 클래스
 - Hashtable 클래스의 하위클래스
 - key와 value 모두 String인 Map 객체
- 자바 프로그램에서 설정파일을 읽어오는 용도로 많이 사용됨

=======================================
22.05.23 월 - 14일차

클라우드스터딩 - 객체지향
자바 API ~ 상속과 인터페이스

토큰(Token) : 의미를 갖는 최소단위, 더 이상 나눌 수 없는 요소

15장 람다식
코드를 간결하게 할 수있는 장점이 있음
자바스크립트에 있는 callback 개념을 유사하게 구현해낸 것

이름이 없는 익명 함수형태
함수적 인터페이스를 자료형으로 사용함
함수적 인터페이스 : 추상메서드가 한개만 존저해는 인터페이스

16장 스트림 (가독성 좋은 코드 만들기)

람다 활용, 내부반복자를 이용하여 시간과 코드의 양을 줄일 수 있다.
스트림을 이용해서 대용량의 데이터들을 빠르게 처리할 수 있다.

스트림 처리단계
1. 생성하기
2. 가공하기
3. 결과 만들기

17장 스레드
프로세스 : 실행 중인 프로그램을 의미함
스레드 : 프로세스 안에서 작업을 수행하는 것

멀티스레드의 장점
 - CPU, 메모리를 효율적으로 사용할 수 있다.
 - 사용자에 대한 응답성이 높아진다.
 - 작업을 스레드 단위로 분리해서 실행시간을 줄일 수 있다.

쓰레드 생성하는 방법
1. Thread 클래스를 상속
2. Runnable 인터페이스를 구현한 객체를 Thread 객체에 넣어줌

스레드 우선순위
 - 우선순위 값은 상대적인 값이다
 - 스레드를 실행하기 전에 지정해야한다
 - main() 메서드에서 실행하는 스레드인 경우 기본값 5

운영체제에 따라 1~10, 1~7인 경우가 있다. -> 상수값인 MAX_PRIORITY를 사용하기도 한다.

17.5 스레드 동기화 (★)
동기화(Synchronized) : 하나의 스레드가 작업이 끝날때까지 해당 객체가 변경되지 못하도록 하는 것

동기화 <-> 비동기화

ajax (Asynchronized Javascript And Xml) 
 - 비동기로 처리해야하는 기술

18장 입출력 스트림
파일을 첨부하는 기능

스트림 : 데이터를 출발지에서 도착지로 이동할 수 있는 통로

출력 스트림 : 데이터를 도착지로 보냄
입력 스트림 : 외부의 데이터를 읽음

스트림 자료구조 : FIFO (First In, First Out)

입출력 스트림은 단방향임
 - 읽기와 쓰기가 동시에 되지 않음

바이트기반 데이터 (InputStream / OutputStream)
 - 1바이트 단위로 처리됨
 - 주로 영상이나 음악을 처리할때 처리함
 - 편집기로 파일을 열어도 알아볼 수 없음
문자 기반 데이터 (Reader / Writer)
 - 텍스트로 처리되는 데이터, (2바이트)
 - 한글은 2바이트이기때문에 반드시 문자 입출력 스트림에서 처리해야함

BufferedReader (★)
 - 버퍼에 있는 내용을 한 줄씩 읽을 수 있는 readLine() 를 가지고 있는 보조스트림

File 클래스 : 자주 사용됨 (★)
 - 빈번히 사용되는 클래스이다.
 - 파일의 존재여부, 파일의 크기, 마지막 수정날짜 등등

19장 네트워크
클라이언트와 서버
 - 서버 : 서비스를 제공
 - 클라이언트 : 서비스를 사용

IP Address (아이피 주소)
 - 4바이트(32비트)로 이루어진 정수로 이루어짐
 - 4개의 정수 사이에 마침표로 구분되어있음 (각 정수는 0~255사이의 범위)

Port (포트) 
 - 네트워크 상에서 컴퓨터와 컴퓨터가 서로 연결되는 부분

Socket (소켓)
 - 클라이언트와 서버가 특정 포트를 통해 양방향 통신이 가능하도록 만들어주는 소프트웨어 장치

클라이언트와 서버가 연결되는 순서
 1. 클라이언트에서 연결 요청
 2. 서버에서 연결 수락
 3. 클라이언트 처리 요청
 4. 서버에서 처리
 5. 서버에서 클라이언트로 처리 결과 응답

URL Connection 클래스
 - 추상클래스
 - URL 클래스를 이용하여 객체화 생성이 가능함

TCP / UDP
 - TCP/IP 프로토콜 : 다른 시스템간의 데이터 통신을 위한 표준 프로토콜
 - TCP 통신방식은 전화기화 유사
     - 데이터가 잘 전송되었는지 확인이 가능함
     - 속도가 느림
 - UDP 통신방식은 소포와 유사
     - 데이터가 잘 전송되었는지 확인이 불가
     - 속도가 빠름


네이버 API 실습
https://developers.naver.com/main/

공공데이터포털
https://www.data.go.kr/

aeWLdjxAXU_GuuCWUIs3
DAfbQKkzPS




























프로젝트 주제는 익숙한걸로(?)
사용되는 기술이 중요(?)
====================================
22.04.25 월 (선행 1일차)

환경변수(변할 수 있는 수)
JAVA_HOME
-> 자바 설치된 경로

Path
-> 어디서든 해당경로의 파일 실행
%JAVA_HOME%\bin 
	(변환)-> 자바 설치경로\bin\java.exe

GUI : Graphic User Interface
Inter + face
 ~사이에 + 표면

CLI : Command Line Interface

자료형 변수명;

변수/메서드/클래스 명명 규칙
1. 클래스명 첫자를 대문자로
2. 여러 단어로 이루어진 경우 
-> 두번째 이후 단어의 첫자 : 대문자
학생번호 : studentNumber (Camel 표기법, 주로 class명, 메서드명)
-> 단어와 단어 사이에 '_'
학생번호 : student_number (Snake 표기법, 주로 변수명)
3. 상수(항상 같은 수)는 모두 대문자
-> 원주율 : PI


자료형
자료 : 데이터
형 : 타입
데이터타입, 타입, 데이터형, 자료타입, 형...

기본자료형
- 정수(-,+,0), 실수(소수점 있는 수), 논리(참/거짓)
정수 (byte, short, int, long, char)
int : -21억 ~ +21억
long : 21억이 넘는다(긴)
실수 (double)
논리 (boolean) : true/false 둘 중 하나의 값

char (character)
- 문자
- 작은따옴표(')로 감싸서 표현

참조(reference)자료형


줄바꿈이 포함된 상태
안녕하세요
반갑습니다

저는 "홍길동"입니다.

====================================
22.04.26 화 (선행 2일차)

파일의 종류
 - 텍스트
 - 바이너리

변수 (variable, 變數)
vary + able, variety


구조(structure)

int < long < double 


ctrl + d : 코드 한줄 삭제
ctrl + alt + 방향키 : 선택영역 코드 복사

★★
비교연산자 : 결과값은 항상 boolean(true/false)으로 나옴

a == b 같은지 비교
a != b 같지 않은지 비교

&&와 &의 차이
&& : 좌측항이 false이면 무조건 false이기때문에 우측항은 연산하지 않음
&& : 좌측항이 false여도 우측항을 연산하고 결과값 리턴

||와 |의 차이
|| : 좌측항이 true이면 무조건 true이기때문에 우측항은 연산하지 않음
| : 좌측항이 true여도 우측항을 연산하고 결과값 리턴

=====================================
22.04.27 수 (선행 3일차)

연산
* 대입연산
=, +=, -=, *=, /= ....

* 산술연산
+, -, *, /, %

* 증감연산
++, --

* 비교연산
<, >, <=, >=, ==, !=

* 논리연산
&&, ||, !

* 삼항연산
조건 ? 값1(true) : 값2(false)


if문
if (조건문1-결과값이 boolean!) {
    실행문 1
} else if (조건문2 - 결과값boolean) {
    실행문 2
} else {
    실행문 3
}

else문은 있을 수도 있고, 없을 수도 있음


자동 import 단축키 : ctrl + shift + O (알파벳 O)

폰트 : D2 coding  (Il1| 구분이 쉬움)

자바 버전
1.0
1.2 -> java2
1.5 -> java5
1.7 -> java7 (아직 쓰고 있는 곳 많음)
1.8 (★) (제일 많이 쓰고 있음)
9
10
11 (★)
...
18


for문 구조

for (초기화식(1) ; 조건식(2) ; 증감식(4)) { 
    실행문(3)
}

for문 순서
(1) -> (2) -> (3) -> (4)
    -> (2) -> (3) -> (4)
    -> (2) -> (3) -> (4)
    -> (2) -> (3) -> (4) (조건식이 true일 동안 반복)


while문 구조

while (조건식) {
    실행문	(조건식이 true일 동안 반복)
}

자칫하면 무한반복(loop)에 빠질 수 있음


for : 반복횟수가 정해져 있을 때
while : 반복횟수가 정해져 있지 않을 때


반복문 이름 부여
outer : 
for ( ; ; ) { 

    inner :
    for(   ){
    break outer;
    }

}

for문에 이름을 부여(outer, inner)해서 break문을 사용할 경우 중첩 for문을 한꺼번에 나갈 수 있음

===================================
22.04.28 목 (선행 4일차)
복습방법
클라우드스터딩 : https://cloudstudying.kr/
강의 -> "자바 입문하기!"

컴퓨터 과학 (CS, Computer Science)
 - 네트워크, 자료구조, 알고리즘, 데이터베이스


컴퓨터언어 (compile, interpreter)
compile
 - 소스 -> 기계어(실행)
 - C, C++
 - 속도가 빠름
 - 유지보수 어려움, 번거롭다 (코드 하나 수정해도 "컴파일->실행" 과정을 거쳐야함)

JIT (Just In Time) : Java가 여기에 속함 (+ 현재 버전의 Python, JavaScript)
 - 소스 -> 컴파일(바이너리) -> JVM(실행)
 - compile 장점 + interpreter 장점
 - compile 단점 + interpreter 단점

interpreter
 - 소스(실행) => 소스의 한줄씩 번역해서 실행
 - Python, JavaScript
 - 속도가 느림
 - 유지보수가 쉬움 (compile 언어에 비해서)


여러줄 주석 단축키 : Ctrl+Shift+'/' -> 잘 안씀 (그냥 Ctrl+'/' 를 사용함)

웹개발시에는 패키지를 꼭 만들어야한다! (default package 사용X)

메서드 실행(호출) = method call (같은 의미)

===================================
===================================
22.05.02 국비 첫 수업


취업지원센터 김지은 (070-4907-5726, kimje1415@tjoeun.co.kr)
취업지원서비스는 훈련종료 한달 전부터 진행함 (출결 조건을 만족해야함)

오리엔테이션
서류 작성해서 금일 제출 (훈련생 서약서, 개인정보 동의서, 안전수칙 준수 서약서)


지각, 외출, 조퇴 3번시 결석 1번
수업시간 50%를 만족하지 못하면 당일 결석처리됨
출결방법 불일치시 결석처리 (예 - 카드출석+QR퇴실)
9:40까지 정상입실
6:20부터 정상퇴실 (마지막시간 입력시간으로 퇴실 체크됨)
 - 학원 10시30분까지 운영함

공가처리 (단위기간 출석일수의 10% )
 - 병원 진료확인서 (진단서 필요X, 진료확인서는 무료or 2~3,000원, 다음날까지 제출)
 - 입사시험(면접)
 - 훈련 관련 자격증시험

훈련장려금 : 단위기간 기준 15일 이내 지급

교육과정 설계 취지
 - 자바 개발, 데이터 분석을 구분해서 나누지않고 하나의 범위로 구분
 - 데이터 분석이 가능한 자바 웹 개발자
 - 자바 백엔드 개발자 + 데이터 분석
 - 최근 각광받고 있는 엘라스틱 서치 기술 학습

자바
Java - 기본문법, 연산, 제어문, 객체지향 프로그래밍, 클래스와 객체, 자료구조, 자바API, IO, 쓰레드, 네트워크
SQL - (Oracle, MySQL, 데이터모델링, ERD, DML, DDL 데이터조회, 조인, 서브쿼리)
HTML / CSS / JavaScript - HTML 태그, 속성, CSS 사용법, 선택자, JavaScript 문법, jQuery, Ajax
JSP / Servlet - JSP 문법, 내장 객체, Servlet 설정, 매핑, 세션, 쿠키, EL, JSTL, JDBC
Spring Framework - 의존성 주입(DI, Autowired), AOP, Interceptor, 모델2/MVC구조, MyBatis 연동, RestAPI
Util - Git(소스 버전 관리), Maven(빌드 도구), Junit(테스트 도구)
서버 배포 - AWS 서버 구축, java, tomcat, mysql 설치, 웹 어플리케이션 배포/구동

빅데이터
SQL, 파이썬, 데이터 수집, 데이터 전처리, 데이터 시각화, 기초수학, 머신러닝, 딥러닝, NoSQL, API

SQL - RDBMS 데이터 분석
파이썬 - 기본문법, 연산, 제어문, 객체지향프로그래밍, 클래스와 객체, 자료구조, 입출력, 모듈/패키지
데이터 수집 - API, 웹 크롤링, 데이터베이스 연동
데이터 전처리 - Numpy, Pandas, excel/csv 파일 다루기, JSON 파일처리, 결측값, 이상값 처리
데이터 시각화 - matplotlib, seaborn, 시각화 종류 및 시각화 실습
머신러닝 - Tensorflow, ~
API - Flask(파이썬 웹 프레임워크 )서버 구축, API 서버 구현


중요함!!  - Java, SQL, SpringFramework

엘라스틱 서치
 - 오픈소스 검색엔진, 대용량 데이터 저장소
 - 단순 RDBMS 검색이 아닌 비정형 텍스트 색인 검색기능
 - 자동완성 및 초성 검색기능


프로젝트
자바 웹 프로젝트, 데이터 분석, 검색엔진


여유가 있을 때 개인프로젝트 진행하자

SQL 교재 (Do it! 오라클로 배우는 데이터베이스 입문)
★★★ 둘째 마당 : 중요함 
셋째 마당 : 이해정도만 하면 됨
넷째 마당 : SQL로 프로그래밍 하는 법 (수업 X)

dataq.or.kr : 데이터 자격검정 홈페이지

용어 암기 (★★★)
 - 개체(entity) 
 - 속성(attribute)
 - 관계(relationship)

~/workspace/tjoeunacademy_test/ABC쇼핑몰.xlsx
ABC쇼핑몰.xlsx (파일) => DB (schema)
회원(시트) => table
홍길동(데이터) => record, row....


entity(개체) : 데이터화 하려는 사물, 개념의 단위 (회원, 주문내역, 상품리스트) => table
atrribute(속성, 특징) : 엔티티(entity)가 가지는 항목 => 열(column)
relationship(관계) : 개체와 개체간의 연관성 => fk (foreign key, 외래키) 외 다양하게 구현


독립성(independency) <-> 의존성(dependency)
 독립성 : 하위스키마를 변경하더라도 상위스키마가 영향을 받지 않는 특성
특정 스키마가 변경되더라도 다른 계층의 스키마는 변경할 필요가 없음
 
무결성(integrity)
 - 데이터의 정확성, 일관성, 유효성이 유지되는 것을 말함

면접시 물어볼 수 있는 SQL의 분류
 - DQL (Data Query Language) : 데이터를 원하는 방식으로 조회하는 명령어 (DML에 포함되기도 함)
 - DML (Data Manipulation Language) : 데이터를 저장, 수정, 삭제하는 명령어
 - DDL (Data Definition Language) : 데이터 관리를 위해 테이블을 포함한 여러 객체를 생성, 수정, 삭제하는 명령어
 - TCL (Transaction Control Language) : 트랜잭션 데이터의 영구 저장, 취소 등과 관련된 명령어
 - DML (Data Control Language) : 데이터 사용 권환과 관련된 명령어


행 = row = record = tuple(튜플) (실무에서는 row라는 표현을 많이 씀)
열 = column = field = attribute (실무에서는 colums이라는 표현을 많이 씀)

열(column) : 데이터의 종류(자료형), 저장가능한 값의 최대길이 등 저장 조건과 범위를 지정할 수 있음


row, raw 혼동하기 쉬움


기본키 (PK, Primary key) - ★★
보조키
외래키 (FK, Foreign key) - ★★

기본키
- 저장된 행을 식별할 수 있는 유일한 값
- 가장 중요한 키로서 한 table에서 중복되지 않는 값만 가지는 키
- Null 값을 가질 수 없음

보통 개인정보 노출이 가장 적은 데이터를 기본키로 지정함
 - 학번, 아이디, 주민번호 => 학번을 기본키로 지정
 - 일반 웹사이트 => 식별을 위한 회원번호를 기본키로 사용 (외부에 노출은 안하고 내부적으로만 사용함)

보조키 = 대체키(alternate key) = 후보키(candidate key)
 - 기본키가 될 수 있는 후보키, null값이 없는 키

외래키(FK)
 - 특정 테이블에 포함되어있으면서 다른 테이블의 기본키로 지정된 키
 - 데이터의 중복을 피하기 위해서 필요함.

실무에서는 보통 테이블이 수십개에서 수백개, 데이터는 억단위를 넘는 경우가 흔함

일부러 외래키를 정의하지 않고 테이블간에 관계를 "느슨하게" 설계하는 경우도 있음
 -> ex) 회원정보 삭제시 지난주문내역 삭제가 발생하는 것을 막기위함

주민등록번호는 법적으로 수집이 금지되었음 (암호화하더라도 수집하면 안됨)

자료형(Data type) 
 - 주로 쓰는 자료형(★★★) : VARCHAR2, NUMBER, DATE
 - 블로그에 내용을 쓰는 경우(★★) : CLOB ( VARCHAR2는 용량에 한계가 있음)

char(character) - 고정문자열
varchar(variable character) - 가변문자열

scalar(0차원) - vector(1차원) - matrix(2차원, 행렬) - tensor(3차원 이상)
scalar : 

이 외에도 여러가지 자료형이 있음 (컬렉션형 - VARRAY, NESTED TABLE)


객체(Object) - SQL 언어에서는 그저 하나의 단위 정도로 생각하자
p40~41 단어 알아야함 - table, index, view, sequence, synosym, procedure, function, package, trigger

PL/SQL - 변수, 조건문, 반복문과 같은 프로그래밍 언어를 사용할 수 있음
최근 PL/SQL을 안쓰려고 하는 추세임 (사용하는 경우 Oracle에 종속되기 때문, 다른 RDBMS로 갈아타기 어려움)


오라클 데이터베이스 설치 
oracle.com -> Resources -> Downloads -> DB Express -> Oracle Database 21c Express Edition 윈도우 64비트 버전 설치
D:\kdigital_a\oraclexe
비밀번호 : sys1234

Oracle DB는 삭제하는 과정이 복잡함
- 일반적인 삭제 과정을 거친 후 레지스트리 삭제 프로그램으로 청소 진행할 것

SQL developer 설치
oracle.com -> Resources -> Downloads -> SQL Developer (자바 포함된 버전으로)
설치 X, 압축만 풀면 됨

SQL Developer
새로만들기 
- 사용자 이름 : sys
- 롤 : sysdba  (최고관리자 권한)
- 비밀번호 : sys1234
- 호스트 : localhost
- 포트 : 1521
- SID : xe (서비스아이디, 무료버전이라 xe로 고정되어있음)
(위 정보들이 있어야 DB에 접속할 수 있음.)

보기 -> DBA -> 하단 창 추가
DBA 창 -> '+'버튼 -> 이전에 추가한 사용자 이름으로 접속
sys -> 저장영역 -> 테이블스페이스(우클릭) -> 새로만들기
- 파일이름 : TEST
- 파일크기 : 500M
- 자동확장 설정 : 체크표시 (다음크기 100M : 용량이 차면 자동으로 용량 확장하는 설정, 최대크기 : 제한없음)


계정 추가
'다른 사용자' 우클릭 -> 사용자 생성
- 사용자 이름 : TESTUSER (대문자로 해야함)
- 비밀번호 : test1234
- 기본 테이블스페이스 : TEST 선택
- 임시 테이블스페이스 : TEMP 선택
- 부여된 롤 : CONNECT, RESOURCE
- 할당량 : TEST -> '무제한'

적용 클릭시 에러발생
- 원인 : 계정명 앞에 "C##" 시작하는 계정명만 가능
일반이름으로 생성시키는 방법 ↓↓↓
- sys 워크시트에서 명령어 실행 - alter session set "_oracle_script"=true;


새로운 접속정보 생성
새로만들기 
- 사용자이름 : testuser
- 비밀번호 : test1234
- 롤은 그대로 (기본값)

사용해본 명령어
- desc emp;
- select * from emp;

sql은 대소문자 구별 없음
워크시트 내용 저장할 필요 없음

========================================
22.05.03 화 - 2일차

SQL 주석 
방법 1 : -- 한줄 주석
방법 2
/*
여러줄 주석
*/


SQL문 실행에 띄어쓰기/줄바꿈은 아무런 문제가 없다.

(가독성을 위해서)
보통 SQL명령문은 대문자, 그외(테이블명, 열이름)는 소문자로 쓴다 
줄바꿈/들여쓰기를 한다
실무에서 프로그래밍언어와 구분하기 위해 SQL문 전체를 대문자로 사용하는 경우도 있음.


DML (Data Manipulation Language) : 데이터 관련 명령어
- 데이터 조작 언어
- 데이터를 조회(DQL), 등록, 수정, 삭제

DDL (Definition) : 테이블 관련 명령어
- 데이터 정의 언어
- 테이블 생성, 변경, 삭제

DCL (Control) : 데이터베이스 권한 관련 명령어
- 데이터 제어 언어
- 데이터베이스 접근권한 제어

TCL (Transaction Control Language)
- 트랜잭션(논리적 작업 단위) 제어
(트랜잭션 : 논리적 기능을 수행하기 위에 한번에 작업되어야 하는 일련의 연산단위(?))


4-1 SELECT문
SELECT : 데이터를 조회하는 데 사용되는 명령어

테이블 탭에서 중요하게 봐야할 하위탭 : "데이터", "제약조건"

JOIN : 테이블끼리 또는 테이블과 같은 다른 요소(뷰, view)를 활용하여 JOIN문을 활용할 수 있음.

Select문 사용할 때 고려사항
- 어디에서 가져올 것인지 (어떤 table)
- 어떻게 가져올지 (전체, 일부 column)
- 어떤 값을 출력할지 (where)

기본구조
SELECT 열이름 [AS 별칭], .... 
FROM 테이블명
[WHERE 조건식]
[ORDER BY 열이름 [ASC or DESE]]

[ ] : 생략이 가능(모든 경우는 아니나 생략이 가능하다는 뜻으로 사용되는 경우가 많음)

";" : 문장 구분을 위해서 필요함 (한개의 문장을 실행할 때에는 ';' 가 없어도 됨)


DISTINCT : 조회할 때 중복값을 제거

SELECT 컬럼 FROM 테이블 GROUP BY 그룹화할 컬럼;   -> 잘 안씀

select ename, sal, comm, sal*12+comm as 연봉 from emp;  
-- as 별칭을 부여할 때 사용 
-- comm값에 null값이 포함되어서 null값으로 출력됨 (null 값은 연산 불가)

-- null이면 0으로 처리해주는 함수 : NVL(a , b)    (a = 열 이름, b= null값이 반환할 값)
select ename, sal, comm, sal*12+NVL(comm, 0) as 연봉 from emp;
select comm, nvl(comm, 0) from emp;

as (별칭, alias)
- 별칭에 띄어쓰기가 있는 경우 큰따옴표(" ")로 묶어서 사용
- 써도 되고 안써도되나 가독성 때문에 잘 안씀


ORDER BY
- 정렬의 기본값은 ASC (오름차순)

SELECT *
FROM emp
ORDER BY deptno ASC, sal DESC;
 - 선언한 순서대로 정렬 1순위, 2순위

정렬을 사용(ORDER BY)하는 것이 속도를 깎아먹는 주 요인임 => index를 사용하는 경우 일정부분 해소가 가능함
그러나 정렬을 하지 않는 경우는 거의 없음

ORDER BY는 항상 문장 맨 끝에 와야함


2022 개발자 설문조사
https://programmers.co.kr/pages/2022-dev-survey

프로그래머스 코딩테스트 -> SQL 고득점 Kit


쇼핑몰, 금융권, 교육기관 : 프로젝트를 해본 경험이 있는게 좋음

WHERE 조건식 : 해당 조건에 true인 것만 선택해서 출력함
SELECT * FROM emp WHERE deptno = 30;

AND / OR
WHERE문에 여러개의 조건식을 사용할 수 있다.

AND (그리고)
A AND B : A가 참이고 B도 참이면 결과는 참 (둘다 참 -> 참)
OR (또는)
A OR B : A가 참이거나 또는 B가 참이면 결과 참 (둘 중 하나 이상이 참 -> 참)

성별이 여자 AND 나이가 30 이상 = 여자이면서 30 이상
성별이 여자 OR 나이가 30 이상 = 여자/30미만(30이상), 남자/30이상

SELECT * FROM emp WHERE deptno = 30 AND job = 'SALESMAN';
테이블 안에 들어있는 문자열 데이터는 대,소문자를 구별한다!
 - 데이터 값이 대문자이면 대문자로 조건문 작성, 소문자이면 소문자로 조건문 작성


SQL문은 나머지연산을 제공하지 않음. 사칙연산(+, -, *, /)만 가능


!=, <>, ^= : 같은 의미로 사용되는 연산자 (A != B : A와 B가 같지 않는 경우)
"NOT 조건식" 의 형태가 사용되기도 함

IN 연산자 : OR 연산자의 중복사용을 막을 수 있음

BETWEEN 연산자 a AND b 
- a와 b 사이의 값 (a값, b값 포함됨)

-날짜 검색도 BETWEEN 연산으로 가능하다
1981년 입사한 직원
SELECT * FROM emp WHERE hiredate BETWEEN '1981-01-01' and '1981-12-31';

날짜 표시형식 변경방법
 - 도구 -> 환경설정 -> 데이터베이스 -> NLS -> 날짜형식 변경
RR/MM/DD 또는 RRRR-MM-DD 등 가능


AND -> BETWEEN
OR -> IN


LIKE (★★)
- 텍스트 검색할때 주로 사용되는 연산자 ( '_', '%')
- 주로 % 만 사용됨
- 데이터 조회 속도가 느려지는 원인이 됨

김
김구
김구라

LIKE '김_'  -> 조회 데이터 (김구)
LIKE '김%' -> 조회 데이터 (김, 김구, 김구라)



-- NULL 값인 것만 출력하기 (IS NULL)    ★★★
SELECT ename, sal, comm FROM emp WHERE comm IS NULL;

-- NULL 값 제외하고 출력하기 (IS NOT NULL)   ★★★
SELECT ename, sal, comm FROM emp WHERE comm IS NOT NULL;

에러가 나지 않기때문에 SQL문이 잘못됐는지 확인하기 어렵다
사용법을 제대로 익혀두자

집합연산자 (UNION, UNION ALL, MINUS, INTERSECT)

UNION : 합집합, 중복제거
UNION ALL: 합집합, 중복값 출력 (실무에서는 UNION ALL을 많이 씀)
MINUS : 차집합
INTERSECT : 교집합

자유게시판, 유머게시판

최근게시물
제목, 작성일이 같아도 둘다 출력되게끔함! (자유게시판, 유머게시판)


6장 함수
SQL은 거의 동일하지만 함수는 DB마다 다른 경우들이 있음.
함수도 대소문자 구분 X

UPPER()
LOWER()
LENGTH()

dual 테이블  -> 더미(dummy) 테이블 (임시연산이나 함수의 결과값 확인을 위해 사용됨)
SELECT sysdate from dual; 
- 현재 날짜를 보고 싶을 때 dual 테이블을 이용해서 간편하게 확인함

SUBSTR()   -> (substr/ing)
"안녕하세요"
"안녕", "안녕하"

SUBSTR(문자열 데이터, 시작위치, 추출길이)
SUBSTR(문자열 데이터, 시작위치)

INSTR() -> 문자열 데이터 안에서 특정 문자 위치를 찾는 함수
Oracle index는 1부터 시작함!

REPLACE() : 자주 사용됨 (프로그래밍 언어에서도 사용됨)
- 특정 문자를 바꾸는데 사용

TRIM, LTRIM, RTRIM
-- 원래 특정 문자를 trim하는 용도로 사용함 (잘 사용 안함)
-- 주로 공백을 제거하는 용도로 사용됨
TRIM
-- both : 왼쪽+오른쪽, leading : 왼쪽, trailing : 오른쪽
'서울시'
'       서울시'
'서울시         '

LPAD, RPAD : 빈공간을 특정 문자로 채워줌

CONCAT : 두 문자열을 합치는 함수
 - oracle에서는 '||' 연산자가 동일한 기능을 함, 매우 편리하나 사용하지 않는게 좋음


=============================================
22.05.04 수 - 3일차

SQLD 문제집 자료 - 클래스룸
과목 1, 2만 공부하면 됨
과목3은 할 필요 없음 (SQLP 과정)

숫자 관련 함수 
1. ROUND : 특정 위치에서 반올림
2. TRUNC : 특정 위치에서 버림
3. CEIL : 올림
4. FLOOR : 내림
5. MOD : 나머지 값을 반환

날짜 관련 함수
- 날짜 '+'/'-' 숫자 연산 가능
- 날짜끼리 '-' 연산은 가능하나 '+' 연산은 불가능함
1. SYSDATE : Oracle 서버가 놓인 OS의 현재 날짜 및 시간
2. ADD_MONTHS : 몇 개월 이후 날짜
3. MONTHS_NETWEEN : 개월수 차이 
4. NEXT_DAY : 돌아오는 요일 반환
5. LAST_DAY : 달의 마지막 날짜 반환

형 변환 함수
1. TO_CHAR : 숫자/날짜 -> 문자열
2. TO_NUMBER : 문자데이터 -> 숫자형
3. TO_DATE : 문자데이터 -> 날짜 데이터


NULL 처리 함수
1. NVL함수
2. NVL2 함수

조건에 따른 데이터 처리함수
1. DECODE
2. CASE

DECODE : 간단한 경우에 사용, 다른 DB에 없는 경우 있음
CASE
 - 복잡한 경우에 사용 (DECODE가 표현할 수 없는 방식도 지원함)
 - DECODE에 비해 범용적으로 사용이 가능함

랭킹 함수 (★★★★★)
- ROW_NUMBER() : 중복없이 전체 순서 지정       (공동 등수 X)
- RANK() : 중복되면 하위랭킹 제외 후 순서 지정 (공동 1등이면, 다음 순위 3등)
- DENSE_RANK() : 중복되면 하나의 랭킹으로 지정 (공동 1등이면, 다음 순위 2등)

over : (공통 정렬 기준)

SELECT 
    sal, 
    ROW_NUMBER() OVER (ORDER BY sal DESC) AS rank1, 
    RANK() OVER (ORDER BY sal DESC) AS rank2, 
    DENSE_RANK() OVER (ORDER BY sal DESC) AS rank3
FROM emp;


7장 다중행 함수와 데이터 그룹화

SUM()
COUNT()
AVG()
MIN(), MAX()
VARIANCE(), STDDEV

그룹함수는 항상 NULL을 제외하고 리턴함
'*' 사용이유 : NULL값을 포함한 전체 행의 개수를 알고싶을 때는 COUNT(*)을 사용함
또는 Primary_Key 컬럼을 COUNT 하는 방법도 있음


group by : 값이 같은 행끼리 묶어서 그룹핑
~별(월별, 부서별, 연도별 등등) -> group by 사용

HAVING - group by 결과의 조건 지정


SQL문 실행순서!

        어디에서 (FROM)
        어떻게
         - 조건에 해당하는 데이터만 (WHERE)
         - 그룹핑 (GROUP BY)
         - 그룹핑된 조건 (HAVING)
         출력 컬럼 (SELECT)
         정렬 (ORDER BY)
         
         AS (Alias)도 위 순서에 영향을 받음



======================================
22.05.06 금 - 4일차

p195
7.4 그룹화와 관련된 여러 함수 (시험에는 항상 나옴, ★★★★)

사실 잘 쓰지 않음 + oracle에 종속된 함수

- ROLLUP : 데이터의 합계 출력
- CUBE : 결합 가능한 모든 조합의 그룹핑
- GROUPING SETS : 컬럼별 별도 합계

이런 데이터가 필요하면 보통 프로그래밍 언어단에서 처리함

LISTAGG : 잘 사용 X

PIVOT : 엑셀과 동일한 기능
- 행을 열로 바꿔줌 (단순히 바꾸는 것은 아니고 정리해서..)


8장 JOIN

JOIN의 종류
* cross join (크로스 조인) : 가능한 모든 행 조인
* euqi join (등가 조인, ★★) : 조건이 일치하는 결과만 출력 => inner join
* no euqi join (비등가 조인) : 조건이 일치하지 않는 결과 출력
* outer join (외부 조인, ★★) : 양쪽 테이블의 한쪽만 조건이 일치해도 출력 => left join, right join 
* self join (자체 조인) : 자기 자신 테이블 조인


join 그림 - 슬랙 참조 (or 구글에 join 검색)

실제 실무에서는 *을 잘 사용하지 않고 직접 column명을 입력해줌
변경사항이 생겼을 경우 프로그램 수정이 쉽지 않기때문


표준(ansi) 조인방식 
1.  , -> JOIN
2. WHERE -> ON
- JOIN, ON 표현방식에 익숙해지자

시험에 나오는 부분 (★)
- 필요한 조건식의 최소 개수 : 조인 테이블 개수에서 하나를 뺀 값


자체조인
예) 
원하는 출력형태 : 직원번호, 직원명, 상사직원번호, 상사명
-> 상사명은 emp 테이블에 없기때문에 동일한 테이블을 JOIN함

LEFT OUTER JOIN (오라클 방식)
SELECT e1.empno, e1.ename, e1.mgr, e2.ename
FROM emp e1, emp e2
WHERE e1.mgr = e2.empno(+);

LEFT OUTER JOIN (ANSI 방식, 표준)
SELECT 
    e1.empno, e1.ename, e1.mgr, e2.ename
FROM emp e1 LEFT OUTER JOIN emp e2   
ON e1.mgr = e2.empno;


LEFT JOIN : 왼쪽 테이블 데이터가 다 나옴
RIGHT JOIN : 오른쪽 테이블 데이터가 다 나옴


표준문법
- NATURAL JOIN : 자동으로 join 해줌 (기준이 명시되어있지 않아 실무에서는 잘 사용 안함)
- JOIN ~ USING : ON 과 비슷하나 잘 사용 안함
- JOIN ~ ON : WHERE절과 동일함

3개 이상의 테이블 조인은 잘 사용 안함
FROM table1 JOIN table2 ON (조건식) 
JOIN table3 ON (조건식)


기본 구조
1. INNER JOIN
1-1 oracle 형식
FROM t1, t2
WHERE t1.x = t2.x;

1-2 표준형식
FROM t1 JOIN t2
ON t1.x = t2.x;

2. OUTTER JOIN
2-1 oracle 형식
FROM t1, t2
WHERE t1.x = t2.x(+)

2-2 표준형식
FROM t1 LEFT JOIN t2
ON t1.x = t2.x


CONNECT BY (계층형 / 트리구조) 조회 : Oracle에서만 가능
- 시험에서 자주 나옴
-- 기본구조
SELECT
    empno, mgr, ename
FROM emp
START WiTH mgr IS NULL      -- 시작 조건
CONNECT BY PRIOR empno = mgr; -- 조인 조건

-- 추가 구조
SELECT
    level,                  -- 계층형태를 알려줌
    LPAD(' ', 4*(LEVEL -1)) || empno,   -- 계층형태를 눈으로 보기 쉽게 하기 위함
    mgr, ename
FROM emp
START WiTH mgr IS NULL      -- 시작 조건
CONNECT BY PRIOR empno = mgr; -- 조인 조건


 9장(★★★★★) - 서브쿼리

SELECT문을 괄호로 감싼 것 => 서브쿼리

단일행 서브쿼리 ( =, !=, >, <, ....) : 실행값이 1 row인 쿼리
다중행 서브쿼리 (IN, NOT IN, ANY, ALL) : 실행값이 1 row 이상인 쿼리

다중행 서브쿼리
* IN        : 메인쿼리의 데이터가 서브쿼리의 결과값과 하나라도 일치하면 true
* ANY, SOME : 메인쿼리의 조건식을 만족하는 서브쿼리 결과가 하나 이상이면 true
* ALL       : 메인쿼리 조건식을 서브쿼리 결과값 모두가 만족하면 true
* EXISTS    : 서브쿼리의 결과가 하나라도 존재하면 true


/*
뷰(VIEW)
- 가상의(논리적) 테이블
- INLINE VIEW (코드 안에 뷰)
*/

-- SELECT문을 사용해서 가상의 테이블(view)을 만들고 FROM의 대상으로 사용할 수 있음


/*
데이터가 많은 경우
JOIN을 하고 조건을 넣는 것과                       -> 단순 JOIN
데이터를 줄여서 JOIN하는 것과는 속도차이가 있음    -> VIEW를 이용해서 데이터를 줄인 후 JOIN
*/


스칼라 서브쿼리 => 단일행
- SELECT절에 오는 서브쿼리로 반드시 하나의 결과만 반환해야함
- 한 행을 조회할때마다 실행되기때문에 속도가 느림


페이징처리 => rownum 이용, 서브쿼리 2번 사용
- rownum : 행에 번호를 부여해줌
- 2번 감싸야 페이징 처리가 된다 (서브쿼리 안에 서브쿼리)
- 정렬을 하기 위함

SELECT 
    *
FROM (
    SELECT rownum rnum, a.*     -- 넘버를 부여하는 서브쿼리
    FROM (
        SELECT empno, ename     -- 시간대 순으로 정렬하는 서브쿼리
        FROM emp
        ORDER BY hiredate
    ) a
) b
WHERE b.rnum BETWEEN 1 AND 10;  -- 페이징 처리를 위한 BETWEEN 조건절

- 인터넷에 한번만 감싸는 형태로 페이징처리 구현했다고 하지만 그렇게 할 경우 다음페이지 구현이 되지를 않음


서브쿼리 사용 가능한 위치
- WHERE 조건문
- 컬럼 (스칼라 서브쿼리)
- HAVING 조건문
- FROM 뒤에 (INLINE VIEW)

=======================================
22.05.09 월 - 5일차

셋째마당
10장 데이터를 추가, 수정, 삭제하는 데이터 조작어

10-1 테이블에 데이터 추가하기

명령어 
- 테이블 생성 : CREATE
- 테이블 삭제 : DROP  (데이터를 삭제하는 경우에는 DELETE를 사용)

- 테이블에 데이터 추가 (INSERT INTO, VALUES)
INSERT INTO 테이블명 [(열1, 열2, ... 열N) ]
VALUES (열1 데이터, 열2 데이터, ... 열N 데이터);

COMMIT 하지 않으면 실제 DB에 저장되지 않음

데이터 요청순서 흐름
브라우저 -> (tomcat) -> JAVA -> SQL -> DB

데이터 요청 리턴 순서 흐름
브라우저 <- (tomcat) <- JAVA <- SQL <- DB
                                          DB에서 오류를 뱉어내는 경우있음


INSERT시 컬럼명 생략이 가능하나 열에들어갈 모든 데이터를 순서대로 입력해줘야함

NULL값의 경우 tool에 따라 공백으로 보일 수 있음 (시험에서는 공백으로 나옴)

NULL값 입력하기
 - NULL 지정
 - 빈 공백 ('')으로 지정  -> 선호되지 않음
 - 컬럼명을 생략
보통 공백으로 NULL값을 입력하기보다는 NULL을 지정하거나 열을 지정하지 않는 방식으로 NULL을 입력함

날짜 데이터 입력하기 -> 날짜 형식에 맞춰서 입력하면 됨
- 날짜형식을 인식하지 못할경우 TO_DATE를 사용해서 날짜표기방식 알려주기
- SYSDATE를 사용하여 날짜 입력


서브쿼리를 이용해서 데이터 입력하기 -> VALUES절을 사용하지 않음
INSERT INTO 테이블명 (컬럼명, ...) SELECT ~~  ;


데이터 수정하기 (UPDATE)
- UPDATE 테이블명 SET 컬럼명=데이터, 컬럼명=데이터 WHERE ~ 
- WHERE절은 생략가능하나 없을경우 테이블 안에 모든 데이터가 바뀜 (조심해서 다뤄야함! ★★★★)

롤백 (ROLLBACK;) 
- 수정한 내용을 원상태로 되돌림, TCL명령어 중 하나 (INSERT, UPDATE, DELETE 실행 취소)
- CREATE문을 하는 순간 자동으로 commit이 됨 -> CREATE 이전 실행문들은 롤백이 안됨

서브쿼리를 사용해서 데이터 수정하기
 - UPDATE문에 사용 가능
 - WHERE문에 사용 가능

실수하지 않는 방법 : 조건 확인한 후에 수정 진행할 것

데이터 삭제하기 (DELETE)
 - DELECT FROM 테이블명 WHERE 조건
 - WHERE절을 쓰지않는 경우 테이블에 있는 전체 데이터가 삭제됨



11장 트랜잭션 제어와 세션 

트랜잭션 : 더 이상 분할할 수 없는 최소 수행단위

ALL or NOTHING
- 하나의 트랜잭션 내에 있는 여러 명령어를 한번에 수행하여 작업을 완료하거나 모든 작업을 취소한다.

TCL : 트랜잭션을 제어하기 위해 사용하는 명령어 ( 명령어 예 - COMMIT, ROLLBACK)

ROLLBACK : 하나에 트랜잭션에 속해있는 모든 작업들을 취소하는 명령어
COMMIT : 트랜잭션을 영원히 반영하는 명령어
- COMMIT으로 반영된 내용은 되돌릴 수 없으므로 신중하게 진행해야함!!

SAVEPOINT (시험에 나옴★)
 - ROLLBACK 명령어로 작업을 취소할 때 취소할 지점을 지정할 수 있음 (ROLLBACK TO ~)

세션이란 접속되어있는 상태를 뜻한다
세션(session) : 접속 시작부터 접속 종료까지의 전체기간
- "세션이 여러개" : 현재 서버에 접속해 있는 연결이 여러개라는 의미
- 같은 계정이라도 접속방법이 다르면 다른 세션임

★★
조회 일관성(Read Consistency) : 트랜잭션이 완료되기 전까지 다른 세션에서는 데이터 조작 전 상태의 내용이 일관적으로 조회, 출력, 검색되는 특성

LOCK : 하나의 데이터를 여러 곳에서 동시에 조작하려 할 때 발생할 혼란을 막기 위한 요소

행 레벨 록 (row level lock) 
 - where절을 통해 특정 데이터를 조작할 경우 해당 조건에 속하는 행만 lock이 걸림
 - table 전체 행이 lock이 걸린 경우에도 insert문은 수행이 가능함

테이블 레벨 록 (table level lock)
 - 행의 수와 상관없이 데이터가 변경 중인 테이블은 table 자체에 lock이 걸림 (table단위 잠금)


12장 데이터 정의어(DDL) - (테이블 관련 데이터 정의어)

CREATE, ALTER, DROP 와 같은 DDL 실행은 COMMIT와 같은 효과를 나타냄


NUMBER(7, 2) : 소수점 이하 2번째 자리를 포함한 7자리 숫자를 저장 => 12345.78 (자연수는 5자리까지 가능함)

ALTER : 테이블을 변경하는 명령어
- ADD : 열 추가
- RENAME : 열 이름 변경
- MODIFY : 열의 자료형 변경
- DROP COLUMN : 열 삭제

TRUNCATE : 테이블 데이터를 삭제함 -> DELETE와 결과는 동일함
차이점 
1. TRUNCATE는 DDL이므로 삭제 후 롤백 불가, DELETE는 롤백 가능
2. 테이블 용량이 초기화 됨, DELETE는 용량이 사라지지 않음
3. DROP TABLE : 테이블 자체를 삭제



SQL Developer는 Oracle과 원격형태(Remote, localhost)로 접속하는 과정임
Oracle이 외부접속을 차단하는 경우 SQL developer와 같은 툴이 아닌 터미널을 이용한 방식으로 조작해야함 (명령어 이용, GUI형태는 이용X)


13장 객체 종류 
인덱스 (★★★★★)
-- PK(기본키) or 고유키(Unique key)일 경우에 인덱스는 자동으로 생성됨
인덱스 : 데이터를 빠르게 검색하기 위한 색인 기술
B-tree(Balanced tree) 자료구조(이진트리의 변형된 알고리즘) 사용

장점
- 검색속도 빨라짐
- 시스템 부하를 줄여줌 (성능 향상)

단점 
- 추가 저장공간 필요
- 인덱스 생성 기간 필요
- DML(INSERT, UPDER, DELETE) 작업시 성능 저하장점

/*
인덱스를 적용할 컬럼 (?)
- WHERE 조건절에서 자주 사용되는 컬럼
- 조인 조건에 사용되는 컬럼
- 두개 이상의 조건이 포함되는 경우 -> 복합 인덱스 지정
- 복합 인덱스는 조회 조건이 모든 컬럼이 동시에 지정되어야 함 (복합인덱스 - empno, sal => 조건 - empno, sal)

* 주의사항
- PK, UNIQUE 제약조건에서는 자동 생성
- 해당 컬럼을 가공하기 전 상태에서 조건 지정해야함 -> 함수를 사용해서 데이터를 가공한 결과값은 인덱스 X
- 인덱스 여부도 데이터 모델링 시 고려 필요함
- LIKE는 인덱스 미적용 가능성 높음(예 - %s%)
*/


unique scan
range scan
full scan

인덱스스캔 유도

복합인덱스 사용법
 - 복합인덱스 사용시 조건의 앞에다가 PK로 지정해야 효과가 있음




뷰(VIEW)

정규화 : 테이블을 쪼개는 행위  (시험에 나오는 내용, 따로 공부할 것)
- join을 해야함
1차 정규화 : 
2차 정규화 : 
3차 정규화 : 

반정규화 : 테이블을 합치는 행위
- join할 필요가 없음
- 중복을 줄이고, 조회속도를 향상시킴

테이블을 join하면 속도가 느려지는 단점이 있음 
따라서 초기에 view를 만들어줘서 매번 join을 해야하는 것을 막음 (속도 개선효과)

뷰의 사용 목적 
1. 편리성
2. 보안성 (각 테이블에 대한 접근권한 X, 만들어진 view 테이블에만 접근권한이 있음)
3. 속도개선

-- 권한 부여 (GRANT)
-- 권한 회수 (REVOKE)

시퀀스
-현재값 : currval
-다음값 : nextval

14장
제약조건

종류
- NOT NULL : null값 허용하지 X
- UNIQUE : 중복 X
- PRIMARY KEY : not null + unique + index 지정
- FOREIGN KEY : 다른 테이블의 열을 참조하는 키
- CHECK : 설정한 조건식은 만족하는 데이터만 입력 가능
- DEFAULT : 기본값을 정할 수 있음


데이터 무결성(Data intefrity) : 데이터의 정확성과 일관성을 보장
- 영역 무결성(domain integrity) 
- 개체 무결성(entity integrity) 
- 참조 무결성(referential integrity)


외래키 (Foreign key)
CASCADE : 열 데이터를 삭제할 때 참조하고 있는 데이터도 함께 삭제
- CONSTRAINT [제약조건 이름] REFERENCES 참조테이블 (참조할 열) ON DELETE CASCADE 

SET NULL : 열 데이터를 삭제할때 참조하고 있는 데이터를 NULL로 수정
- CONSTRAINT [제약조건 이름] REFERENCES 참조테이블 (참조할 열) ON DELETE SET NULL


15장 권한

시스템권한, 객체권한

WITH ADMIN OPTION (시험★) : GRANT문을 통해 부여받은 권한을 다른 사용자에게 부여할 수있는 권한도 함께 부여받음.


롤 : 여러 권한을 한번에 부여하고 해제할 수 있도록 여러 권한을 묶어놓은 그룹


요구사항 -> 기획 -> 스토리보드, 화면설계 -> DB 설계

=======================================
22.05.10 화 - 6일차

****************
SQL 총 복습

SELECT
    컬럼명..
FROM 테이블
WHERE 조건
GROUP BY 컬럼명
HAVING 조건
ORDER BY 컬럼 ASC/DESC


JOIN 
- 두개 이상의 테이블에서 조회
FROM a, b
WHERE a.컬럼명 = b.컬럼명

FROM a JOIN B
ON a.컬럼명 = b.컬럼명

INNER JOIN
LEFT/RIGHT OUTER JOIN


Subquery
- query 안에 query


INSERT INTO 테이블명 (컬럼명...) VALUES (값...)
UPDATE 테이블명 SET 컬럼명 = 값... WHERE 조건
DELETE FROM 테이블명 WHERE 조건

********************

데이터 모델링(설계)
- 현실세계에서 일어나는 사건들을 데이터화하는 과정
- 실제 현실은 너무 복잡해서 개념화(추상화)하여 단순하게 표현
- * 추상화, 단순화, 명확화

모델링 단계
개념적 모델링 -> 논리적 모델링 -> 물리적 모델링

개념적 모델링
- ERD(Entity Relationship Diagram)를 만드는 과정
- 엔티티와 속성을 도출

논리적 모델링
- 관계(Relation) 정의, 식별자 정의
- 정규화 수행

물리적 모델링
- 실제 DB에 정의

엔티티/엔터티(Entity) -> 테이블(table)
속성(attribute) -> 컬럼(column)

엔터티
- 관리되어져야하는 데이터의 집합
- 개념, 사건, 장소...
- 유일한 식별자가 있어야 함
- 2개 이상의 인스턴스(행, 데이터)가 있어야함
- 한개 이상의 속성 (식별자 외 1개 이상), 식별자 포함 2개 이상

속성
- 데이터의 가장 작은 논리적 단위
- 엔터티는 반드시 한개 이상의 속성(식별자 제외 1개 이상)으로 이루어져 있음
- 엔터티의 특성, 특징, 속성
- 기본속성, 설계속성, 파생속성

예) 부서 엔터티의 속성 : 부서번호, 부서명


관계(Relationship)
관계차수(Relationship Cardinality)
1:1, 1:N (일대다), N:M (다대다)
식별관계(실선) : 외래키(FK), 데이터 삭제 불가
비식별관계(점선) : 데이터 삭제 가능

ERD툴 사이트 : https://www.erdcloud.com/
- 무료
- 팀간 협업 가능

Mysql 설치

https://www.mysql.com/

다운로드 -> MySQL Community (GPL) Downloads -> MySQL Community Server -> Installer MSI 프로그램 다운 및 설치 -> Setup type : Developer Default

기본포트 번호
- Oracle : 1521
- MySQL : 3306
- MariaDB : 3306
동일한 포트번호를 쓸 수 없음 -> 마리아DB와 MySQL 동시설치시 하나는 포트번호를 바꿔야함 


최고계정 : Root
비밀번호 : root1234

- 최고계정 : 윈도우-Administrator, Oracle-sys, MySQL-Root

MySQL Workbench : 오라클의 sql developer와 동일한 프로그램

sakila -> 샘플 DB
MySQL 
- Schema : 다른 툴에서는 DB로 표현됨

새로운 테이블 생성
- Name : testdb
- Charset/Collation : utf8, utf8_general_ci

계정 생성
Administration 탭 -> Users and Privileges -> Add Account
- Login Name : testuser
- Limit to Hosts Matching (특정 위치에서만 접속이 되게 할 수 있음) : % (아무곳에서나 가능, localhost는 db가 설치된 컴퓨터에서만 접속이 가능함 -> root 계정은 localhost로 설정됨)
   - 실제 현업에서는 DB 설정이 localhost로 되어있기 때문에 서버를 원격으로 접속하게됨 (CLI환경으로 접속해야함)
- Password : test1234
Schema Privileges -> add Entry -> selected schema(testdb) -> select all -> apply

계정 접속
Connection Name : 즐겨찾기 이름
Username : 생성한 계정 이름 (testuser)
Password : Store in Vault (test1234)


CMD에서 mysql 실행하기
mysql 설치경로 : C:\Program Files\MySQL\MySQL Server 8.0\bin
명령어 : 
실행 : 'mysql -u계정이름 -p' 엔터 후 비밀번호 이름 입력
데이터베이스 보기 : show databases;
테이블 선택 및 사용 : use testdb;
이후 sql 쿼리 작성 
- 예시 : select * from emp;
종료 : \q


=======================================
22.05.11 수 - 7일차
자바프로그래밍
3장 변수

자료형 변수명;  => 변수 선언
예) int a;
변수명 = 초기값; => 변수 초기화
예) a = 10;
자료형 변수명 = 초기값; => 변수 선언과 초기화를 동시에
예) int a = 10;

변수 명명 규칙
- 변수이름에 의미를 부여하자 (★★★)
- 한글이 안되는 것은 아니나 되도록 피하자
- 사용가능한 특수문자 : _ , $

암묵적인 규칙(★★)
1. 클래스명은 첫자를 대문자로
변수나 메서드는 첫자는 소문자로
예) 클래스 - String, Math, 변수/메서드 - numer, println
2. 여러 단어로 이루어진 경우 : 두번째 단어의 첫글자는 대문자로 사용하여 구분 Or '_'로 구분
- Camel 표기법 : lastIndexOf, parseInt, studentNumber
- snake 표기법 : last_index_of, parse_int, student_number
예) 
게시판 댓글 수 : boardcommentcount -> boardCommentCount / board_comment_count
3. 상수는 모두 대문자 (단어구분은 snake표기법으로)
예) PI, MAX_NUMBER

자료형 - 기본자료형, 참조자료형
기본자료형(Primitive Type) : 변수가 값을 직접 가지고 있는 자료형
4가지 자료형만 기억하자 -> 정수형 : int, long, 실수형 : double, 논리형 : boolean
- long을 사용할 때 -> 정수형인데 21억이 넘는 경우

참조자료형(Reference Type)
참조자료형의 예 : 문자열
값을 직접 저장하는 것이 아니라 메모리에 저장된 위치정보를 저장함

상수 : 변하지 않는 수 ( final 키워드 사용)
리터럴 : 값 자체

제어문자(\) 
\n : 줄바꿈
\t : 탭
\\ : \
\' : '
\" : "

변수의 범위 (scope)
- 변수가 사용가능한 범위는 { }을 기준으로 구분할 수 있음

형변환(casting)
기본자료형들은 boolean(논리자료형)을 제외한 나머지 모든 자료형들은 서로 형변환이 가능!
자동형변환 : 작은 자료형 -> 큰 자료형
강제형변환 : 큰 자료형 -> 작은 자료형 (값의 손실이 발생할 수 있음)



4장 연산
기억해야할 연산자
=, +=, -=, +, -, *, /, %, ++, --, ==, !=, >, >=, <, <=, &&, ||, "조건식 ? 참 : 거짓"

% : 나머지를 구하는 연산
정수형 자료형을 나눗셈 연산시 값의 손실이 발생할 수 있는 것 조심해야함

증감연산 
++, -- : 1씩 증가시키거나 감소시킴

삼항연산자
(조건식 ? 값1 :값2 )
- 조건식이 true이면 값1, false면 값2를 반환
- 간단한 조건식을 구현할 때 if문 대신 사용할 수 있음

문자열연산 + 
정수형을 문자열 변수에 대입하지 못함
형변환 방법
1) String.valueOf() : 정수형 -> String으로 변환해주는 메서드
2) 정수형 + "";  : 문자열 연산을 통해 자동형변환이 되는 것을 이용한 방법

연습문제 4장 3~7번 풀어볼 것 -> 완료


5장 제어문
조건문 : if문, switch문
반복문 : for문, while문, do-while문

조건문
(1) if문
if ( 조건문 ) { 
    실행문
} else if ( 조건문 ) {
    실행문
} else {
    실행문
}

else if문 사용시 조건식의 순서에 주의할 것!

(2) switch문 -> 잘 사용 안함
switch (변수) {
    case 값1 :
        실행문1;
        break;
    case 값2 :
        실행문2;
        break;
    default : 
        실행문
}
각 case 실행문마다 break;를 사용해줘야 한다.


/*******************
이클립스 단축키
- shift + 엔터 : 줄바꿈
- alt + 상하키 : 커서가 존재하는 행 이동
- ctrl + alt + 상하키 : 복사
- ctrl + d : 행 삭제
- ctrl + / : 주석 처리
- ctrl + space : 자동완성
- ctrl + F11 : 자동실행
- ctrl + shift + f : 코드 자동 정렬
- ctrl + shift + o : 자동 import
- ctrl + shift + - : 화면 분할
- ctrl + n : 새로운 파일 만들기 (class, package, ... )
- ctrl + m : 작업영역 최대화
- alt+shift+ s -> r (Source 탭 -> Generate getters and setters) : 변수에 접근할 메서드를 생성해줌 (getter, setter)
- ctrl + e : 열린 창 확인 후 이동
- ctrl + shift + r : 파일 열기
*********************/

class를 import를 안해줘도 되는 2가지 경우의 수
- java.lang 패키지에 존재하는 클래스
- 동일한 패키지에 있는 클래스

반복문
(1) for문
for (초기화식①; 조건식②; 증감식④) {
    실행문③;
}

실행순서
 ① -> ② -> ③ -> ④
     -> ② -> ③ -> ④
     -> ② -> ③ -> ④
     -> ② -> ③ -> ④
     -> ②(조건 만족시 종료)
	
(2) while문
while (조건식) {
    실행문; (조건식이 true일 경우에만 실행)
}

(3) do~while문
do {
    실행문;
} while ( 조건식 );

끝에 ; 을 붙여야하는 것 주의
조건식이 false여도 최소한 한번은 실행됨
DB에서 사용하는 경우가 있음

(4) 중첩 반복문 
구구단을 통해 값이 변하는 흐름을 이해하기

반복문의 중지 - break, continue
break : 반복문들 빠져나옴
continue : 실행문을 더이상 실행하지 않고 다음 반복으로 넘어감
- 중첩반복문에서 "break 반복문 이름;"을 통해 해당 반복문을 빠져나갈 수 있음

무한반복문
- for (;;) { 실행문; }
- while (true) { 실행문; }
- do { 실행문; } while (true);

5장 연습문제 완료


=======================================
22.05.12 목 - 8일차
연습문제 풀이 (chapter4장 3번~ chapter5장)

조건문에서 boolean 값은 == 연산자 사용하지 않아도 됨
if (boolean == true)    ->     if (boolean)  /  if (!boolean)

이클립스 단축키 
ctrl + m : 작업영역 최대화

alt+shift+ s -> r (Source 탭 -> Generate getters and setters) : 변수에 접근할 메서드를 생성해줌 (getter, setter)
=======================================
22.05.16 월 - 9일차

6장 배열 (여러 값을 하나의 변수로 저장, Array)

6.1 배열의 선언
데이터타입[] 변수명;  // 데이터타입 변수명[];
예) int[] arrInt;    //    int arrInt[];

지역변수는 초기화를 하지 않으면 사용할 수 없다.
new 연산자로 배열 객체를 생성하면 배열의 값이 기본값으로 초기화된다.

기본자료형의 기본값 : 0 ( char : '\u0000', boolean : false)
참조자료형의 기본값 : null (값의 부재)

- String str = "";    -> 빈문자열이 있음
- String str = null;     -> 값의 부재, 존재하지 않음

6.3 다차원배열
0차원 : 스칼라(scalar)
1차원 : 벡터(vector)
2차원 : 행렬(matrix)
3차원이상 : 텐서(tensor)

6.4 배열 복사
- for문을 이용한 복사
- System.arraycopy() 메서드 이용

6.5 향상된 for문 (인덱스를 사용하지 X)
for (타입 변수 : 배열) {  실행문  }
- 간편하게 사용하기 편함
- 단점 : 인덱스를 사용하지 않아서 값을 읽을 수만 있고 변경할 수 없음.

6.6 참조자료형
참조자료형은 메모리의 주소를 저장하고 있음 : 값은 메모리에 저장됨

7장 클래스
객체지향 프로그래밍(Object Oriented Programming)
- 상속
- 다형성
- 추상화
- 캡슐화

7.2 클래스와 객체
클래스 : 설계도
객체 : 설계도로 만들어진 피조물(제품)

객체 선언 -> 클래스명 변수명;
객체 초기화 -> 변수명 = new 클래스명();

객체 선언과 초기화 동시 -> 클래스명 변수명 = new 클래스명();

7.3 클래스의 구조
 - 필드(field, 멤버변수) -> 클래스 내부 전체에서 사용되는 변수
 - 생성자(constructor) -> 객체를 생성할 때 사용됨 (클래스명과 이름이 같음)
 - 메서드(method)

7.4 필드 (멤버변수)

- 클래스 변수 : 객체를 생성하지 않고도 클래스를 통해 이용할 수 있는 변수, 모든 객체가 공유함
- 인스턴스 변수 : 객체를 생성해야만 이용할 수 있는 변수 (static 키워드가 붙지않음)
- 지역변수 : 메서드 수행문과 같은 클래스 내 별도의 중괄호 블럭 내에서 사용되는 변수

생성시기
- 클래스변수 : 클래스가 메모리에 로드될때
- 인스턴스변수 : 객체가 생성될때

7.5장 메서드
메서드의 구조

접근제한자 리턴타입 메서드명 (매개변수...) {
    실행문
    ....
    return 값;
}

접근제한자, 리턴타입 : 있을 수도 있고, 없을 수도 있음

=======================================
22.05.17 화 - 10일차
메서드의 실행 (p166)
- 클래스 메서드 : 클래스명으로 바로 실행 가능 (메서드 선언부에 static 키워드가 있음)
- 인스턴스 메서드 : 객체를 통해 실행이 가능

메서드 실행순서 : 스택(Stack)
- Last In, First Out (FIFO) : 먼저 실행된 메서드가 나중에 종료됨

메서드 오버로딩 
 - 이름이 같은 메서드가 여러개 있음
 - 매개변수의 자료형, 개수, 순서 중에 하나 이상 달라야함

오버로딩(overloading) : 동일한 이름의 메서드를 여러개 정의하는 것 (매개변수가 다름)
오버라이딩(overriding) : 부모에 존재하는 메서드를 자식클래스에서 새롭게 정의하는 것

7.6 생성자 (constructor)
- new 연산자와 함께 객체를 생성할 때 사용함
- 클래스 이름과 생성자 이름이 동일해야함
- 리턴값이 없음
- 객체가 생성될 때 가장 먼저 실행 됨

생성자의 용도 및 목적 : 객체의 초기화!

모든 클래스에는 생성자가 반드시 하나 이상 존재함
클래스 내에 정의된 생성자가 없으면 컴파일러가 자동으로 기본생성자를 추가해줌

참조자료형의 기본값 : null
기본자료형의 기본값 : 0

필드(static 변수, 인스턴스 변수) : 배열의 경우 따로 초기화를 하지 않아도 자동초기화 됨

7.7 this -> 자기자신

VO (Value Object) = 값 오브젝트 (리터럴값 개념) 읽을수만 있고, 값을 변경할 수 없음
DTO (Data Transfer Object)  = 데이터를 오브젝트로 변환하는 객체 (인스턴스 개념)

Source 탭 -> Generate getters and setters
이클립스 단축키 : alt+shift+ s -> r
클래스 변수에 접근해주는 메서드를 자동으로 생성해줌 (getter, setter)


클래스 -> 인스턴스변수, 메서드, 생성자, 스태틱변수

변수 -> 인스턴스변수, 스태틱변수
메서드 -> 인스턴스메서드, 스태틱메서드

7.8 초기화블록 { } 
- 변수 초기화 목적
- 생성자보다 먼저 실행됨

static {    }
- static 초기화블록 : 클래스가 메모리에 로드될때 한번만 실행됨

{    }
- 인스턴스 초기화블록 : 객체가 생성될 때마다 실행됨

7.9 Package 패키지
도트( . ) : 상위 또는 하위 패키지를 구분하는 기호

import
ctrl + shift + o : 자동 import

패키지명 생략 가능 예
1. 같은 패키지에 존재하는 경우
2. 상단 import 구문에 정의한 경우
3. java.lang 패키지에 있는 클래스인 경우

* 사용시 하위패키지에 있는 클래스는 import되지 않음

module-info.java 
- 다른 프로젝트에 있는 클래스를 import해서 사용할 수 있음

7.10 접근제한자
public : 모든 클래스에서 사용가능
private : 같은 클래스 내에서만 사용 가능

default : 동일 패키지 내에서 사용 가능
protected : 동일 패키지 내 + 상속관계에 있는 경우 사용 가능


클래스내 멤버 위치 : 순서는 크게 상관없지만 관례적인 순서가 있다.
class 클래스명 {
     1. 필드 (변수)
     2. 생성자
     3. static 메서드
     4. 인스턴스 메서드    
}

=======================================
22.05.18 수 - 11일차

7.11 싱글톤 (Singleton)
 - 하나의 객체만 생성하도록 하는 기법
 - 생성자의 접근제한자를 private로 설정 -> new 연산자로 객체 생성을 할 수 없음
 - 클래스 내에 객체 생성
 - static 변수이기때문에 객체 생성은 클래스가 로드될 때 한번만 수행됨
 - 적용 예 = 쓰레드, 회원가입, 주문, 스프링 : 데이터에 엑세스해서 기능하는 클래스를 만들때 사용 (저장할 데이터 정보를 싱글톤 기법으로 저장하지는 않음)

7.12 final

final 클래스 : 상속이 불가능한 클래스
final 메서드 : 오버라이딩이 불가능한 메서드
final 변수 : 값이 변경되지 않는 변수 (생성자를 통해 초기화하는 경우에 변경 가능함)
static final (상수) : 값이 변하지 않고 모든 곳에서 공유되는 값

7.13 javadoc

설명하고자 하는 클래스, 필드 및 메서드 위에서 "/**" + 엔터
필드, 메서드에 대한 설명문구를 작성할 수 있음
@param / @return 등등

8장 상속 (부모에게 물려받는 상속)

8.1 클래스 상속
class 자식클래스 extends 부모클래스 {
    ...
}

1. 단일 상속만 가능
2. 자식 클래스를 객체로 생성할 때, 부모클래스가 먼저 객체화 된다.
3. 모든 클래스는 Object 클래스의 하위 클래스다.

8.2 메서드 재정의 (Override)

1. 부모클래스의 메서드와 자식클래스 메서드의 선언부가 동일해야한다.
2. 자식클래스에서 재정의된 메서드의 접근제한자는 부모클래스 메서드의 접근제한자보다 좁은범위를 적용시킬 수 없다.

annotation : @
@Override : 오버라이딩 하는 메서드임을 표시해줌 
 -> 실수하는 것을 줄일 수 있음

8.3 다형성

추상메서드가 있는 클래스는 반드시 추상 클래스다
추상메서드는 자식 클래스에서 무조건 재정의해줘야한다.

부모클래스를 매개변수로 사용하면 모든 자식클래스를 사용할 수 있다.
 - 예 -> Object를 매개변수로 한 경우 모든 클래스 자료형이 대입될 수 있음

8.4 상속관계에서 접근제한자
protected : 다른 패키지에 있어도 상속관계에 있으면 사용 가능
default : 다른 패키지에 있으면 사용 불가

8.5 추상클래스

추상클래스를 상속받는 자식클래스는 추상클래스의 있는 모든 추상메서드를 구현해야한다. 

8.6 객체를 배열로 처리
8.7 final 제어자

=======================================
22.05.19 목 - 12일차
9장 인터페이스
class 키워드 대신 interface 키워드를 사용함

[public] interface 인터페이스명 {
    [public static final] 자료형 상수명 = 값;
    [public abstract] 리턴타입 추상메서드명();
    [public] default 리턴타입 메서드명(매개변수) {    }
    [public] static 리턴타입 메서드명(매개변수) {    }
}

상수
 - 인터페이스 필드는 상수만 선언할 수 있다.
 - public static final 생략하면 컴파일시 자동으로 생성된다.
 - 선언시 반드시 초기화를 해야한다.

추상메서드

default 메서드, static메서드 
 - 구현부가 있어야하나 잘 사용하지 않는다.

9.3 인터페이스 구현
public class 구현클래스명 implements 인터페이스명 {
    // 인터페이스의 모든 추상메서드 반드시 구현!
    ....
}

구현클래스에서 사용하는 키워드는 implements 이다.
여러개의 인터페이스를 구현할 수 있다. 
클래스는 단일상속(실선 표현), 인터페이스는 다중구현(점선 표현)

@Override : 컴파일러에게 상위클래스의 메서드를 오버라이딩하고 있다고 알려주는 표시(anotation)

익명 구현 객체
 - 한번만 사용하는 경우 인터페이스를 구현한 class 파일을 새로 만드는 것은 불편함
 - 실행 클래스에서 이름이 없는 익명 구현 객체로 객체를 생성할 수 있음
 - 실행클래스 내에서 인터페이스를 직접 구현하는 방식

인터페이스 객체명 = new 인터페이스() {
    // 인터페이스의 모든 추상 메서드 구현
};
끝에 ";"를 붙여줘야한다.

매개변수의 다형성

intanceof : 객체의 상속 관계를 확인(?)할 수 있는 연산자
객체 instanceof 클래스(인터페이스)

9.5 default 메서드와 static 메서드
자바 8버전 이후부터 default 메서드와 static 메서드를 인터페이스에서 정의할 수 있도록 개선됨
하지만 잘 사용하지 않는 편임

=====================================================
eclipse 내 컴파일러 버전 바꾸는 법 (자바 버전 바꾸기)
project -> Propertise -> Java Compiler -> Compiler compliance level 수정
=====================================================

9.6 어노테이션(Annotation)
어노테이션 : 프로그램에 추가적인 정보를 제공해주는 메타데이터(metadata)

@Override : 오버라이딩 되지 않으면 에러
@FunctionalInterface : 함수형 인터페이스로 추상메서드가 한개만 가능하도록 설정

어노테이션 정의하기
public @interface 어노테이션명 {
    자료형 요소명() [default 기본값];
}

10장 내부클래스 (중첩클래스)

class 클래스명 {
    class 내부클래스명 {
        ...
    }
}

멤버클래스의 파일명
외부클래스명$내부클래스명.class

로컬클래스의 파일명
외부클래스명$1내부클래스명.class

11장 예외처리 (에러를 미리 대비하자)
오류 : 에러와 예외 포함

에러(error) : 프로그램 코드에 의해서 해결할 수 없는 심각한 오류

예외(exception) : 특수한 상황이 발생하면 프로그램이 중단되는 현상으로 프로그램 코드에 의해서 해결할 수 있는 오류

컴파일 에러 : 컴파일 중에 발생하는 에러
런타임 에러 : 프로그램 실행 중에 발행하는 에러
- 컴파일러가 기본적으로 컴파일 에러를 잡아주지만 런타임 에러는 경우의 수를 예측하여 준비해야한다.

11.3 예외처리
try {  } catch (    ) {    } finally {    }

try {
    에외가 발생할 가능성이 있는 코드
}    catch ( Exception1 e1 ) {
    예외 e1이 발생할 경우 수행할 문장
} finally {
    항상 실행되는 수행문
}

특별한 경우가 아니면 제일 상위클래스인 Exception 클래스로 예외처리를 한다.

throws : 예외떠넘기기 
throw : 예외 발생시키기

finally 구문 말고 바깥에 코드를 짜도 상관없지 않나?
-> try문에서 return문으로 인해 메서드가 종료되더라도 실행됨 

11.6 사용자정의 예외클래스
잘 사용하지 않음

try-with-resource -> try-catch문의 업그레이드 버전

try ( ) {    } catch (    )  {    }
 - try() 괄호 안에서 생성한 객체가 AutoCloseable 인터페이스를 구현한 클래스라면 예외 발생여부랑 상관없이 close() 메서드를 자동으로 해준다.

12장 기본 API

12.1 java.lang 패키지
Object : 표준 클래스의 최상위 클래스
System : 표준 입출력 관련 클래스
Class : 클래스를 메모리에 로드할 때 사용
String : 문자열
StringBuffer, StringBuilder : 문자열 저장하거나 처리할때 사용
Math : 수학관련 기능
Wrapper : 기본자료형의 데이터 관련 클래스

12.1.1 Object 클래스
모든 클래스의 최상위 클래스
toString() : 객체를 문자열화 할때 사용되는 메서드
clone() : 객체를 복제

12.1.2 System 클래스

System.in : 표준 입력 객체
System.out : 표준 출력 객체

12.1.3 Class 클래스
사용용도
- 클래스를 메모리에 로드
- 클래스나 인터페이스의 이름, 생성자, 필드, 메서드 정보를 확인

12.1.4 String 클래스
- new 키워드 없이 "=" 연산자만으로 객체를 생성할 수 있음
- 더하기 연산이 가능함

String은 값을 바꿀 수 없음
String타입 변수 : str
str.indexOf() : ~의 인덱스 -> 활용해서 특정 단어를 포함됐는지 확인이 가능함
      서울시 종로구     , 서울시 종로구
str.trim().equals(str2)
"2,000"
str.replace(",", "")
"    서  울    시 종  로 구     "
str.replace(" ", "")
"낚시,게임,영화,독서"
str.split(",").length

=======================================
22.05.20 금 - 13일차

String class
indexOf() : 특정단어가 포함되어있는지 여부도 확인이 가능함
trim() : 웹개발단계에서는 잘 사용 안함 (프론트단에서 보통 정제되어오기때문), 빅데이터쪽에서는 사용 할 수 있음
replace() : 공백 제거시에 주로 사용됨
split() : 자주 사용한다

문자열 -> 기본자료형
정수형 : Integer.parseInt(String str)
실수형 : Double.parseDouble(String str)

method chaining
형태 : obj.a().b().c().d()
- 각각의 메서드에 리턴값이 존재해야함.
- 리턴타입이 다음 실행될 메서드를 가진 클래스 타입이어야함

12.1.5 StringBuffer, StringBuilder
String 객체는 immutable 객체이다 
- 문자열 변환할때마다 새로운 객체가 만들어진다

StringBuffer, StringBuilder 객체는 mutable 객체
- 동일한 객체에서 문자열 수정이 가능하다

append() : 문자열을 뒤에 추가해주는 메서드

12.1.7 Wrapper 클래스
auto-boxing : 기본자료형을 참조자료형으로 포장
unboxing : 다시 기본자료형으로 변환

12.2 Java.util 패키지
12.2.1 Random 클래스
Random(long seed) -> 매개변수인 seed 값이 동일하면 랜덤값이 동일하게 나옴

12.2.3 Date 클래스

12.2.4 Calendar 클래스
Date클래스보다 나중에 추가된 클래스
서로 변환 가능 : Date 클래스 < - > Calendar 클래스
싱글톤기법으로 클래스가 구성되어있음 (생성자의 접근제한자 protected)
 - new 연산자로 객체생성 불가

혼동할 수 있는 부분
Calendar.MONTH -> 0부터 시작하기 때문에 1을 더해줘야 한다 (1월이 0, 12월은 11)
Calendar.WEEK_OF_MONTH -> 요일 (DB 또는 서버마다 다른 경우가 많아서 실제로 확인해서 작성하자)

12.2.5 Arrays 클래스 -> 배열에 관계된 내용이 있는 클래스

12.3 java.text 패키지

12.3.1 DecimalFormat 클래스 : 숫자와 관계된 포맷팅 클래스

###,###.## 
 - 입력된 자리수만큼만 출력
 5500 -> 5500

000,000
 - 자리수가 고정되서 출력
 5500 -> 005,500

응용 예 (###,###.00 )
 5500 -> 5500.00

12.3.2 SimpleDateFormat 클래스
날짜 포맷팅 관련된 클래스

12.4 java.util.regex 패키지 (정규표현식을 사용하기 위한 클래스를 모은 패키지)
자바스크립트에서 대부분 정규식을 처리하기때문에 자바는 사용할일이 많지는 않음
데이터 분석시에는 많이 사용함


13장 컬렉션 프레임워크 (★★★ : List - ArrayList, Map - HashMap)
인터페이스를 이용한 다형성 개념을 사용할 수 있다.
객체 저장, 처리를 위한 추가, 삭제, 검색을 할 수 있는 다양한 클래스와 인터페이스들의 모임

Collection
 - List : 데이터의 저장되는 순서 유지, 중복저장 가능 ( ArrayList 중요! )
 - Set : 데이터의 저장되는 순서 유지 안됨, 중복저장 불가
Map : 키(key)와 값(value) 쌍으로 저장, 키는 중복 불가 ( HashMap 중요! )

Collection 인터페이스에 정의된 메서드
 - add()
 - size()

13.2 List 인터페이스
자주 사용되는 메서드
 - add() : 객체 추가
 - get() : 객체 리턴
 - size() : 사이즈 리턴

길이를 자유롭게 변경할 수 있음!

ArrayList - ★★★
 - 접근속도가 빠름
 - 데이터 삭제 및 삽입 속도가 LinkedList보다는 느림

대부분 DB에서 select를 한 것을 다루기때문에 ArrayList를 사용하게 됨

13.3 Set 인터페이스
- 중복이 없고, 순서가 없다.
- 중복을 제거할때 사용하기도 한다.

13.4 Iterator와 Enumeration
Iterator : Collection 프레임워크 객체에 저장된 데이터에 접근할때 사용되는 인터페이스 
- cursor가 한칸씩 이동하면서 저장된 데이터를 읽어온다
- List, Set 모두 Iterator를 가지고 있다 (ArrayList는 for문을 사용할 수 있기 때문에 쓸 필요가 없다.)
- Set의 경우 인덱스가 없기때문에 하나씩 출력할때 Iterator를 사용한다.

13.5 Map 인터페이스 
객체를 (key, value)의 형식으로 저장한다.
 - key : 중복 불가  -> mutable한 값은 key로 사용할 수 없다. -> List 불가, String 가능
 - value : 중복 가능

HashMap (★★★) : key의 순서를 알 수 없음
TreeMap : key의 순서 -> 크기순
LinkedHashMap : key의 순서 -> 저장된 순서

자주 사용할 메서드
 - put() : 저장할때 사용
 - get() : key값을 통해 value를 가져옴
 - size() : 키의 수를 반환
 - keySet() : 모든 키를 Set으로 리턴 (중복되지 않기때문에 가능함)

put() 
- 존재하는 키는 value 수정
- 존재하지 않는 키는 value 추가

Map을 출력하는 방법은 여러가지 있음
대부분 아래와 같이 사용하는게 간편함
Set<타입명> keys = map.ketSet();
for ( 타입명 key  : keys ) {
    System.out.println( key );
}

Properties 클래스
 - Hashtable 클래스의 하위클래스
 - key와 value 모두 String인 Map 객체
- 자바 프로그램에서 설정파일을 읽어오는 용도로 많이 사용됨

=======================================
22.05.23 월 - 14일차

클라우드스터딩 - 객체지향
자바 API ~ 상속과 인터페이스

토큰(Token) : 의미를 갖는 최소단위, 더 이상 나눌 수 없는 요소

15장 람다식
코드를 간결하게 할 수있는 장점이 있음
자바스크립트에 있는 callback 개념을 유사하게 구현해낸 것

이름이 없는 익명 함수형태
함수적 인터페이스를 자료형으로 사용함
함수적 인터페이스 : 추상메서드가 한개만 존저해는 인터페이스

16장 스트림 (가독성 좋은 코드 만들기)

람다 활용, 내부반복자를 이용하여 시간과 코드의 양을 줄일 수 있다.
스트림을 이용해서 대용량의 데이터들을 빠르게 처리할 수 있다.

스트림 처리단계
1. 생성하기
2. 가공하기
3. 결과 만들기

17장 스레드
프로세스 : 실행 중인 프로그램을 의미함
스레드 : 프로세스 안에서 작업을 수행하는 것

멀티스레드의 장점
 - CPU, 메모리를 효율적으로 사용할 수 있다.
 - 사용자에 대한 응답성이 높아진다.
 - 작업을 스레드 단위로 분리해서 실행시간을 줄일 수 있다.

쓰레드 생성하는 방법
1. Thread 클래스를 상속
2. Runnable 인터페이스를 구현한 객체를 Thread 객체에 넣어줌

스레드 우선순위
 - 우선순위 값은 상대적인 값이다
 - 스레드를 실행하기 전에 지정해야한다
 - main() 메서드에서 실행하는 스레드인 경우 기본값 5

운영체제에 따라 1~10, 1~7인 경우가 있다. -> 상수값인 MAX_PRIORITY를 사용하기도 한다.

17.5 스레드 동기화 (★)
동기화(Synchronized) : 하나의 스레드가 작업이 끝날때까지 해당 객체가 변경되지 못하도록 하는 것

동기화 <-> 비동기화

ajax (Asynchronized Javascript And Xml) 
 - 비동기로 처리해야하는 기술

18장 입출력 스트림
파일을 첨부하는 기능

스트림 : 데이터를 출발지에서 도착지로 이동할 수 있는 통로

출력 스트림 : 데이터를 도착지로 보냄
입력 스트림 : 외부의 데이터를 읽음

스트림 자료구조 : FIFO (First In, First Out)

입출력 스트림은 단방향임
 - 읽기와 쓰기가 동시에 되지 않음

바이트기반 데이터 (InputStream / OutputStream)
 - 1바이트 단위로 처리됨
 - 주로 영상이나 음악을 처리할때 처리함
 - 편집기로 파일을 열어도 알아볼 수 없음
문자 기반 데이터 (Reader / Writer)
 - 텍스트로 처리되는 데이터, (2바이트)
 - 한글은 2바이트이기때문에 반드시 문자 입출력 스트림에서 처리해야함

BufferedReader (★)
 - 버퍼에 있는 내용을 한 줄씩 읽을 수 있는 readLine() 를 가지고 있는 보조스트림

File 클래스 : 자주 사용됨 (★)
 - 빈번히 사용되는 클래스이다.
 - 파일의 존재여부, 파일의 크기, 마지막 수정날짜 등등

19장 네트워크
클라이언트와 서버
 - 서버 : 서비스를 제공
 - 클라이언트 : 서비스를 사용

IP Address (아이피 주소)
 - 4바이트(32비트)로 이루어진 정수로 이루어짐
 - 4개의 정수 사이에 마침표로 구분되어있음 (각 정수는 0~255사이의 범위)

Port (포트) 
 - 네트워크 상에서 컴퓨터와 컴퓨터가 서로 연결되는 부분

Socket (소켓)
 - 클라이언트와 서버가 특정 포트를 통해 양방향 통신이 가능하도록 만들어주는 소프트웨어 장치

클라이언트와 서버가 연결되는 순서
 1. 클라이언트에서 연결 요청
 2. 서버에서 연결 수락
 3. 클라이언트 처리 요청
 4. 서버에서 처리
 5. 서버에서 클라이언트로 처리 결과 응답

URL Connection 클래스
 - 추상클래스
 - URL 클래스를 이용하여 객체화 생성이 가능함

TCP / UDP
 - TCP/IP 프로토콜 : 다른 시스템간의 데이터 통신을 위한 표준 프로토콜
 - TCP 통신방식은 전화기화 유사
     - 데이터가 잘 전송되었는지 확인이 가능함
     - 속도가 느림
 - UDP 통신방식은 소포와 유사
     - 데이터가 잘 전송되었는지 확인이 불가
     - 속도가 빠름


네이버 API 실습
https://developers.naver.com/main/

공공데이터포털
https://www.data.go.kr/

aeWLdjxAXU_GuuCWUIs3
DAfbQKkzPS

=======================================
22.05.24 화 - 15일차

20장 데이터베이스

데이터베이스의 특징
1. 데이터 중복 최소화
2. 데이터 공유
3. 데이터 일관성
4. 데이터 무결성
5. 데이터 독립성
6. 데이터 보안성
7. 데이터 안정성

MySQL과 자바 연결하기
mysql.com 
connector/J

라이브러리 찾는 사이트
https://mvnrepository.com/

다운받은 Connector Java 파일(mysql-connector-java) 라이브러리 추가는 방법
Propertise -> java build Path -> Libraries -> Classpath -> Add Txternal JARs



VO (Value Object)	/ DTO (Data Transfer Object)
DAO (Data Access Object)

DB 접속
1. 드라이버(클래스) 로드
2. 연결(connection) 
 - 연결에 필요한 정보 : 호스트, 포트, 아이디, 비밀번호
3. Statement(or PreparedStatement) 객체 생성
4. Statement 객체로 sql 실행
5. 실행 결과를 받아옴
6. 자원해제

executeUpdate() : insert / delete / update -> 변형된 개수 리턴
executeQuery() : select -> ResultSet 객체 리턴


DB마다 메소드를 동일하게 사용하게 되어있음( JDBC가 인터페이스를 구현하도록 했음)

행정안전부 자바 시큐어코딩 가이드
===============================================
===============================================
자바 완료!!!!!
===============================================
===============================================

=======================================
22.05.25 수 - 16일차


1. 회원 등록
2. 회원 목록
3. 회원 상세
4. 회원 수정
5. 종료 

HTML, CSS, JavaScript 시작
교재 : HTML5 웹 프로그래밍 입문

서버 프로그램 : 자바, C#, 루비, 파이썬, 자바스크립트
웹 서버 관련 프레임워크 
 - 웹 프레임워크(ASP .NET, JSP, PHP 등)
 - MVC 프레임워크 (ASP .NET MVC, Spring MVC, Ruby on Rails 등)
 - 비동기 프레임워크(Node.js Express, Jetty)

클라이언트 프로그램 : HTML, CSS, JavaScript

1.4 웹 표준 기술과 HTML5 주요기능
HTML5 : 큰 의미로 웹 표준 기술을 총칭 (CSS3, 자바스크립트를 포함)
CSS : HTML 페이지에 스타일을 지정하는 스타일시트를 작성할 때 사용하는 언어
자바스크립트 : HTML 페이지에서 사용자 반응을 처리하는 스크립트를 작성하는 언어

HTML 주요 기능
 - 멀티미디어 기능
 - 그래픽 기능
 - 통신 
 - 장치 접근
 - 오프라인 및 저장소 
 - 시맨틱
 - CSS3 스타일시트
 - 웹의 성능 극대화 및 통합

1.5 HTML5를 공부하면 좋은 이유
 - 애플리케이션 수준의 웹 페이지를 만들 수 있다.
 - 데스크톱 애플리케이션을 만들 수 있다.
 - 리액트 네이티브를 사용해 모바일 애플리케이션을 만들 수 있다.

2장 웹페이지 기본 구조와 작성방법
2.1 HTML 기본용어
 - 요소 : HTML 페이지를 구성하는 각 푸품
 - 태그 : 요소를 만들 때 사용하는 작성 방법
 - 속성 : 태그에 추가 정보를 부여할 때 사용
흔히 요소와 태그를 구분하지 않고 사용함

내용을 가질 수 있는 요소 -> <요소이름>내용</요소이름>
 - ex : <h1>Hello HTML5</h1>
내용을 가질 수 없는 요소 -> <요소 이름>
 - ex : <img>, <br>, <hr>

XHTML 표기법 : 내용을 가질수 없는 태그를 표기하기 위해서 만들어짐
HTML : <img> -> XHTML : <img />
HTML : <br>   -> XHTML : <br />
HTML : <hr>   -> XHTML : <hr />

주석
<!-- 주석  -->

vscode 설치
Live Server 설치
File -> Preferences -> Settings -> Extensions -> Live Server Config -> Use Local IP 체크
기본브라우저 : Chrome

html:5 작성 후 엔터 -> HTML 자동완성 코드 

Liver Server 실행
 - 현재 열려진 페이지서에 Alt+l+o

Live Server 확장프로그램의 장점
 - 저장 후 변경사항을 브라우저에서 바로 확인 할 수 있음

HTML 주석은 외부에서 볼 수 있으니까 신중하게 사용해야한다.


JSP 수업 시작까지 2~3주정도 걸릴 예정 (~6/10 예상)

=======================================
22.05.26 목 - 17일차

2.2 HTML5 페이지 구조와 작성법
<head> 태그
- 여러가지 속성에 대한 정보를 넣는다
- CSS와 JavaScript 태그의 위치 : 주로 head 태그에 넣는다 (아무데나 넣어도 상관없으나 주로 head 태그에 위치시킴)
- <meta> : 웹페이지 추가 정보 전달
- <title> : 페이지 제목 지정
- <script> : 웹페이지에 스크립트 추가
- <link> : 다른 파일 추가
- <style> : 스타일시트 추가
- <base> : 웹페이지의 기본경로 지정

<body>
- 사용자에게 실제로 보이는 부분

// 인터넷에서 검색이 이루어지는 형태
 - 인터넷에 글을 등록하자마자 검색 리스트에 나오지 않음
 - 봇이 인터넷에 있는 정보들을 모아서 DB에 저장시킴  
 - (여러가지 메타태그를 기반으로 수집)
 - 검색은 DB의 데이터를 조회하는 것 -> 실시간 데이터와 차이가 있을 수 있음


에러 확인하는 방법
 - 크롬 개발자모드(F12) -> Console 탭에서 에러메시지 확인 가능

3장 HTML5 기본태그
3.1 글자태그
- h1~h6 : 제목 글자 생성
- p : 본문 문단 생성 (단락, paragraph)
- br : 줄 바꿈 (break)
- hr : 수평 줄 삽입(horizontal rule)

드래그 후 alt + shift + 상하방향키 : 줄 복제 단축키

특수문자 표기 (공백, 줄바꿈, <, >, &)
- 공백(스페이스) 또는 줄바꿈(엔터)을 아무리 많이 넣어도 작용하지 않음
- 공백 : &nbsp
- 줄바꿈 : <br> 태그 이용

앵커태그 (★) :
 - 하이퍼링크를 생성하는 태그

<a href="#alpha"> Alpha 부분 </a>
- # -> id 속성을 의미함 : 클릭시 문서 내 'alpha'라는 id를 가진 곳으로 이동함
- id 속성을 중복해서 사용하는 것은 웹 표준에 어긋남

글자 모양 태그 : 존재하기는 하나 보통 CSS를 이용함
- b : 굵은 글자
- i : 이탤릭체
- small : 작은글자
- sub : 아래첨자
- sup : 위첨자
- ins : 밑줄 글자
- del : 취소선이 그어진 글자

3.2 목록 태그
목록을 만들때 많이 사용됨
- ul : 순서가 없는 목록 생성 (Unordered list)
- ol : 순서가 있는 목록 생성 (Ordered list)
- li : 목록 "요소" 생성 (List item)

HTML이 가진 기본 속성은 없애고 CSS에서 다른 속성으로 바꿔버림
- 점, 숫자 표시를 없애고 사진 또는 박스형태로 바꿈
- 따라서 사실상 ol, ul 차이가 없음
- 하지만 웹 접근성(Web Accessibility)때문에 ol, ul을 구분해서 사용하는 것을 권장한다. (웹접근성 : 장애가 있는 이들도 문제 없이 이용할 수 있도록 개발하는 방식)

- dl 태그 : Description-List
- dt 태그 : Description-Term
- dd 태그 : Description-Description

3.3 테이블 태그

- table : 표 삽입
- thead : 표의 제목이 있는 부분
- tbody : 표의 내용이 담기는 부분
- tfoot : 표의 하단 부분
- th : 표의 제목 셀 생성 (bold, 가운데 정렬)
- tr : 표에 행 삽입
- td : 표의 일반 셀 생성

- thead, tbody 태그는 없어도 다른 코드 순서에 따라 표 내용이 구현이 된다.
- thead에 담긴 내용은 코드 위치상 tbody 밑에 있어도 페이지 내에서는 위로 올라와서 담긴다.
- tfoot에 담긴 내용은 코드 위치에 상관없이 페이지 내에서는 표 하단에 담긴다.

th, td 속성
colspan, rowspan : 표에 차지하는 영역을 조절할 수 있음
- colspan : 셀의 너비 지정
- rowspan : 셀의 높이 지정

반응형 웹페이지가 늘어나면서 table 태그를 사용해서 웹페이지 영역을 잡는 방법은 잘 쓰지 않게됨

3.4 미디어 태그

<img> 이미지태그
 - src : 이미지의 경로 지정
 - alt : 이미지가 없을 때 나오는 글자 지정
 - width : 이미지의 넓이 지정
 - height : 이미지의 높이 지정

<audio><video>
 - src : 음악, 비디오 파일의 경로 지정
 - preload : 준비중일때 모든 데이터를 불러올지 여부 지정
 - autoplay : 자동재생 여부
 - loop : 반복여부 지정
 - controls : 재생 도구 출력 여부 지정

<video> 
 - width : 비디오의 넓이 지정
 - height : 비디오의 높이 지정

비디오, 오디오는 용량을 차지하기때문에 잘 사용하지 않음 -> 스트리밍서비스에서 소스를 관리

src에서 경로 지정
절대경로 : 처음에 /를 사용하면 최상위경로를 말함 (서버가 시작된 디렉토리 기준)
 - 웹, 리눅스 : /부터 시작
 - 윈도우 : 드라이브명(C) 예) C:\
 - src="/img/logo.png"
 - src="http://192.168.10.10:5500//img/logo.png"    (호스트:포트번호~)

상대경로 : 실행파일이 있는 기준으로 한 경로
 - ../ : 한단계 위
 - ./ 또는 /가 없으면 현재 위치
 같은 폴더에 있는 경우 : 파일명 또는 ./파일명
 - src="./logo.png"
 - src="logo.png"
 상위폴더에서부터 찾아가야할 때
 - src="../img/logo.png"

오디오, 비디오 태그
 - 브라우저마다 지원하는 확장자가 다르기 때문에 여러개의 source 태그를 통해 문제를 해결한다. -> 불편하고 일관성이 없기때문에 사용하지 X

4장 HTML5 입력 양식 태그와 구조화 태그
4.1 입력 양식 태그 (전부 외울 것! ★★★★★)

입력 양식 태그: 사용자에게 정보를 입력 받는 요소

form 태그는 method 속성의 방식으로 action 속성 장소에 데이터를 전달함

radio : name이 같으면 하나만 선택됨, 중복선택 불가
체크박스는 체크된 것만 배열형태로 전달됨
checked 속성을 사용하면 선택된 상태로 시작됨

<label for="(적용될 id)">글씨</label>
label태그를 이용해서 버튼이 아니라 글씨를 클릭해도 체크되게 할 수 있음

셀렉트 박스 : name과 value가 쌍으로 전송이 됨 (ex : food=0)



전송방식 (GET, POST, ...)
GET 방식
 - 전송값들이 주소에 그대로 노출
 - 주소 공유가 가능
 - 길이 제한 있음
 - 파일 전송 불가
index.jsp -> 2 페이지 주소 공유 -> index.jsp?page=2
page = 2
공유 주소 : http://itempage3.auction.co.kr/DetailView.aspx?itemno=C415115132


POST 방식
 - 전송값들이 주소에 노출 안됨(보안)    -> 로그인, 회원가입시 사용
 - 주소 공유가 불가능
 - 길이 제한 없음 (원칙적으로 없으나 다른 조건에 따라 달라질 수 있음)
 - 파일 전송 가능
index.jsp -> 2 페이지 주소 공유-> index.jsp  (공유한 주소로는 2페이지를 갈 수 없음)


JSP : HTML 안에 자바 코드를 넣는 것
일반적인 연봉수준 : 2800~3000 (최소 2600, 최대 3300)
개발하는 회사 ( != 서비스업체, 마케팅업체)
개발이 주요직인 회사
개발자를 대우해주는 회사(?)
다양한 경험을 할 수 있는 회사
스타트업
 - 다양한 최신경험을 할 수 있음
 - 직속선임이 고경력자일 가능성 높음

=======================================
22.05.27 금 - 18일차

프론트엔드
 - 어플
 - 분석
 - cloud

백엔드
 - 서버
 - SP (?)
 - DB
 - API

각 분야가 나뉘어지지만 어느정도 분야가 걸쳐있다.

4.2 HTML5 문서 구조화
공간 분할 태그
- 레이아웃 구성을 위해 공간을 분할함
- 과거에는 table 태그로 나눴지만, 이제는 공간분할태그(div, span)를 사용한다

div 
 - 공간을 블록(block) 형식으로 분할
 - 한 행을 모두 차지함

span 
 - 공간을 인라인(inline) 형식으로 분할
 - 자신의 글자크기만큼 영역을 차지함

시맨틱 태그 (semantic : 의미론적인)
 - 특정 태그에 의미를 부여해 웹페이지를 만들기 시작함
 - 시맨틱 웹 : 컴퓨터 프로그램이 코드를 읽고 의미를 인식할 수 있는 지능형 웹
 
div 태그와 동일한 기능이지만 의미를 부여해서 코드 가독성을 높인다.
개발자에 따라 div를 사용하는 경우도 있고, 시맨틱 태그를 사용하는 경우도 있다.

종합예제 - 블로그 레이아웃 구성


5장 CSS3 기초 : 선택자와 단위

선택자 (Selector, ★) 
 - 자바스크립트, JQuery 등에서 앞으로 계속 사용할 예정
 - CSS3에서 특정 HTML 태그를 선택할때 사용됨

  h1  {  color  :   red; }
선택자 스타일속성  스타일값

외워야할 선택자! (★★★)
아이디선택자 : #아이디
 - 아이디는 페이지에서 딱 한번만 사용해야 한다 -> 자바스크립트때문
클래스 선택자 : .클래스
속성선택자
 - 사용법 : 선택자[속성=값] -> input[type=text]
자식 선택자 (부모-자식관계)
 - 바로 한단계 아래
 - 사용법 : 부모>자식 -> div > span
자손 선택자 (조상-자손관계)
 - 하위영역 모두 포함됨
 - 사용법 : 조상 자손 -> header h1 (띄어쓰기로 구분)

구조선택자 중 nth 선택자 (n번째 자식을 선택)
 - 사용법 : 선택자:nth-child(수열) -> li:nth-child(2n+1)

, : 한꺼번에 여러개의 선택자를 동일하게 적용하고자 할때 사용
예) h1, h2, h3, h4 { color : red; }

5.2 기본선택자

h1 태그 class="item header" <br>
.item { color : red;} <br>
.header { background-color: blue;}
하나의 태그에 클래스를 여러개 사용할 수 있다. (공백으로 구분)
 - class="item header" -> item 클래스, header 클래스

금요일 인터뷰 질문할 것들 정리

공통질문
1. 개발실력이 성장할 수 있는 선임이 있는지 확인하는 방법
 - 들어가기 전까지 모름...
 - 막혔을 때 질문 많이 하기
 - 면접 때 많이 물어봐야함 
(면접 후 팀원들이랑 얘기할 수 있는 기회가 있기도 함)

강사님
1. 깃허브에 올라온 오픈소스 보는 법 & 참여하는 방법
2. 협업 토이프로젝트 하는 것은 어떻게 시작하고 어떤 과정으로 이루어지는지

선배님
1. 실제로 실무를 접했을 때 어느정도까지 준비되었으면 좋겠다 싶었는지 
 - 크게 기대하지 않음
 - 구조적인 사고를 할 수 있는지 여부 (관련 연습)
2. 토이프로젝트 하고있는게 있는지 / 했던 프로젝트가 있는지
 - X

Q 자바를 다 이해 못했을 때 어떻게 해야하나?
다음에 들으면 이해가 될까?
 - 성향에 따라 다름
 - 외우지는 않고 이해하는 것으로...

Q 기대할 수 있는 평균 연봉 : 3천초반?
Q 구직시 좋은 회사를 찾을 수 있는 방법?
 - 면접시 전문적인 질문 여부를 토대로 확인
Q 취직 후 개발공부를 어떻게 하고있는지
 - 아직 안하고 있음
 - 도커, 쿠버네티스와 같은 신기술들을 접해보는 것이 좋음
Q 개발 공부 할 때 좋은 예, 나쁜 예
- 너무 오픈 소스를 참고하지 말기
- 질문을 많이 하기
Q 현업에서 주로 하게되는 업무
- 지금과 크게 차이가 없으니 배우고 있는 것을 잘 연습하기
Q 현업과 공부시 체감 난이도
- 사실 차이가 없음
Q 야근 여부
- 많이하면 3일?
- 주말 빼고는 다하는 경우도 있음

추가
취업시 코딩에만 너무 매몰되지 말고 업무적인 질문을 할 수 있도록 하자
회사마다 다르다
첫프로젝트가 끝났을 때 생각보다 더 많이 성장한 것을 느낌
엘라스틱서치로 할 수 있는게 너무 많다
DB -> 자바를 이용해서 DB데이터 가공 -> 엘라스틱서치에 저장
엘라스틱서치 : 통계에 능함
향후 계획


=======================================
22.05.30 월 - 19일차

CSS3
동일한 선택자가 두개 이상 적힌 경우 : 맨 아래 적힌 것이 우선순위를 가진다.

5.3 속성 선택자

같은 클래스인데 타입(속성)에 따라 스타일을 주고싶을 때 사용함

- 선택자[속성] { 스타일속성 : 스타일값  }
- 선택자[속성=값] { 스타일속성 : 스타일값  }
아래 있는 형태가 주로 사용됨

==============================
vscode 단축키
한줄 삭제 Ctrl + shift + k
==============================

5.5 반응, 상태, 구조 선택자
5.5.1 반응선택자
:hover : 마우스가 올라갔을 때 스타일
:active : 클릭할 때의 스타일

5.5.2 상태선택자
readonly 속성을 적용하면 수정이 불가능함

5.5.3 구조선택자

:nth-child(수열) : 형제관계에서 수열번째로 등장하는 태그 선택
- 게시판을 줄무늬 형태로 넣을때 사용할 수 있음


Sass (CSS와 다른 형태의 스타일시트)
- 괄호를 입력할 필요가 없음
- 변수, 선택자도 선택자 내부에 입력이 가능함

5.6 CSS3 단위
스타일 값으로 입력할 수 있는 단위 (키워드, 크기, 색상, URL)
- 키워드 : W3C에서 미리 정의해둠

- 크기 : %, px, ... (em, cm, mm, inch)
100% = 1.0em
150% = 1.5em
200% = 2.0em

- 색상
RGB : 빨간색, 초록색, 파란색을 조합한 색상
  255.  0.  0 : red
    0.255.  0 : green
    0.  0.255 : blue
RGBA : RBA에 투명도를 추가한 형태
HEX : RGB를 16진수단위로 짧게 나타낸 형태
- URL

6장 CSS3 속성
6.1 박스속성
- margin, border, padding, width, height 속성

- margin : border 바깥쪽 여백
- padding : border 안쪽과 글자 사이 여백

6.2 가시속성
block속성, inline속성을 display 속성으로 변경할 수 있음

display 속성에 많이 사용되는 키워드 : none, block, inline, inline-block

display: none 
-> 태그가 존재하지만 웹페이지상에서 표현되지 않음, 차지하는 영역 X
visibility : hidden 
-> 눈에는 안보이지만 영역이 잡혀있음

display: inline;
-> 글씨 있는 부분만 영역이 잡힘
-> width, height 속성이 적용되지 않음

display: inline-block;
-> 기본적으로 글씨 있는 부분만 영역이 잡힘
-> width, height 속성을 적용시킬 수 있음

6.3 배경 속성
background-image
background-position
background-size
background-repeat
background-attachment : fixed -> view point 기준으로 잡힘, div에 종속되지 않음
background-color

6.4 글자 속성
고정폭 폰트 (monospace, Courier) - 자간이 동일함

웹폰트
fonts.google.com
자주 사용되는 폰트
 - Noto Sans Korean, Nanum Gothic
원하는 폰트 클릭해서 import문 복사 후 폰트 적용하기
<style>
    @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300&display=swap');
    body { font-family : 'Noto Sans KR' }
</style>

텍스트 정렬 (text-align)
span 태그가 텍스트 정렬이 되지 않는 이유
 - span 태그는 inline 형태이므로 너비가 없다 -> 중앙이라는 개념이 없음

- line-height 속성 (수직 가운데 정렬)
   - 글자를 감싸는 박스의 높이와 같은 크기를 지정해주면 글자 수직가운데정렬이 됨

6.5 위치 속성

절대 위치 좌표
상대 위치 좌표

left, top 속성
z-index

6.5.2 위치 속성 공식
- 자손의 position 속성에 absolute 키워드를 적용하려면 부모에 height 속성을 입력한다.
- 자속의 position 속성에 absolute 키워드를 적용하려면 부모의 position 속성에 relative 키워드를 적용한다.

6.6 유동 속성
웹브라우저의 크기에 상관없이 공지 등을 일정한 위치에 고정할 때 사용

float: left
태그를 왼쪽으로 붙임

clear: left
아래 태그들을 clear로 초기화 해주지 않으면 선행된 float 속성을 따라감 

6.7 그림자와 그레이디언트 속성


너비 = 실제영역 + (padding + border) * 2
box-sizing : border-box -> 설정한 너비가 border 포함된 것으로 설정함


=======================================
22.05.31 화 - 20일차

7장 다양한 레이아웃의 구성과 기능
7.1 수평, 중앙, One True 정렬 레이아웃

7.1.1 수평 정렬 레이아웃
수평으로 요소를 정렬할때
 - "자손에게 float 속성을 지정하고, 부모의 overflow 속성에는 hidden 키워드를 적용한다." -> 일반적으로 적용되는 규칙


========================================================
VScode "=" 입력시 자동으로 큰따옴표 나오는 설정
setting -> quot 검색 -> HTML: Auto Create Quotes 체크여부
=========================================================

7.1.2 중앙 정렬 레이아웃
중앙정렬하고 싶은 태그에 width 속성을 부여하고 margin 속성을 '0 auto'로 입력한다.

그리드 시스템 : 보통 중앙정렬 레이아웃은 그리드 시스템과 함께 사용됨

7.1.3 One True 레이아웃
"행을 독립적으로 생각하자"

- 각 행을 독립적으로 구성한다는 것이 핵심
- width 속성과 height 속성을 지정하지 않고 overflow 속성에 hidden을 적용하면 유동영역을 감싼다.

7.2 요소배치
7.2.1 절대위치를 사용한 요소 배치
"자손의 position 속성에 absolute를 적용하려면 부모의 position 속성에 relative를 적용한다."

7.2.2 요소를 중앙에 배치
1. 중앙 정렬하려는 div태그의 position 속성을 absolute로 지정한다.
2. left 속성과 top 속성을 모두 50%로 지정한다.
3. 중앙에 정렬하려는 div 태그의 margin-left, margin-top 속성에 음수를 입력한다. (입력하는 값은 div 태그의 너비, 높이의 절반이어야 한다.)

7.2.3 요소를 고정 위치에 배치
position 속성에 fixed를 적용

7.3 글자 생략

white-space : nowrap -> 공백문자를 처리하는 방법
 - nowrap : 줄바꿈 X

text-overflow: ellipsis; -> 너비를 넘어갈 경우 ...으로 처리되어 사라짐

8장 반응형 웹
미디어 쿼리 : 미디어 타입(PC, 모바일, 태블릿...)에 따라 CSS를 적용할 수 있는 기능

8.2 반응형 웹을 위한 설정
8.2.1 뷰포트 설정
meta 태그 : 웹페이지에 추가정보를 제공할 때 사용됨

name 속성에 viewport가 입력된 meta태그를 뷰포트 meta태그라고 한다.

8.2.2 미디어 쿼리 설정
- @media 규칙
@media (<미디어쿼리>) {
    <CSS 코드>
}

- media 속성 : 미디어 쿼리 조건에 맞는 장치에서만 css 파일을 불러옴
<link rel="stylesheet" href="<파일이름>" media="<미디어쿼리>">

min-width, max-width 속성을 사용해서 주로 CSS를 다르게 한다

table태그는 반응형으로 처리하기가 어렵다
 - 조건에 따라 table 형태를 다르게 만들어서 해결하는 경우가 있음
 - 이럴 경우 수정할 때 여러개의 table을 다 수정해야함


8.3 반응형 웹 패턴

https://getbootstrap.com/
https://wordpress.com/ko/
https://adminlte.io/ -> 유료
 - 기본적인 템플릿을 사용할 수 있음

- HTML 태그 구성은 모바일 장치를 기준으로 한다
- float 태그의 left와 right를 활용해 적당한 위치에 놓는다.

"float 속성에 들어가는 값"과 "HTML 태그의 순서"가 중요하다.

9장 자바스크립트 기본 문법

줄바꿈 또는 ';'를 이용해서 종결을 나타낸다

클래스 안에 있으면 메서드, 밖에 있으면 함수
alert('hello') -> 함수
Math.abs(-2) -> 메서드

자바스크립트 출력하는 법
- alert('ABC'); 
  알림창으로 뜸
- console.log('ABC');
  개발자도구 console창에서 확인 가능
- document.write('ABC');
  웹페이지 화면에 출력됨

9.2 자료형과 변수
자료형
 - 정의되지 않은 자료형(undefined)가 있다.

- number
- string
- boolean
- undefined -> 미정의된 값
- function
- object

문자열
- 쌍따옴표(""), 홑따옴표('') 둘 다 사용 가능
- 단, '  ', "  "와 같이 시작과 끝을 동일하게 해야한다.

배열 (대괄호 사용, 타입 혼용 가능)
- 인덱싱은 자바와 동일
- 인덱스는 0부터
- 배열을 콘솔 출력 -> console.log(arr);

전역(global)변수, 지역(local)변수
- 전역변수는 어디서든 사용될 수 있음
- scope 바깥에서 지역변수 호출은 사용이 불가함

명시적 형변환
숫자 -> 문자
- String() -> 생성자 함수 (숫자를 문자로 형변환해줌)
문자 -> 숫자
- Number(), parseInt()

Number()와 parseInt()의 차이점
- Number() : 값이 비어있을 경우 0으로 변환
- parseInt() : 값이 비어있을 경우 NaN (Not a Number)로 출력

=======================================
22.06.02 목 - 21일차

9.3 조건문과 반복문

9.3.1 조건문
if 조건문
<script>
    if (조건 ) {
        실행문;
    }
</script>

자바스크립트는 서버가 아닌 클라이언트 단에서 실행되는 언어다 (Node.js 제외)
 - 예) 클라이언트 PC에서 시간을 변경하면 클라이언트 브라우저의 시간도 변경이 됨 -> 코드에 영향

9.3.2 반복문
for문
for (var i=0; i<10 ; i++) {
    실행문;
}

배열 -> 객체로 인식됨
var array = [a, b, c ];

while문
while (조건) {
    실행문;
}

9.4 함수 - 익명함수, 선언함수

선언한 함수 : 실행문들이 실행되기 전 미리 로드가 된다.
익명함수는 선언된 함수와 달리 순서에 따라 실행된다.
-> 위 원리에 의해 함수 실행 위치에 따라 결과가 달라진다.

매개변수와 반환값(리턴값)
function 함수이름(매개변수1, 매개변수2) {
    실행문;
    실행문;
    return 리턴값;
}


callback 함수
- 함수가 매개변수
- 매개변수가 된 함수를 원함수 내에서 실행

closure -> 클로저
 - 독립적인 변수를 가지는 함수 
 - 내부함수를 사용해서 별도의 스코프 정의 
 - 클로저 함수를 각각의 변수에 할당하면 각자 독립적으로 값을 사용하고 보존할 수 있다

9.5 객체
객체 : 자료형 여러개를 한번에 저장함
- 각 요소에 접근할 때 키(key)를 사용함 (인덱스 사용X)

for in 반복문
for (var 키 in 객체) {
    문장
}

자바스크립트 / 파이썬
값이 있으면 true;    (-1, ' '(공백), '0')
값이 없으면 false;   ( 0, ''(빈문자열), undefined)

비교연산 ( == , ===, !== )
== 
 - 값이 같은지 비교, 문자열 비교도 가능
 - 객체인 경우 주소 비교

===
 - 값도 같고, 타입도 같아야 true

!==
 - 값이나 타입이 다르면 true


10장 문서 객체 모델
10.1 문서 객체 모델의 기본 용어와 개념

문서객체모델 - DOM(Document Object Model) 

- 문서객체를 조작한다 => 태그를 조작한다는 의미
- 노드 : 요소노드, 텍스트노드

- 정적 생성 : 웹 페이지를 처음 실행할 때 HTML 태그로 적힌 문서 객체를 생성하는 것
- 동적 생성 : 웹 페이지 실행 중에 자바스크립트를 사용해 문서 객체를 생성하는 것  

=======================================
22.06.03 금 - 22일차
10.2 문서 객체 선택

소스보기 : 처음 응답 받았을 때의 소스
개발자도구 : 현재 적용되고 있는 동적(?)인 상태를 볼 수 있음

1. URL 요청
2. 서버응답 (HTML, CSS, JS) => 소스보기
3. JS -> 조작               => 개발자 도구에서 보이는 소스

문서 객체를 선택하는 메서드
1개 선택
 - document.getElementById('아이디') : 아이디로 1개 선택
 - document.querySelector('선택자') : 선택자로 1개 선택 (동일한 선택자가 여러개 있을 경우 가장 먼저 등장하는 것을 선택함)

여러개 선택
 - document.getElementsByName('이름') : name 속성으로 여러 개 선택
 - document.getElementsByClassName('클래스') : class 속성으로 여러 개 선택
 - document.querySelectorAll('선택자') : 선택자로 여러 개 선택

10.3 문서 객체 조작

SPA(Single Page Application)
 - 웹페이지를 한번만 읽어들이고, 사용자가 조작할 때 웹페이지 내용을 자바스크립트를 사용해 바꾸는 형태의 웹페이지
 - 대부분 Ajax를 사용한다

10.3.1. 글자 조작
 - textContent : 문서 객체 내부 글자를 순수 텍스트 형식으로 가져오도록 변경
 - innerHTML : 문서 객체 내부 글자의 HTML 태그를 반영해 가져오도록 변경

10.3.2 스타일 조작
자바스크립트는 특수문자 '-'를 식별자에 사용할 수 없음
때문에 '-'로 연결된 단어의 첫 글자를 대문자로 변경한다 
 - 예) background-color -> backgroundColor, box-sizing -> boxSizing
문자열을 사용해서 스타일 속성에 접근할 수도 있다.
 - 예) doucument.body.style['background-color'] = 'red';
 
10.3.3 속성 조작

- setAttribute(속성이름, 속성값) : 속성 지정
- getAttribute(속성이름) : 속성 값 추출


'data-'로 시작하는 속성 -> 사용자 지정 속성 (예: data-role)
- 웹 표준 지정속성이 X
- 반드시 속성 조작 메서드를 사용해서 접근해야함


10.4 이벤트

이벤트 : 키보드를 누르거나 마우스를 클릭하는 것처럼 어떤 현상이 프로그램에 영향을 미치는 것

자바스크립트에서 기본으로 지원하는 이벤트
- 마우스 이벤트
- 키보드 이벤트
- HTML 프레임 이벤트
- HTML 입력 양식 이벤트
- 사용자 인터페이스 이벤트
- 구조 변화 이벤트
- 터치 이벤트

window.onload = function(){   };
코드에서 onload를 이벤트 속성(event property)이라고 함
on을 제외한 load : 이벤트 이름(event name) 또는 이벤트 타입(event type) 이라고 함
이벤트 속성에 넣는 함수 : 이벤트 리스너(event listener), 이벤트 핸들러(event handler)라고 함

인라인 이벤트 모델 
 - HTML 태그 내부에 자바스크립트 코드를 넣어 이벤트를 연결하는 방식
 - 코드가 지저분해짐
고전 이벤트 모델
 - 과거에 표준으로 정의되어 많이 사용하던 이벤트 모델

this : 이벤트 리스너 내부에서 사용시 이벤트를 발생한 자기 자신

10.4.2 이벤트 사용

이벤트가 발생하면 웹브라우저가 이벤트정보가 담긴 이벤트 객체를 만들어 이벤트 리스너에게 전달함

기본 이벤트(default event) : 특정 태그가 가진 기본적인 이벤트
- 때때로 기본 이벤트를 막아야한다. (주로 a, form 태그에서 사용)
- 이럴때는 이벤트 리스너 반환 값에 false를 입력해준다.

기본 이벤트 제거방법 2가지
1. preventDefault();

document.getElementById('').onclick = function(e) {
    e.preventDefault();    // 기본 이벤트 제거
    e.stopPropagation();   // 이벤트 전파 제거 (이벤트 중첩발생을 막아줌)
};

2. return false;


11장 JQuery 라이브러리

- 쉬운 문서 객체 모델과 관련한 처리 구현
- 쉽고 일관된 이벤트 연결 구현
- 쉬운 시각적 효과 구현
- 쉬운 Ajax 응용 프로그램 개발

보통 CDN을 사용하여 JQuery를 이용함
- 수업에서는 구글CDN 이용
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

CDN : 전세계에 있는 서버 중에서 사용자가 접속하는 곳과 가까운 서버에서 파일을 전송하는 기술

11.2 문서 객체 선택

제이쿼리 기본형태
$(선택자).메서드(매개변수1, 매개변수2)

11.3 문서 객체 조작
11.3.1 속성 조작
- attr() : 문서 객체 속성을 조작할 때 사용

속성 지정 3가지 방법
1. 속성 값을 입력해서 지정
2. 객체를 입력해서 속성 지정
3. 함수를 이용해서 속성 지정

11.3.2 스타일 조작
스타일을 조작할 때는 css() 메서드를 사용한다.

메서드의 일반적인 규칙(항상 그런 것은 아님)
1. 
메서드() : get
메서드(a) : set a

2.
메서드(a) : get a
메서드(a,b) : a에 set b


12.3.3 글자 조작

- html() : 문서 객체 내부의 HTML 태그 조작 -> 자주 사용됨
- text() : 문서 객체 내부의 글자 조작

12.3.4 클래스 조작
- addClass() : 클래스 추가
- removeClass() : 클래스 제거
- toggleClass() : 클래스 전환

책에 안나와있는 메서드 정리
removeAttr()는 removeClass()와 달리 속성을 아예 삭제함
remove() : 객체가 아예 사라짐
empty() : 객체 비우기

append() : 태그 안쪽 끝에 추가
prepend() : 태그 안쪽 앞에 추가
after() : 태그 바깥쪽 뒤에 추가
before() : 태그 바깥쪽 

반대되는 것들
appendTo, prependTo
insertAfter, insertBefore

clone() : 복제                

12.4 이벤트
index() : 해당 객체의 인덱스를 추출하기

eq(idx) : 선택된 객체가 여럿일 때 인덱스(idx)를 이용하여 하나의 객체만 선택할 때 사용한다
예) 
$('img').click(function(){
    console.log($(this).index())
    var idx = $(this).index()
    $('span').eq(idx).css('color', 'red');
});

on(), bind() 메서드
$('img').on('mouseover', function(){ });
$('img').bind('hover', function(){  });
$('img').hover(function(){  });

=======================================
22.06.07 화 - 23일차

11.5 시각효과
11.5.1 시각효과 메서드
- show(속도), hide(속도), toggle(속도)
- slideDown(속도), slideUP(속도), slideToggle(속도)
- fadeIn(속도), fadeOut(속도), fadeToggle(속도)

메서드 사용 : 3가지 종류
.메서드();
.메서드(duration);
.메서드(duration, callback);

11.5.2 애니메이션 효과

- $(selector).animate(속성객체);
- $(selector).animate(속성객체, 시간);
- $(selector).animate(속성객체, 시간, 콜백함수);

반복해서 함수 실행
- setInterval(callback, 시간)

반복 중지 (매개변수에 중지할 함수를 변수로 넣어줘야함)
- clearInterval(변수)

12장 자바스크립트와 jQuery 라이브러리 응용

12.1 입력 양식 포커스

12.2 프레임 애니메이션

setInterval(함수, 시간) : 특정 시간마다 함수 실행
setTimeout(함수, 시간) : 특정 시간 후에 함수 실행 (반복 X)
clearInterval(식별번호) : setInterval() 함수로 설정한 타이머 제거
clearTimeout(식별번호) : setTimeout() 함수로 설정한 타이머 제거

12.3 문서 객체 생성과 추가
$(대상).prepend(객체)
$(대상).append(객체)
$(대상).before(객체)
$(대상).after(객체)

$(객체).prependTo(대상)
$(객체).appendTo(대상)
$(객체).beforeTo(대상)
$(객체).afterTo(대상)




12.4 무한 스크롤
document.height = 전체 문서의 높이
window.scrollTop = 스크롤 높이
window.height = 브라우저 창의 높이

(document.height == window.scrollTop + window.height) 이면 문서 추가

=======================================
22.06.08 수 - 24일차


어떤 선택자를 써야하는지가 중요!

url?이름=값&이름=값

사용자정의속성 ('data-'로 시작하는 속성)
- data('aaa') : 사용자정의 속성("data-aaa")의 값을 가져오는 메서드

Ajax (Asynchronous Javascript And Xml)
 - 비동기로 서버와 통신 (웹은 기본적으로 동기방식)
 - 최근에는 JSON으로 통신함

JSON (JavaScript Object Notation)
- 객체 : {}
- 배열 : []

13장 프로젝트: 모바일 페이지 제작

13.1.1 동위선택자
같은 단계에서 뒤에 있는 태그를 선택할 때 사용

- 선택자A + 선택자B : 바로 뒤에 있는 선택자B 선택
- 선택자A ~ 선택자B : 뒤에 위치한 선택자B 선택

14장 프로젝트: 핀터레스트 스타일의 웹페이지 제작


JSP/Servlet 시작
교재 : 성낙현의 JSP 자바 웹 프로그래밍



이클립스에서 톰캣 9.0 설치하기 (9.0부터는 메시지가 한글로 나옴)
- perspective -> JavaEE
- 하단 servers 탭 -> apache -> tomcat 9.0 -> 'download and install' -> 설치경로 입력 -> jre : 기본(workbench default JRE) -> next -> finish

- 톰캣 우클릭 후 Add and remove -> web 리소스 Configured로 이동

하단 server탭에 톰캣 더블클릭시 포트번호 및 기타 정보 확인 가능
접속 경로 : localhost:8080


새 프로젝트 만들기
New -> Dynamic Web Project

src/main/webapp : 파일 넣는 경로
새 파일 만들기
New -> jsp파일
인코딩형식 바꾸기
-window -> preferences -> Web -> JSP files -> Encoding -> UTF-8

JSP와 Servlet의 차이

JSP : HTML 안에 Java 코드가 있음
Servlet : Java 코드 안에 HTML이 있음

파일명이 index인 경우에는 파일명 입력 없이도 열린다.

<% %> -> 일반 자바 코드를 입력
<%! %> -> 클래스의 필드를 선언한다.

=======================================
22.06.09 목 - 25일차
1장 JSP 기본
스크립트요소 
 - 선언부 
 - 표현식
 - 스크립틀릿

1.3 지시어(Directive)
<%@ 지시어종류 속성1="값1" ... %>
종류
 - page : JSP 페이지에 대한 정보를 설정
 - include : 외부 파일을 현재 JSP 페이지에 포함
 - taglib : 표현언어에서 사용할 자바 클래스나 JSTL을 선언

1.3.1 page 지시어
info, language, contentType, pageEncoding, import, session, buffer, autoFlush, trimDirectiveWhitespaces, errorPage, isErrorPage

errorPage
- 에러가 발생하면 다른 페이지가 나오게 한다.
- 현재는 주로 서버단에서 설정하므로 JSP에서 설정할 필요 없음.

지시어 속성 위치에 ctrl+spacebar 를 누르면 사용할 수 있는 속성들이 나열되어있음.

request : JSP가 가진 내장객체
주소?age=10 
 - request.getParameter("age") 는 10의 값을 받는다

1.3.2 include 지시어 (★)
웹페이지 제작시 코드 중복작성을 피할 수 있음
- header.jsp, footer.jsp를 따로 만들어둔다
- include 지시어를 통해 웹페이지에 해당 부분을 포함시켜준다

<%@ include file="포함할 파일의 경로" %>

web.xml 파일(★★★★★)
- 기본적인 설정 파일 
- 프로젝트마다 존재한다. (톰캣(WAS), web, JSP, homepage, ...)
- <welcome-file> : 기본주소 입력시 나올 페이지(차례대로 우선순위)

Dynamic Web Project 구조(★★★★★)
- src/main/java : java파일
- build/classes : class 파일
- src/main/webapp : 웹 최상위 경로 (jsp, html, css, js, 이미지, ...)
- src/main/webapp/WEB-INF : class파일, 라이브러리(lib), 설정파일... 등 (해당경로에 파일이 있어도 웹상에서 접속할 수 없음, 접근을 막아둠)
- src/main/webapp/WEB-INF/lib : 라이브러리(jar) 위치, 자동으로 라이브러리를 연결해줌
- src/main/webapp/WEB-INF/classes : 클래스파일들 위치 (이클립스는 build/classes에 클래스 파일을 만들지만 실제 서버에서는 이 경로에 지정이 되어있다. classpath가 기본으로 설정된 경로)
- src/main/webapp/WEB-INF/web.xml : 설정파일

http://localhost:8080/contextPath/경로
context path : 프로젝트명 (지금 기준)
context : 별도의 공간(영역)
 - 동일한 도메인인 경우 context path로 구분할 수 있음
 - 이클립스의 서버설정-module탭에서 contextpath를 변경할 수 있음
 - context path를 변경했을 시 톰캣서버에서 프로젝트를 제거했을 경우 context path가 기본값으로 재설정됨 -> 이미지 파일들의 경우 경로를 못찾을 수 있음 -> <%=request.getContextPath() %> 를 이용한다.

ctrl+F5 : 사이트 관련한 cache 메모리 등을 강제로 새로고침함 (★★★)


지시어 <%@ include %> 
- 소스 그대로 포함
- parameter를 넘겨줄 방법이 없음

액션태그 <jsp:include ~>
- 실행한 결과를 포함
- <jsp:param value="" name=""></jsp:param> 태그를 이용해서 parameter를 넘겨줄 수 있음


2장 내장 객체 (Implicit Object)

자주 쓰이는 내장객체(★★★★)
- request
- response
- out
- session

저장소 개념으로 쓰이는 내장객체(★★★★)
 - page  <  request  <  session  <   application
  페이지    요청(★)   브라우저(★)  어플리케이션(전체)

page와 request의 공통점 : 하나의 요청
page와 request의 차이점
- request 하나의 요청에 MVC를 다 담을 수 있음
   M -> Model : java(xml)
   V -> View : jsp         -> request get
   C -> Controller : java  -> requset set

요청 : 브라우저 -> index.do -> Controller -> Service -> DAO -> SQL
응답 : 브라우저 <-   View   <- Controller <- Service <- DAO <- SQL


요청(request) 헤더 : Get/Post
응답(response) 헤더 : HTTP/1.1, Set-Cookie

JSP파일 실행시 컨테이너가 자동으로 내장객체를 생성해줌
- JSP 파일 실행 -> 서블릿으로 컴파일 -> _jspService() 메서드 자동생성

POST 방식으로 한글을 보낼때는 글자가 깨짐
-> request.setCharacterEncoding("UTF-8");

헤더 정보
- user-agent : 사용자 디바이스, 브라우저 등의 식별정보를 담고있음
- referer : 이전 페이지 정보

response 내장객체에서 자주 사용되는 메서드
- sendRedirect(String location)
- foward()

RequestDispatcher("주소:aaa").foward(request, response)
- 주소는 바뀌지 않지만 aaa의 파일의 주소를 나타냄

sendRedirect() / include / forward()의 차이점 잘 확인하기
- sendRedirect() : sendRedirect -> target (최종 주소 : target.jsp)
- include() : include -> target -> include (최종 주소 : include.jsp)
- forward() : forward -(위임)-> target.jsp (최종 주소 : forward.jsp)

sendRedirect()는 요청이 두번 이루어진다. (코드 위치에 상관없이 첫번째 요청이 끝나고 응답을 하는 것이 아니라 두번째 요청을 진행한다.)

   include    |    sendRedirect   |   forward
     포함              이동             위임
   원래 URL          다른 URL         원래 URL
     1요청            2요청             1요청
  request 공유   request 공유X      request 공유


사용자에게는 에러에 대한 정보를 습득할 수 없도록 해야한다.

오늘 복습할 키워드

1.Dynamic Web Project 구조
 - src/main/webapp
 - src/main/webapp/WEB-INF
 - src/main/webapp/WEB-INF/lib
 - src/main/webapp/WEB-INF/classes
 - src/main/webapp/WEB-INF/classes/web.xml

2.contextPath
 - http://localhost:8080/contextPath/경로

3.지시어<%@ include %>와 액션태그<jsp:include ~>의 차이

4.자주 쓰이는 내장객체(★★★★)
 - request, response, out, session

5.저장소 개념 내장객체(★★★★)
 - page, request, session, application

6.클라이언트와 서버간의 요청 및 응답
요청 : 브라우저 -> index.do -> Controller -> Service -> DAO -> SQL
응답 : 브라우저 <-   View   <- Controller <- Service <- DAO <- SQL

7.include(), sendRedirect(), forward()의 차이점

=======================================
22.06.10 금 - 26일차

JSP-sendRedirect 와 JavaScript-location과의 차이
  sendRedirect (a.jsp -> b.jsp -> c.jsp)
   - c.jsp의 referrer : a.jsp

  location (a.jsp -> b.jsp -> c.jsp)
   - c.jsp의 referrer : b.jsp

3장 내장 객체의 영역(Scope)
저장소의 영역!(?)

저장소 개념으로 쓰이는 내장객체(★★★★)
 - page  <  request  <  session  <   application
  페이지    요청(★)   브라우저(★)  어플리케이션(전체)

사용법(API)
- void setAttribute(String name, Object value) : name 속성에 값을 저장 ( name은 첫번째 매개변수 )
- Object getAttribute(String name) : name 속성의 값을 반환 ( name은 첫번째 매개변수 )
- void removeAttribute(String name) : name 속성을 삭제 ( name은 첫번째 매개변수 )

3.2 데이터 전송 객체(DTO) 준비

데이터 전송 객체(DTO, Data Transfer Object) = 값 객체(VO, Value Object)

자바빈즈 규약
1. 자바빈즈는 기본(default) 패키지 이외의 패키지에 속해야한다.
2. 멤버 변수(속성)의 접근 지정자는 private으로 선언한다.
3. 기본 생성자가 있어야한다.
4. 멤버 변수에 접근할 수 있는 게터/세터(getter/setter)가 있어야한다.
5. 게터/세터 메서드의 접근지정자는 public으로 선언한다.

3.4 request 영역

클라이언트가 요청할때마다 새로운 request 객체가 생성된다
같은 요청을 처리하는데 사용되는 모든 jsp페이지가 공유한다.

3.5 session 영역
클라이언트가 웹 브라우저를 최초로 열고난 후 닫을 때까지 요청되는 모든 페이지는 session 객체를 공유한다.
예 - 로그인 상태를 유지하는데 사용됨

3.6 application 영역 
- 잘 사용은 안하나 가끔 설정할 때 사용함 (JSP가 아닌 다른데서 사용)
- 서버가 시작할 때 생성되고 서버를 내릴 때 삭제됨


4장 쿠키(Cookie)
쿠키란
- 클라이언트의 상태 정보를 유지하기 위한 기술
- 키(key) : 값(value)의 형태로 저장
- 파일형태로 저장함
- 객체는 저장할 수 없음
- 저장할 수 있는 용량의 한계가 있음
- javaScript도 쿠키를 사용할 수 있다.

session : 서버에 저장
cookie : PC에 file 형태로 저장

기본 동작 메커니즘
1. 클라이언트가 서버에 요청
2. 서버가 쿠키를 생성 -> HTTP 응답 헤더에 실어서 클라이언트에 전송
3. 클라이언트가 쿠키를 받아서 저장 (서버는 쿠키를 아직 사용 못함)
4. 클라이언트가 다음번 요청시 저장해둔 쿠기를 HTTP 요청 헤더에 실어서 전송
5. 서버가 쿠키의 정보를 읽어 필요한 작업 수행

쿠키의 속성
- 이름 : 쿠키를 구별하는 이름
- 값 : 실제 데이터
- 도메인 : 적용할 도메인
- 경로 : 쿠키를 적용할 경로
- 유지기간 : 쿠키를 유지할 기간

설정 메서드
- void setValue(String value)
- void setDomain(String domain)
- void setPath(String path)
- void setMaxAge(int expire_seconds)
- 이름을 설정하는 메서드가 없음 -> 쿠키의 이름은 생성자를 통해 설정되고 이후 변경할 수 없음

생성자 형태
- new Cookie(String name, String value);

get 메서드
- String getName()
- String getValue()
- String getDomain()
- String getPath() : 설정한 적이 없다면 null을 반환
- int getMaxAge() : 설정한 적이 없다면 -1을 반환

history

=======================================
22.06.13 월 - 27일차
5.5 JDBC 설정 및 데이터베이스 연결

tomcat은 JSP를 work라는 디렉토리로 옮긴다.
work 디렉토리에는 JSP로 생성된 java(서블릿 파일),컴파일한 class 파일, 세션파일들이 상주하는 공간임.

파일 수정했는데 적용이 안되는 경우
 - 웹 모듈에 auto reload 기능이 켜져있는지 확인
 - 서버탭 서버명 우클릭 -> "clean tomcat work directory" -> 체크한 클래스파일을 지우고 다시 컴파일을 한다.
 - 상단 Project -> build Automatically (체크 되어있는지 확인)


5.6 커넥션 풀로 성능 개선

DB 접속시 new 연산자를 이용해 Connection 객체를 생성할 경우 빈번한 연결/해제가 일어나서 시스템 성능에 큰 영향을 미침 -> 현재는 Connection pool이라는 방법으로 미리 Connection 객체를 생성해 풀에 넣어좋고 요청시 생성한 connection 객체를 사용/반납하는 형태로 이루어지고 있음


hikariCP
 - 스트링부트 2.0부터 기본으로 탑재된 JDBC connection pool이다.

5.6.1 커넥션 풀과 JNDI
대부분의 WAS는 커넥션 풀을 비롯한 여러 자원을 JNDI 서비스로 제공하고있음

JNDI : Java Naming and Directory Interface
 - 이름만 알면 찾아서 쓸수있는 디렉터리 서비스 (객체이름과 실제 객체를 연결)
 - 비슷한 예로 DNS (Domain Name System)가 있음 (도메인과 IP주소를 연결)

추후 실무에서 hosts파일(호스트파일) 수정하면서 개발을 하는 경우가 있음
 - hosts 파일 관련 검색하면 자료가 많이 있음
 - 네트워크 관련 공부하면서 알게될 수 있음

5.6.2 커넥션풀 설정
톰캣 서버 설정 파일 수정(server.xml, context.xml)

6장 세션(Session)

쿠키는 문자열로만 저장되나, 세션은 객체도 저장할 수 있음

세션은 클라이언트가 서버에 접속해 있는 동안 그 상태를 유지하는 것이 목적임.

6.3 세션과 DB를 이용한 로그인 구현

6.3.2 DB 연동

- DTO(Data Transfer Object) : 데이터를 교환하기 위해 생성하는 객체
- DAO(Data Access Object) : DB의 데이터에 접근하기 위한 객체
  - CRUD를 전담함 (Create, Read, Update, Delete)

7장 액션태그(Action Tag)

자바빈즈 : 일종의 객체라고 생각하자
- 데이터를 저장하기 위한 멤버변수(속성)와 게터/세터 메서드로만 이루어진 클래스

=======================================
22.06.14 화 - 28일차

8장 모델1 방식의 회원제 게시판 만들기

먼저 어떤 기능을 구현할 지 생각하자

등록기능 : URL이 2개 필요하다
 - 글쓰기 화면 : form이 있는 URL
 - 글쓰기 처리 : DB insert 기능을 하는 URL

8.2.1 MVC 패턴

- 컨트롤러(Controller) - 제어 (사용자 요청 분석, 모델 호출 및 결과값을 뷰에 전달)
- 모델(Model) - 기능, 데이터 처리 (DB 작업도 담당)
- 뷰(view) - 화면출력

모델1
- JSP : 뷰와 컨트롤러 기능
- 자바빈즈 : 모델과 컨트롤러 기능
- 개발속도가 빠르고 배우기 쉬움
- JSP 파일에 뷰와 컨트롤러가 혼재되어서 코드가 복잡해지고 유지보수가 어려움

모델2 (MVC 패턴을 그대로 사용)
- 서블릿 : 컨트롤러
- 자바빈즈 : 모델
- JSP : 뷰
- 업무 분담이 명확해서 코드가 간결해짐 -> 유지보수가 쉬워짐
- 구조가 복잡함

게시판 작성 추가 과제
1. 검색 후 검색 종류 선택
2. 검색 후 검색어 출력
3. 검색 종류에 전체(제목+내용) 추가
4. 목록에 작성자를 ID가 아니라 NAME 출력

=======================================
22.06.15 수 - 29일차

클래스를 제외한 파일명은 대문자로 시작하지 않음

include 지시어 : 소스를 그대로 가져옴
include 액션태그 : 실행한 결과소스를 가져옴

<textarea></textarea> 사이에 공백(탭, 엔터 등)이 있는경우 클라이언트단에서도 그대로 출력됨

8.5 상세보기

9장 게시판에 페이징 기능 넣기

페이지당 개수 : 10
총 개수 : 40 -> 총 페이지 : 4
50 -> 5
41 -> 5
42, 43,..., 49, 50 -> 5

총 페이지 수 = 총 개수 / 페이지당 개수
if (총 개수 % 페이지당 개수 > 0 ) 총 페이지수++
-----------------------------------
총 개수 : 75
1페이지 :  1~10
2페이지 : 11~20
3페이지 : 21~30
4페이지 : 31~40
5페이지 : 41~50
6페이지 : 51~60
7페이지 : 61~70
8페이지 : 71~75

시작값 : (페이지-1)*페이지당개수 + 1
끝값 : 페이지*페이지당 개수
if (끝값 > 총개수) 끝값 = 총 개수

시작블럭값 : (현재페이지-1)/블럭개수*블럭개수
끝블럭값 : 시작블럭값+블럭개수
if (끝블럭값 > 총 페이지수) 끝블럭값 = 총 페이지수

1페이지 -> [1][2][3][4][5]
6페이지 -> [6][7][8]

9.4.2 페이징 처리용 쿼리문 작성

=======================================
22.06.16 목 - 30일차

BoardPage 클래스를 따로 만든 이유 : 관련 메서드를 보관하기 위함 (util용)
 - static 메서드로 만들어서 객체 생성하지 않고도 사용할 수 있게 함

페이징처리 알고리즘에 대해서 말로 설명할 수 있는지...




10장 표현 언어(EL : Expression Language)

EL의 장점(★★★★)
로직은 Java에만 실행하고 JSP에는 로직을 넣을 필요가 없게됨

- 사용법이 간결하다
- 예외와 형변환에 관대하다

표현식을 대체할 수 있음 <%= %>

EL의 기능
 - JSP 내장 객체의 영역에 담긴 속성을 사용할 수 있음
 - 산술, 비교, 논리 연산이 가능
 - 자바 클래스에 정의된 메서드 호출이 가능
 - 표현언어만의 객체를 통해 JSP와 동일한 기능을 수행할 수 있음

기본 사용법
${ 속성 }

- 변수에 접근하기 위해서는 JSP 내장객체 영역에 저장한 후에 사용해야한다.
- 정의된 getter/setter 메서드를 알아서 호출해서 불러온다

내장객체 영역 스캔 순서 
 - page -> request -> session -> application
 - 특정 내장객체만 선택해서 스캔이 가능함 ( ${ requestScope.객체 }

객체 표현방식 : 점(.)이나 대괄호([])를 사용함
 - 일반적으로는 점(.)을 사용함
 - 한글이나 특수기호가 있을경우 대괄호([])만 사용할 수 있음

param : request.getParameter("매개변수명")과 동일하게 요청 매개변수의 값을 받아옴

form으로는 객체 전송이 불가능함 -> 영역을 사용해서 페이지로 전달
 - form은 parameter형태로 전송됨
 - 내장객체 영역에는 Attribute 형태로 전송됨

10.3 컬렉션 사용하기
- EL을 사용하면 컬렉션을 자바코드보다 훨씬 더 간단하게 이용할 수 있음

\을 사용하면 EL코드를 주석처리할 수 있다
 - \${ 속성 } 


제이쿼리 안에 EL표현식이 있을 경우 헷갈리기 쉬움
$(function() {
    $("${name}").click(function () {
        aszzz
    })
}

10.4 EL의 연산자들

대부분 java와 동일하나 키워드를 통해서도 연산자를 사용할 수 있음
div : /
mod : %
gt : >
ge : >=
lt : <
le : <=
eq : ==
ne : !=

empty : 비어있으면 true가 됨
 - null, 빈문자열, 길이가 0인 배열, size가 0인 컬렉션

메서드 호출하기 (instance 메서드)
 - 내장영역에 객체를 저장해서 객체의 메서드를 호출할 수 있음


10.6 static 메서드 호출 (2가지 방법)
10.6.1 클래스명을 통한 호출
 - 클래스명을 통해 직접 메서드 호출이 가능함 (객체 생성 및 영역에 저장과정을 거칠 필요 X)


서블릿과 혼용해서 개발하려면 EL을 사용하는 것이 JSP만 사용하는 것보다 편하게 느껴진다.



11장 JSP 표준 태그 라이브러리(JSTL)

스크립틀릿을 사용하지 않고도 제어문, 반복문을 사용할 수 있게됨

모델2 방식의 웹애플리케이션을 개발할 때 EL과 함께 주로 사용됨

11.1 JSTL이란?
- JSP에서 빈번히 사용되는 조건문, 반복문을 처리해주는 태그를 모아둔 표준 라이브러리

5개의 태그 중에서 2가지만 주로 사용됨 - 안보고 코딩할 수 있어야 함
★★★ c : 변수 선언, 조건문/반복문, URL처리 
★★★ fmt : 숫자, 날짜, 시간 포맷 지정 
    x : xml 파싱
    fn : 컬렉션, 문자열 처리
    sql : 데이터베이스 연결 및 쿼리 실행


https://mvnrepository.com/
-> jtsl 검색 후 2번째 것 -> 1.2버전 jar파일 다운로드 -> web-inf/lib 폴더에 저장

<%@ taglib %> 후 자동완성기능 사용하기 (prefix, uri 등)

11.3 코어(Core) 태그
- if : else문이 없음
- forEach

11.3.1 <c:set> 태그
 - 목록을 반복시키는 경우 필요한 변수 설정에 사용하는 태그

11.3.3 <c:if> 태그 - ★★★★★
<c:if test="조건" var="변수명" scope="영역">
    조건이 true일 때 출력할 문장
</c:if>

else문이 없기때문에 각각 다른 조건

<c:url value="경로"></c:url>
- value 앞에 contextPath를 알아서 붙여준다.

11.3.5 <c:forEach> 태그
일반 for문, 향상된 for문 두가지 형태로 사용이 가능하다

<c:forEach var="변수명" items="컬렉션 혹은 배열" />

varStatus : 루프의 현재 상태를 알려주는 변수의 이름을 지정한다. 
(향상된 for문 형태에서 인덱스 정보를 얻을 수 있다.)
- current, index, count, first, last

11.4 국제화(Formatting 태그) - ★★★★★
숫자 포맷 - formatNumber
날짜 포맷 - formatDate

=======================================
22.06.17 금 - 31일차

EL에서 값을 가져올 때 대부분의 경우엔 request 영역에 있는 속성값을 가져온다.
page, session, application에 있는 사용하는 속성의 naming을 겹치게 사용하지 개발하지 않는다.
-> requestScope.속성명 처럼 "requestScope"를 일부러 쓰는 경우는 흔하지 않게 만든다.

12장 파일 업로드 및 다운로드

파일을 첨부할 수 있는 자료실형 게시판 만들기
 - 업로드 라이브러리 추가
 - form 태그를 통한 전송파일 및 인코딩방식 설정
 - 파일 저장될 폴더의 물리적 경로 설정
 - 파일 다운로드를 위한 I/O 및 응답헤더 설정

파일 업로드 라이브러리 추가하기
- mvnrepository.com에서 "cos" 검색 2번째 클릭 -> (COS » 05Nov2002) -> jar 다운로드


12.2
파일 업로드용 작성폼 속성
- method : post
- enctype : multipart/form-data ( 다른 속성값도 쓸 수 있음 )

enctype을 지정한 경우 multipart/form-data로 지정한 경우 getParameter()로 form 값을 받을 수 없음 -> MultipartRequest 클래스를 사용해서 받을 수 있음


server를 clean 한 경우 물리경로에 저장된 파일이 다 사라지게 된다.
프로젝트에 만들어준 경로에 다시 저장하고 clean을 하면 삭제되더라도 컴파일 할 경우 다시 이동된다.
workspace\.metadata\.plugins\org.eclipse.wst.server.core\tmp0\wtpwebapps\web\uploads
(\web\uploads : 프로젝트와 동일한 경로)


다운로드 과정
       서버        ->    실제파일명    ->      읽기(input)
클라이언트(다운  ) <-   쓰기(output, 원본파일명으로 변경)


추가 과제
1. fileList.jsp JSTL로 적용
2. fileList.jsp 화면에 이미지 노출 (td추가)
3. board에 첨부파일 기능 추가
- 테이블에 컬럼 추가
- 상세페이지에서 첨부 파일이 있는 경우 다운로드

4. 첨부파일이 있는 경우 디스켓 모양

5. 삭제시 사진도 함께 삭제 (DB에 남아있지 않도록하기)
6. 수정시 (?)
 - 방법 1: 기존파일 삭제 체크박스
 - 방법 2: 기존파일 삭제 아이콘 및 파일 추가 기능?


=======================================
22.06.20 월 - 32일차

13장 서블릿(Servlet)
- 서버 단에서 클라이언트의 요청을 받아 처리한 후 응답하는 역할

- 클라이언트의 요청에 대해 동적으로 작동하는 웹 애플리케이션 컴포넌트
- MVC 모델에서 컨트롤러 역할을 함
- 모든 메서드는 스레드로 동작 (웹은 대부분 스레드로 동작함, node.JS는 제외)
- javax.servlet.http 패키지에서 HttpServlet 클래스를 상속받음

서블릿을 관리하는 컨테이너가 필요하다
- 서블릿의 수명주기(생명주기)를 관리
- 요청이 왔을때 스레드를 생성해서 처리해줌
- 클라이언트의 요청을 받아서 응답을 보낼 수 있도록 통신을 지원해줌

통신 지원
수명주기(생명주기 관리)
멀티 스레딩 관리
선언적인 보안관리 및 JSP 지원

13.3 서블릿의 동작방식
1. 클라이언트의 요청 -> 분석 후 요청을 처리할 서블릿 찾기 -> 비즈니스 서비스 로직 호출 -> 모델(Model)로부터 결과값 받기 -> request나 session 영역에 저장 후 결과값을 출력할 뷰(View)를 선택 -> 뷰(jsp페이지)에 결과값을 출력한 후 요청한 클라이언트에 응답


13.4 서블릿 작성규칙
doGet(), doPost()를 오버라이딩 해야한다 (반드시는 X)
- doGet() : get방식을 사용
- doPost() : post방식을 사용

13.5 서블릿 작성
서블릿은 내장객체가 없다...

요청명과 서블릿을 연결해주는 매핑(mapping)이 필요하다.
1. web.xml에 기술하는 방법
2. @WebServlet 애너테이션을 사용하여 코드에 직접 명시하는 방법

13.5.1 web.xml에서 매핑

<servlet>
    <servlet-name> : 서블릿을 참조할 때 사용할 이름
    <servlet-class> : 패키지를 포함한 서블릿 클래스명
</servlet>
<servlet-mappling> : 매핑 정보 등록 부분
    <servlet-name> : <servlet>에서 사용한 <servlet-name>과 동일한 이름 입력
    <url-pattern> : 요청명으로 사용할 경로 (컨텍스트 루트 제외한 경로)
</servlet-mapping>

13.5.2 @WebServlet 애너테이션으로 매핑
- web.xml에 비해 편리하지만, 요청명만으로 클래스를 찾는 것이 쉽지 않다.

13.5.3 JSP 없이 서블릿에서 바로 응답 출력

비동기방식으로 통신할때 XML이나 JSON을 사용하는 경우가 있으며, 
이렇게 순수 데이터만 출력해야하는 경우에는 서블릿에서 직접 출력하는게 편하다 (★★★★)

13.5.4 한번의 매핑으로 여러가지 요청 처리

".one"로 끝나는 모든 요청을 하나의 서블릿으로 처리하기
서블릿을 "*.one"로 매핑한 후 마지막 슬래시로 경로명을 구분해서 담당 메서드를 호출한다.

클래스의 내용이 방대해질 수 있어서 카테고리별로 구분하여 작성하는 것이 좋다.

13.5.5 서블릿의 수명주기(생명주기) 메서드

수명주기 관리는 서블릿 컨테이너가 담당

서블릿 생명주기 메서드
서블릿 객체 생성 -> 전처리를 위한 @PostConstruct -> init() -> service() -> doGet(), doPost() -> destroy() -> 후처리를 위한 @PreDestroy

서블릿 컨테이너가 서블릿 객체를 생성한다
서블릿 객체가 생성된 직후 PostConstruct -> init() 매서드가 최초 요청시 딱 한번 호출이 된다.
이후 요청시마다 service(), doGet()/doPost()가 호출된다.
톰캣 종료시 destroy() -> @PreDestroy가 호출되면서 서블릿 객체가 소멸된다.



추가 과제
1. fileList.jsp JSTL로 적용 (완료)
2. fileList.jsp 화면에 이미지 노출 (td추가) (완료)
3. board에 첨부파일 기능 추가
- 테이블에 컬럼 추가 (완료)
- 상세페이지에서 첨부 파일이 있는 경우 다운로드

4. 첨부파일이 있는 경우 디스켓 모양

5. 삭제시 사진도 함께 삭제 (DB에 남아있지 않도록하기)
6. 수정시 (?)
 - 방법 1: 기존파일 삭제 체크박스
 - 방법 2: 기존파일 삭제 아이콘 및 파일 추가 기능?


=======================================
22.06.21 화 - 33일차

13.6 MVC 패턴을 적용한 회원 인증 구현

경로지정
 - 클라이언트 : context path를 적어야한다.
 - 서버 : context path를 쓰지 않는다.

14장 모델2 방식(MVC패턴)의 자료실형 게시판 만들기

14.1 프로젝트 구상

비회원제
 - 회원인증 없이 누구나 글 작성 가능
 - 비밀번호 입력 필수
 - 비밀번호를 통해 수정이나 삭제가 가능
자료실
 - 글쓰기 시 파일 첨부가 가능
 - 파일 첨부시 정해진 용량 이상은 업로드 불가
 - 첨부된 파일 다운로드 가능


14.1.2 기능별 요청명 정의
- 기능
- 매핑방법 : web.xml / 애너테이션
- 요청명 : ex) /mvcboard/list.do      /mvcboard/write.do
- 컨트롤러(서블릿) : ex) ListController    WriteController
- 뷰(JSP) 경로


구현순서 : 정해진 순서는 없다.
 - DB -> 모델 -> 컨트롤러 -> 뷰
 - 뷰 -> 컨트롤러 -> 모델 -> DB


=======================================
22.06.22 수 - 34일차

MultipartRequest
enctype을 "multipart/form-data"로 선언하고 submit한 데이터들은 request객체가 아닌 MultipartRequest객체로 불러와야 한다.


[쓰기] 첨부파일 추가, 삭제 버튼 만들기
- 첨부파일 수 제한 : 1~5개 
- 6개 이상은 불가 알림
- DB에 file table이 따로 있어야함 

[상세] 첨부파일 목록 확인

[수정] 첨부파일 수정
- 기존 첨부파일 목록 확인
- 기존 첨부파일 삭제버튼 만들기 (ajax를 이용해서 바로 삭제할 수 있게 하기, 삭제전 alert 발생)
- 신규 첨부파일 추가 기능 (쓰기와 동일)

web-inf 안에는 클라이언트가 직접 접속하지 못한다.


=======================================
22.06.23 목 - 35일차

/user/write.do (입력 받기 위해) -> insert.do로 전송
/user/insert.do (전송 받은 값들을 DB에 저장)
/user/index.do (DB에 저장된 데이터를 출력)
/user/view.do (사용자가 클릭한 회원의 상세정보 출력)


강의실 이동 - 컴퓨터 설정 완료
자바, 이클립스, 오라클, sql developer 
인코딩 UTF-8
=======================================
22.06.24 금 - 36일차

스프링 시작
교재 : 코드로 배우는 스프링 웹 프로젝트

Lombok 라이브러리
 - 게터/세터 메서드를 생성할 필요가 없음
 - 어노테이션을 이용하면 알아서 게터/세터가 있는 것처럼 작동됨


1장 스프링 개발환경 구축

스프링 설정
 - JDK버전 설치 (1.8 이상, 그러나 너무 최신버전은 연동에 문제가 있을 수 있음)
 - STS3(eclipse) 설치 및 프로젝트 생성
 - 톰캣 설치 및 연동
 - 오라클 데이터베이스 설치 (+ SQL Develpoer 설치 및 설정)
 - 스프링 프로젝트 생성 및 라이브러리 추가
 - MyBatis / mybatis-spring 설정
 - 스프링 MVC 개발 설정

1.1.6 Marketplace를 이용한 스프링 플러그인 설치 

Help 탭 -> Eclipse Marketplace -> 'sts' 검색 -> STS3 (Standalone Edition) 인스톨 -> 모두 체크된 것 확인 후 'confirm' -> 다운로드 완료 후 '동의(Accept)' 클릭 후 'Finish' -> 우측 하단에 인스톨 되는 과정 막대바로 확인 가능함

STS4는 스트링부트에 최적화되어있기때문에 사용X
현재 교재는 스프링부트가 아닌 스프링을 사용할 예정이기때문에 STS3를 이용

perspective -> Spring 으로 변경
File 탭 -> New -> Spring Legacy Project -> project name 설정, Spring MVC Project 선택 후 next -> top-level 패키지명 설정 (지금은 'org.zerock.controller'로 설정함) -> 'Finish' -> 우측 하단에 프로젝스 생성 과정 막대바로 확인 가능함

오류가 나는 경우 2가지
- java 환경변수가 제대로 설정되지 않은 경우
- eclipse.ini 파일에서 -vm 설정에 경로가 잘못된 경우

Project Explorer (View 열어서 사용 - 없는 경우 side view에서 열기)

Maven 설명 
- 빌더 중 하나
- (Gradle도 방식 유사하나 설정 파일 및 복사하는 내용이 다름)
- mvnrepository.com -> 'spring' 검색 후 'spring context' 클릭 -> 버전 선택 -> 'Maven' 탭 복사해서 pom.xml <dependencise>태그 내에 삽입하고 저장하면 자동으로 받아줌
- pom.xml에서 Maven을 5.0.7버전으로 수정, 자바도 11버전으로 변경 (page 34~35)


설정파일을 수정하고나면 프로젝트 우클릭 -> maven -> Update project 를 실행해주자. force 체크 (단축키 : alt + F5)

Spring Legacy Project 생성
패키지명 작성
SpringMVC Progect 선택

pom.xml
spring 버전 수정 5.0.7
java 버전 수정 1.6 -> 11
servlet 버전 2.5 -> 3.1.0, artifactId

서블릿 버전 수정
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>

서블릿 버전마다 web.xml 초기 설정이 다름
"web.xml dtd" 구글 검색 -> 버전에 맞는 코드 카피해서 수정!

maven update(alt+f5) : force


웹상에서 오목 만들기 (비동기로 만들기)
1. 오목 화면 만들기 (각각 19줄)
 - 화면 구현하기
 - 각 태그마다 구분할 수 있는 속성 달기

2. 공간 클릭시 흑백 구분해서 돌 표현하기
 - 클릭했을 때 돌 표현하기
 - 순서에 따라서 돌 색상 나눠서 표현하기

3. 클릭 위치 Ajax로 보내기
 - 서버에 전달할 URL 및 서블릿 설정
 - 파라미터를 어떤 형식으로 전달할지 결정하기

4. 서버에서 받은 데이터를 기반으로 오목인지 여부 체크하기 (성공, 실패 여부 전달)
 - 받은 데이터 세션에 저장
 - 오목 여부 로직 기반으로 성공여부 답변하기

5. Ajax 데이터 받아서 결과 출력하기
 - 오목 성공시 끝내기
 - (추가기능) 게임 새로 시작버튼, 세션 정보 삭제

=======================================
22.06.27 월 - 37일차

servlet-context.xml 설명(webapp/WEB-INF/spring/appServlet)
<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
    <beans:property name="prefix" value="/WEB-INF/views/" />
    <beans:property name="suffix" value=".jsp" />
</beans:bean>
 - 빈즈 접두사, 접미사 설정이 되어있음 

<context:component-scan base-package="org.zerock.controller" />
 - 스프링 실행시 스캔할 패키지 설정
 - @Controller 가 붙은 클래스를 스캔해서 객체를 등록시켜둠



프론트컨트롤러 : DispacherServlet
 - 모든 요청을 받아서 컨트롤을 해줌
 - DispacherServlet 설정은 web.xml에 있음 (webapp/WEB-INF/web.xml)
 - servlet-context.xml의 위치정보를 가지고 있음 (빈즈 설정 및 서블릿 담긴 패키지 정보)


브라우저에서 요청 -> DS -> controller -> service -> DAO -> SQL 실행
 ( 이부분 필기 못함.. ) view resolver <- service <- DAO <- SQL 결과



========================================================
별도의 톰캣 설치 (이클립스와는 별개, 배포용 서버 구동하기)
https://tomcat.apache.org 접속 -> tomcat 9 -> "32-bit/64-bit Windows Service Installer" 다운로드 -> 설치 실행 -> 포트번호 수정 (80 포트) -> 설치경로 수정

- 이클립스에서 8080 포트를 사용하고 있고, 실제 서비스하는것처럼 포트번호를 80으로 수정
- 설치경로 (kdigital/java/tomcat9.0)

실행시키면 우측 하단 트레이창에 톰캣이 나타남 -> 설정 및 실행,중지를 직접 할 수 있음
주소창에 "localhost"만 치면 기본화면이 나타남 (80포트는 기본이기때문에 생략해도 됨)

톰캣 폴더 설명
 - bin : 톰캣을 실행하고, 종료시키는 스크립트 (.bat , .sh 등) 파일이 들어있다.
 - lib : 라이브러리들이 있음
 - conf : 서버 전체 설정파일 폴더 ( server.xml 등 )
 - logs : 모든 로그들이 쌓임
 - webapps : 사이트 파일들이 잇을 장소
 - work : jsp 파일을 서블릿형태로 변환한 java 파일과 class 파일이 저장

JNDI 설정 
 - server.xml, context.xml 수정 (이클립스에 있는 서버에서 설정한 내용과 동일하게 수정)
 - server : <Resource> 태그 내용 - OracleDriver 관련 설정
 - context : <ResourceLink> 태그 내용

(JNDI의 용도 : 연결하고 싶은 데이터베이스 DB Pool을 미리 Naming 시켜주는 방법
 저장해둔 WAS의 데이터베이스 정보에 JNDI를 설정해두면 웹 애플리케이션은 JNDI만 호출하면 된다.)
(JNDI 정보를 확인하려고 할때 -> 톰캣 서버 설정 파일(server.xml, context.xml)을 확인해야한다. )

이클립스에서 올리고자하는 프로젝트 우클릭 -> export -> war file -> 생성한 war file을 배포용 서버(webapps 폴더)에 넣어주면 알아서 파일들(jsp, class등)이 생성됨 (class파일들도 webapps/프로젝트명/WEB-INF/classes 위치에 들어감)

war파일을 톰캣서버에 넣으면 이제 배포용 서버를 통해서 접속이 가능하게 됨 (이클립스를 통해서 들어가지 않아도 됨)

webapps/ROOT
 - 기본 default 경로 (localhost 이후 컨텍스트path를 입력하지 않으면 기본으로 접속되는 경로)
==================================================================

1.3.1 프로젝트 실행히 흔히 발생하는 문제들
pom.xml에서 빨간색 경고가 발생하는 경우
 - 해당 라이브러리를 다운로드하지 못할 때 생기는 문제
 - Maven으로 다운로드 되는 파일들은 c:/windows/사용자이름/.m2 폴더 내에 모임 -> 이클립스 종료 후 .m2 폴더에 내용을 삭제한 후 다시 실행한다. -> 이클립스 재싱행시 다시 관련 라이브러리를 다운로드하게 됨

tomcat 실행시 에러메시지 "invalid loc header (bad signature)"가 뜨면서 실행되지 않는 경우
 - 라이브러리 관련 오류 -> 라이브러리 문제(위와 같은 방식으로 처리), Maven을 강제로 업데이트(프로젝트 우클릭 -> Maven -> Update Project)


1.4 Lombok 라이브러리 설치 (이클립스에 설정이 필요함)

Lombok : 개발시 자주 이용되는 getter/setter, toString(), 생성자 등을 자동으로 생성해주는 라이브러리

프로젝트에서만 사용되는 것이 아니라서 Eclipse 에디터 내에서도 사용되어야하기 때문에 별도로 설치하는 과정이 필요함

https://projectlombok.org -> download -> 롬복 다운로드

CMD 실행 -> 다운로드 경로로 이동한 뒤 "java -jar lombok.jar" 명령어 실행 -> "Specify location" 클릭해서 eclipse.exe 선택 후 "install/Update" -> 완료 후 "Quit installer" -> 이클립스 재실행

https://mvnrepository.com/ -> 'lombok' 검색 -> project lombok 접속 -> Maven 복사해서 스프링프로젝트 pom.xml 열어서 <dependencise> 태그 사이에 붙여넣기 -> Libraries/Maven Dependencies에서 lombok jar파일이 생성된 것 확인 (dependency 추가로 생성된 lombok.jar 파일로 이클립스 내 롬복 설치과정을 수행해도됨)

java 파일에 게터/세터 삭제 -> 클래스 위에 @Getter, @Setter 어노테이션 추가 후 자동임포트! -> 게터/세터가 없어도 사용이 가능함 (컴파일된 class파일에 게터/세터 코드가 생성된 되는 원리)

개발환경에서만 lombok.jar파일이 필요하고 서버에서는 필요없음 (class파일에 이미 게터/세터가 만들어져있기때문)


1.5 Java Configuration을 하는 경우 (xml 파일이 아닌 java로 설정하는 방법)

New -> Spring Legacy Project -> 프로젝트명 설정, Spring MVC Project 선택 후 'next' -> 패키지파일명 설정 후 finish.
web.xml 파일 및 spring 폴더 삭제
pom.xml 파일 수정
 - maven-war-plugin 추가
@Configuration을 이용하여 설정파일을 직접 작성 (RootConfig 클래스)
web.xml을 대신하는 클래스 작성 (추상클래스 상속 - AbstractAnnotationConfigDispatcherServletInitializer)


2장 스프링의 특징과 의존성 주입

스프링의 주요 특징
 - POJO 기반의 구성 (POJO : 일반적인 자바 객체라고 생각하자)
 - 의존성 주입(DI)을 통한 객체 간의 관계 구성
 - AOP (관점 지향 프로그래밍) 지원
 - 편리한 MVC 구조
 - WAS의 종속적이지 않은 개발 환경

의존성(Dependency) : 하나의 객체가 다른 객체 없이 제대로 된 역할을 할 수 없는 것
 - 스프링에서는 ApplicationContext라는 존재가 필요한 객체들을 생성하고, 필요한 객체들을  - 주입하는 역할을 하는 구조를 가진다.
 - 빈(Bean) : ApplicationContext가 관리하는 객체
 - 빈과 빈 사이의 의존 관계를 처리하는 방식의 종류 : xml, 어노테이션, java

AOP의 지원
 - 비즈니스 로직은 아니지만 반드시 처리가 필요한 부분을 '횡단 관심사'라고 함
 - 이러한 횡단 관심사를 모듈로 분리하여 다루기 위해 AOP가 사용됨


프로젝트의 scr 폴더 내 'root-context.xml' : 스프링 프레임워크에서 관리해야하는 객체(빈)를 설정하는 설정파일
 - servlet-context.xml : 요청과 관련된 객체를 정의
 - root-context.xml : view와 관련되지 않은 객체를 정의


- 스프링이 스캔 중에 @Component 어노테이션이 있으면 객체를 생성한다.
- @Component가 있는 클래스 내에 @Autowired를 가진 필드가 있으면 생성한 객체 중에 해당되는 타입이 있는지를 확인하고 있을경우 그 객체를 주입해서 콤포넌트를 생성해서 보관한다.


2.3 스프링이 동작하면서 생기는 일
2.3.1 테스트 코드를 통한 확인

테스트코드 작성에 필요한 라이브러리 추가
JUnit을 사용하기 위해서는 "Spring TestContext Framework"가 있어야함
mvnrepository.com에 가서 Spring TestContext Framework를 버전에 맞는 것 찾아서 dependency 추가



=======================================
22.06.28 화 - 38일차

@Setter : 컴파일시 자동으로 settter를 생성해줌
@Autowired : 해당 인스턴스 변수를 스프링으로부터 자동으로 주입해달라는 표시
@Test : JUnit에서 테스트 대상임을 알려주는 표시

assertNotNull() : 매개변수가 null이 아니어야 테스트가 성공한다.

@Data는 여러 어노테이션을 포함한다 (@Getter, @Setter, @toString, @HashCode, @NoArgsConstructor, ... 등등)

팩토리 : 객체를 생성하는 곳
컨테이너 : 생성된 객체를 관리하는 곳

테스트를 통해 알 수 있는 중요한 점 3가지
(1) 테스트코드가 실행되기 위해 스프링 컨테이너가 동작함 
(2) 동작하는 과정에서 필요한 객체들이 스프링에 등록됨 (스캔을 통해서 동작)
(3) 의존성 주입이 필요한 객체는 자동으로 주입이 이루어짐 

스프링 컨테이너는 @Autowired를 통해 객체 인스턴스를 싱글톤으로 관리한다.

===============================================================
자바설정으로 설정파일 만들기
1. web.xml 및 spring 관련파일(root-context.xml, servlet.xml)을 삭제한다.
2. config 패키지를 생성하고 그 안에 RootConfig, ServletConfig, WebConfig를 만든다.
 - @Configuration 을 통해 설정파일이라는 표시를 해준다.
 - xml에서 컴포넌트스캔 부분은 어노테이션으로 대체한다 (@ComponentScan)
 - RootConfig : root-context.xml과 동일한 역할

 - WebConfig : web.xml과 동일한 역할
    - AbstractAnnotationConfigDispatcherServletInitializer를 상속받는다
    - getRootConfigClasses()를 오버라이드할때 RootConfig.Class를 배열형태로 리턴해준다.
    - getServletConfigClasses()를 오버라이드할때 ServletConfig.Class를 배열형태로 리턴해준다.
 - ServletConfig : servlet-context.xml과 동일한 역할
    - viewResolver 관련 설정을 해준다 (prefix, suffix, viewclass, ... 등)
=============================================================== 

@Log4j : 로그객체를 생성해줌 -> 별도의 로그를 설정할 필요 없이 필요한 코드를 만들 수 있음

테스트 코드 작성에 사용했던 어노테이션 정리 
Lombok 관련 어노테이션 : @Setter, @Data, @Log4j
Spring 관련 어노테이션 : @Autowired, @Component
테스트 관련 어노테이션 : @RunWith, @Contextconfiguration, @Test

@ContextConfiguration
 - 스프링이 실행되면서 어떤 설정 정보를 읽어들여야하는지를 표시함
 - (기본값)locations : xml 설정 파일 명시할 수 있음
 - classes속성으로 @Configuration이 적용된 클래스를 지정해줄 수 있음


@Bean과 @Component와의 차이

@Bean
 - 외부 라이브러리의 객체를 등록하고자 할 때 사용
 - 메서드에 사용함 (메서드를 통해 외부 라이브러리 객체 생성)

@Component
 - 개발자가 직접 컨트롤이 가능한 내부클래스에 사용
 - 클래스에서 사용


spring 프로젝트 패키지 구분
 - chap01 : 빈을 생성하고 꺼내보는 실습
 - chap02 : 빈이 주입되는 다양한 형식들
 - chap03 : ↓↓↓
@Service, @Repository, @Controller (@Component와 동일하나 MVC에서 용도에 따라 의미를 부여함)
 - Service -> Service
 - DAO -> Repository
 - Controller -> Controller

ApplicationContext : 스프링 컨테이너를 의미함

=======================================
22.06.29 수 - 39일차


==========포트폴리오 웹에 올리는 방법 2가지 (시작)============

방법 1. 웹호스팅 - 카페24, 후이즈, 가비아 
https://hosting.cafe24.com/ 
-> 스페셜호스팅 -> tomcat 호스팅 -> 일반형

방법 2. AWS
aws 서버 1년간 무료제공 -> 자바, DB, 톰캣서버 설치해서 배포


// 도메인은 살 필요가 없음 (IP로 접속 하는 걸로..)

==========포트폴리오 웹에 올리는 방법 2가지 (끝)============

3장 스프링과 Oracle Database 연동

mvnrepository.com 통해서 ojdbc 최신버전(21.6.0.0.1) 받기

3.4 커넥션 풀 설정 (HikariCP)
mvnrepository.com 통해서 'HikariCP' 최신버전(5.0.1) 받기
("HikariCP"라고 검색해야 최신버전이 나온다)


04. MyBatis와 스프링 연동

MyBatis : SQL 매핑 프레임워크로 분류됨
 - 자동으로 Connection close() 가능
 - MyBatis 내부적으로 PreparedStatement 처리
 - #{prop}와 같이 속성을 지정하면 내부적으로 자동 처리
 - 리턴 타입을 지정하는 경우 자동으로 객체 생성 및 ResultSet 처리

mvnrepository.com 통해서 최신버전 받기
 - MaBatis (3.5.10)
 - MyBatis-spring (2.0.7)

스프링라이브러리는 스프링 버전과 똑같이 맞춰주도록 하자
 - Spring JDBC (5.0.7)
 - Spring Transaction (5.0.7)

4.2 스프링과연 연동처리

MyBatis의 Mapper
 - sql과 그에 대한 처리를 지정하는 역할
 - xml과 인터페이스 + 어노테이션 형태로 작성이 가능하다

4.2.1 Mapper 인터페이스
테스트코드가 정상적으로 작동한다면 스프링 내부에 TimeMapper 타입으로 만들어진 스프링 객체가 존재한다는 뜻이다.

개발시에는 인터페이스만 만들어줬는데 내부적으로 적당한 클래스를 만들어서 구현해줌

인터페이스만 만들면 구현클래스는 마이바티스가 만들어준다는 원리...
스프링이 인터페이스를 이용해서 객체를 생성한다.

4.2.3 XML 매퍼와 같이 쓰기
어노테이션 방식이 편리하나 SQL문이 복잡하거나 길어지는 경우는 XML을 이용하는 방식을 더 선호하게 된다.

이 경우 XML 파일의 위치가 중요함
 - Mapper 인터페이스가 있는 위치와 동일하게 해야함
 - src/main/resources


==========이클립스 프로젝트 Propertise 메뉴 설명=============
Build path->source 를 확인하면 자바파일의 타겟 폴더를 확인 할 수 있다. (컴파일한 파일들이 위치하는 장소)


Deployment Assembly
 - Source : 실제 작업할때 경로
 - Deploy Path : 배포했을 때 경로 (웹에서 접속하는 경로)


==========이클립스 프로젝트 Propertise 메뉴 설명=============

log4jdbc-log4j2
 - SQL 로그를 제대로 보기 위한 라이브러리
 
1. pom.xml에 디펜던시를 추가해서 라이브러리에 추가한다.
2. src/main/resources 에 파일을 추가한다.
 - 파일명 : "log4jdbc.log4j2.properties"
 - 내용 : "log4jdbc.spylogdelegator.name=net.sf.log4jdbc.log.slf4j.Slf4jSpyLogDelegator"
3. rootconfig에 driverClassName, JdbcUrl 설정을 수정해준다

로그 레벨 
 - all > trace > debug > info > warn > error > fatal > off
 - all : 모든로그를 보여줌
 - off : 로그 X

일반적으로 로그레벨은 "error"로 설정해둠(실제 운영서버)
(개발서버에서는 "debug")

System.out.println()은 톰캣 서버에 있는 디스크에 파일을 쓰는 작업이기때문에 속도가 느려지는 원인이 됨

=======================================
22.06.30 목 - 40일차

myBatis
 - ORM(Object Relational Mapping)의 일종
 - iBatis는 myBatis의 전신
메서드 (SqlSessionTemplate 객체가 기본으로 가진 템플릿 메서드들)
 - insert, update, delete
 - selectOne : 하나만 조회
 - selectList : 여러개가 조회될때

메서드명("namespace.id", [파라미터]) 
 - 파라미터는 생략 가능
 - ex) sst.insert("board.insert", dto)     (sst는 sqlSessionTemplate)

xml 태그 (SqlSessionTemplate를 빈으로 등록)
 - select, insert, update, delete 
 - 태그 속성
    - parameterType : 파라미터의 자료형
    - resultType : 결과값의 자료형
    - resultMap : 결과값을 별도로 매핑
        - 내부 태그 result 속성 : column, property
    - parameterMap : 파라미터 값을 별도로 매핑
 - SQL문 : SELECT count(*) FROM board WHERE title LIKE '%${searchWord}%'
    - # or $: 필드명에 맞는 게터메서드를 호출해서 자리에 넣어줌
    - #{필드명} : PrepareStatement -> ? 사용
    - ${필드명} : Statement -> 값이 그대로 들어감

변수명 = "aaa"일때
#{변수명} => 'aaa' 문자열 형태로 들어감
${변수명} => aaa 그대로 들어감
때문에 '%%'안에 사용할때는 $를 사용해야한다.


-----------xml에서 사용할 수 있는 문법---------------------
<where> : myBatis가 알아서 where 조건문을 완성해줌 (where, and 처리 등)

<if>
 - 속성 : test
 - 논리연산자 : and, or (소문자로 사용해야한다!)

<choose><when><otherwise>

<foreach>
 - 속성 : collection, open, close, seperator

<sql> : 검색조건을 따로...
 - 속성 : id

<include> : sql에서 작성한 것을 끌어다 쓸 수 있음
 - 속성 : refid
-----------xml에서 사용할 수 있는 문법---------------------

Mapper Scan을 위한 설정
1. 스캔 경로 설정 
 - 경로설정 방법 1. 
    <mybatis-spring:scan base-package="스캔경로"/>
 - 경로설정 방법 2. 
    <bean id="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="스캔경로"/>
    </bean>
2. Mapper 인터페이스 생성 및 Mapper 어노테이션 설정
3. xml 파일 생성 
 - Mapper인터페이스 파일과 동일한 위치
 - Mapper인터페이스 파일명과 동일하게 설정
 - Mapper 관련 메서드 정의

=======================================
22.07.01 금 - 41일차

mybatis
${value}
#{value}

ibatis
$value$
#value#

$과 #의 차이
$ - Statement -> 그대로 들어간다!
# - PrepareStatement

5장 스프링 MVC의 구조

web.xml, root-context.xml, servlet-context.xml

 - web.xml : Tomcat 구동과 관련된 설정
 - root-context, servlet-context : 스프링과 관련된 설정


ContextLoaderListener의 역할
 - xml 설정파일이 여러개 있을 때 사용한다.
 - 없을경우엔 default로 된 하나의 파일만 설정파일로 사용
 - <context-param>을 읽어서 설정파일을 여러개 읽을 수 있게 한다.

5.3 스프링 MVC의 기본사상

스프링이 중간역할을 하기때문에 HttpServletRequest, HttpServletResponse를 사용할 일이 현저히 줄어들게 된다.
 - 스프링이 내부적으로 Servlet API를 활용함

6장 스프링 MVC의 Controller

Controller의 특징
 - HttpServletRequest, HttpServletResponse를 거의 사용할 필요 없이 필요한 기능을 구현
 - 다양한 타입의 파라미터 처리, 다양한 타입의 리턴 타입 사용 가능
 - GET 방식, POST 방식 등 전송 방식에 대한 처리를 어노테이션으로 처리 가능
 - 상속/인터페이스 방식 대신에 어노테이션 만으로도 필요한 설정이 가능


6.3 Controller의 파라미터 수집
Controller를 작성할 때 가장 편리한 기능이 파라미터를 자동으로 수집해주는 기능이다.
 - 매번 request.getParameter()를 사용하는 불편함을 없앨 수 있음

사용가능한 표현
@RequestParam("nickname") : 파라미터 이름이 "nickname"
@RequestParam(value="nickname", required = false) : 파라미터 이름이 "nickname"이고, 필수로 입력해야하는 파라미터가 X
@RequestParam(value="nickname", required = false, defaultValue="0") : 파라미터 이름이 "nickname"이고, 필수로 입력해야하는 파라미터가 X, 기본값은 0

6.3.5 @DateTimeFormat
날짜를 변환하는 방법
그냥 String으로 받아서 쓰는 방법도 있다.

6.4 Model이라는 전달자

Model 객체 : JSP(MVC 모델2)에서 request 객체와 유사한 역할을 한다.
(Model 객체는 실제 내부적으로 request객체에 set을 한다.)

request는 하나의 요청에서만 저장된다
Model은 객체가 유지되는 동안 저장된다
(실제 사용할 때는 거의 차이가 없다)

6.4.4 redirect

서블릿에서 response.sendRedirect()와 같은 용도로 사용된다.

return "redirect:(주소)";

요청에 응답하지 않고 새로운 요청으로 가서 응답된다.


jackson 라이브러리
 - json 형식으로 변환할때 사용하는 라이브러리
 - @ResponseBody로 사용함
 - 객체를 리턴해도 json 타입으로 출력이 됨
 - response 타입이 HTML이 아니라 json 타입으로 응답함
   (응답헤더 -> Content-Type: application/json;charset=UTF-8)

ResponseEntity : 응답헤더에 원하는 메시지와 상태코드를 담아서 응답할 수 있다.


사용불가한 표현
@RequestParam("nickname", required = false)
 - 속성을 2개를 쓰고자 할때는 반드시 value를 넣어줘야한다. 생략이 불가능함

=======================================
22.07.04 월 - 42일차

자바설정 방식 (xml방식과 혼용하기)
web.xml에 DispatcherServlet에 초기화 파라미터 추가
 - contextClass : 설정 클래스파일 (org.springframework.web.context.support.AnnotationConfigWebApplicationContext)
 - contextConfigLocation : 자바설정 파일 위치

web.xml에 인코딩 필터 설정 (spring이 가진 필터 적용)


자바설정파일 (contextconfigLocation에 매핑된 파일)
 - WebMvcConfigurer 인터페이스 구현하기
 - configureDefaultServletHandling 오버라이드하기
    - 정적인 URL을 default servlet이 처리할 수 있도록 하는 메서드
 - configureViewResolvers 오버라이드하기
    - ViewResolver가 prefix, suffix 설정하기



------------- 이클립스 톰캣 서버 설정 (start) ---------------
 - autoreload 설정 : 자바파일이 수정된 것을 보면 자동으로 재시작 할 수있게끔 하는 설정
 - 운영서버에서는 사용하지 않는다 (서버에 부담이 감)
------------- 이클립스 톰캣 서버 설정 (end) ---------------


하나의 url에서 두개의 처리 (로직, 응답), 2개 이상도 가능
1. Request 객체로 구분해서 처리하기
 - HttpServletRequest 객체를 매개변수로 받기
 - Request객체의 getMethod()값이 "GET"인지 "POST"인지 구분해서 viewResolver에 리턴해준다. (equals 매서드로 비교하기때문에 대소문자 구분해줘야한다.)

2. @RequestMapping으로 구분
 - method를 RequestMethod="GET", RequestMethod="POST"로 구분
3. @GetMapping / @PostMapping으로 구분



리턴이 없는 경우 (매핑URL과 같은 경로의 jsp 파일을 포워딩함)
redirect -> url 자체가 바뀜 
예) return "redirect:/board/test.do";
 - board/test.do로 url이 바뀜
 - 포워딩의 경우엔 url은 바뀌지 않음


redirect: 과 주소 사이 공백 여부 차이
 - redirect:주소 (공백X) -> 컨텍스트패스와 상관없이 이동    
   "redirect:/board/test.do"
    -> localhost:8080/spring/board/test.do

 - redirect: 주소 (공백O) -> 컨텍스트패스를 포함한 경로로 이동 
   "redirect: /board/test.do"
    -> localhost:8080/board/test.do


리턴 없음 (jsp가 필요 없는 경우)
 - HttpServletResponse 객체에 getWriter()를 이용
 - PrintWriter 객체에 담아서 print


값을 저장소에 저장하기 (request / session) -> jsp에 꺼내쓰기위함
1. Request에 저장하기
(1) request에 저장 (하나의 요청에서만 공유가 가능)
 - HttpServletRequest 객체에 setAttribute() 메서드 이용
(2) Model 객체에 저장
 - spring이 알아서 request에 저장함
2. Session에 저장하기
(1) request 객체의 getSession() 메서드 이용
(2) HttpSession 객체를 이용
단순비교하면 HttpSession 객체를 이용하는 것이 더 편해보이나 대부분의 경우 이미 Request 객체를 사용하고 있기때문에 Request객체를 이용해서 Session을 사용하는 것이 편할 때도 많다.

3. ModelAndView 객체 리턴하기
 - 값과 jsp 경로를 ModelAndView 객체에 저장할 수 있음

-------------------------------------------------
한글 출력하는 방법 (setCharacterEncoding)       |
 - response.setCharacterEncoding("utf-8") 사용  |
 - PrintWriter 객체보다 위에 있어야한다.        |
-------------------------------------------------

비즈니스 로직이 필요없는 페이지(디자인만 있는 페이지)
 -> Controller를 굳이 따로 만들 필요가 없을때
 -> Config파일에 직접 controller를 지정할 수 있음
 -> addViewControllers(ViewControllerRegistry reg)를 오버라이드
    - reg.addViewController("요청주소").setViewName("jsp페이지명")


파라미터를 받는 4가지 방법
1. HttpServletRequest 객체 이용
2. @RequestParam 이용
 - 기본값 : 필수입력    &&    매개변수명이 파라미터명과 일치해야함
 - 이름이 다른 경우 : @RequestParam의 name 속성에 파라미터명 지정
 - 필수값이 아닌경우 : required 속성을 false로 지정
 - 기본자료형인 경우 : required=false로 지정해도 에러남 (null 지정할수없기때문) -> defaultValue 지정
3. 커맨드 객체(ModelAttribute) 이용
 - VO(DTO) 객체에 필드명과 파라미터명이 일치하면 자동으로 저장해줌 (일치하지않으면 저장X)
 - 자동으로 request에 저장 (VO(DTO)객체를 매개변수로 넣어주기만 하면 된다)
 - 배열로 전송되는 경우 각 값들을 ","로 구분하여 하나의 문자열로 저장함 (필드가 배열로 선언되었을시 배열로 전환해줌)
4. @PathVariable
 - URL : @GetMapping("/board/{page}/{searchWord}")
 - 매개변수 : @PathVariable int page, @PathVariable String searchWord
예) http://localhost:8080/spring/param/board/1/자바
   -> page : 1, searchWord : 자바
 - API에서 주로 사용되나 다른 곳에서는 잘 사용되지 않음

=======================================
22.07.05 화 - 43일차

BoardController
 - URL매핑, jsp포워딩, service 호출

BoardService
 - list(count+list+페이징 처리)

BoardDAO
 - count
 - list

BoardVO
 - 모든 컬럼

board.xml
 - count
 - list

jsp
 - 목록 출력, 검색, 페이징


controller -> service -> DAO -> SQL 
controller <- service <- DAO <- SQL 

=======================================
22.07.06 수 - 44일차

6.5.5 파일 업로드 처리

서블릿 3.0 이후(톰캣 7.0)은 추가 라이브러리가 필요 X

1. 파일 업로드에 필요한 라이브러리 다운로드(commons-fileupload 또는 cos.jar)
 - commons-fileupload (mvnrepository에서 받는다)

2. servlet-context.xml에 "multipartResolver" 빈 객체 추가
 - 필드 초기화 (defaultEncoding, maxUploadSize, maxUploadSize, uploadTempDir, maxInMemorySize)
 - defaultEncoding : 인코딩 형태
 - maxUploadSize : 파일 업로드 제한
 - maxUploadSize : 개별 파일 업로드 제한
 - uploadTempDir : 업로드할 위치
 - maxInMemorySize : 메모리상에서 유지하는 최대 크기


6.6 Controller의 Exception 처리
처리방법 2가지
 - @ExceptionHandler와 @ControllerAdvice를 이용한 처리
 - @ResponseEntity를 이용하는 예외 메시지 구성

6.6.1 @ControllerAdvice
AOP방식을 이용하면 공통적인 예외사항에 대해서 별도로 분리할 수 있다. (@ControllerAdvice 이용)
 - @ControllerAdvice : 사용된 객체에서 발생하는 예외를 처리하는 존재임을 알려주는 어노테이션
 - @ExceptionHandler : 메서드에서 발생하는 예외타입을 알려주는 어노테이션


7장 스프링 MVC 프로젝트의 기본구성

웹프로젝트는 일반적으로 3-tier(티어)방식으로 구성된다 (presentation, business, persistence tier)

Presentation Tier(화면 계층)
 - 화면에 보여주는 기술을 사용하는 영역

Business Tier(비즈니스 계층)
 - 비즈니스 로직을 담고 있는 영역
 - 고객의 요구사항을 반영하는 계층

Persistence Tier(영속 계층, 데이터계층)
 - DB와 연결된 계층
 - 데이터를 보관하고 사용하는 방식에 대한 설계

각 영역 네이밍 규칙
 - Controller : 스프링 MVC에서 동작하는 Controller 클래스
 - Service, ServiceImpl : 비즈니스 영역을 담당
 - DAO, Repository 
 - VO, DTO : 데이터를 담고있는 객체
    - VO : 일반적으로 Read Only 목적이 강하고, 데이터 자체도 immutable(불변)하도록 설계함
    - DTO : 데이터 수집 목적이 더 강함

패키지의 네이밍 규칙
 - 방법 1 : 영역별로 패키지를 설계하는 방법(controller별, service별, ...)
 - 방법 2 : 비즈니스 단위별로 구분하는 방법


1. 요구사항 분석설계 
2. 화면 설계(스토리보드 작성) 
 - 목업 툴 이용 : PowerPoint, Balsamiq studio, Pencil Mockup, Power Mockup, 카카오오븐(무료)
  
----------(start)MyBatis 사용법---------------
두가지 방법이 있음
1. SqlSessionTemplate를 사용하는 방법 (MyBatis 3.0 이전)
2. MapperInterface를 사용하는 방법 (MyBatis 3.0 이후에 생김)

SqlSessionTemplate 사용
 - SqlSessionFactory에 MapperLocation 경로를 설정해줘야함(SQL이 들어있는 xml 경로)
 - DAO에서 SqlSessionTemplate(sst)를 주입받아서 사용
 - 사용법 예) sst.selectOne("namespace.id", vo);
    - namespace : xml의 namespace 값
    - id : xml에서 SQL문 태그의 id 값
    - vo : 매개변수로 사용할 객체

MapperInterface 사용
 - mybatis-spring:scan 매퍼인터페이스 파일 스캔할 경로 지정 필요(root-context.xml)
 - Mapper 인터페이스 파일 생성 : 사용할 함수 정의
 - mybatis-spring scan : sql.xml 파일 경로를 인터페이스 파일과 동일한 경로에 생성(src/main/resources/..이하)
    - mybatis-spring scan을 사용하기 위해서는 xml 상단에 "xmlns:mybatis-spring" 설정 필요
 - 사용법
    - namespace : 경로포함한 인터페이스명 작성(org.xx.xx.Xx)
    - SQL문 태그의 id : 인터페이스에 정의된 함수명과 일치
 - 매퍼인터페이스를 만들면 mybatis가 알아서 클래스를 정의해서 객체를 만들어준다.

기타
 - parameterType, resultType 필요시 지정
 - <![CDATA[  ]]> : SQL문에 있는 부등호 기호(<, >)를 태그로 인식하는 것을 막아주기 위함
----------(end)MyBatis 사용법---------------

=======================================
22.07.07 목 - 45일차

8장. 영속/비즈니스 계층의 CRUD 구현

영속계층의 작업 순서 
 - 테이블의 칼럼 구조를 반영하는 VO(Value Object) 클래스의 생성
 - MyBatis의 Mapper 인터페이스의 작성/XML 처리
 - 작성한 Mapper 인터페이스의 테스트

<![CDATA[  ]]> : SQL문에 있는 부등호 기호(<, >)를 태그로 인식하는 것을 막아주기 위함

8.2 영속 영역의 CRUD 구현

8.2.1 CREATE(insert) 처리
 - 생성된 PK값이 필요없는 경우
 - 생성된 PK값이 필요한 경우 : @SelectKey 어노테이션을 이용하여 PK값을 미리 처리해서 설정한 이름에 보관하는 방식

8.2.2 READ(select) 처리
 - PK값을 이용해서 데이터를 조회

예) 
- 함수 정의 : BoardVO read(long bno);
- SQL문 : SELECT * FROM tb1_board WHERE bno = #{xxxx}   
   파라미터 값이 하나만 넘어오기때문에 "xxxx"처럼 아무거나 써도 된다. 


9장. 비즈니스 계층

비즈니스 계층 : 로직을 기준으로 처리를 한다 -> 하나의 메서드에서 여러가지 기능을 구현한다는 의미
 - 영속계층에서는 하나의 메서드에서 하나의 기능만을 구현했다.

10장 프레젠테이션(웹) 계층의 CRUD 구현

톰캣의 실행 없이 Controller를 test하는 방법을 알 필요가 있음

테스트 어노테이션 관련 정리
 - @Before : @Test가 있는 메서드가 실행되기 전에 매번 실행된다
 - @WebAppConfiguration : Servlet의 ServletContext를 이용하기 위한 어노테이션 -> 스프링에서는 WebApplicationContext를 이용하기 위한 표시
    - 필드에 WebApplicationContext 객체를 주입받을 수 있음
 - @FixMethodOrder(MethodSorters.NAME_ASCENDING) : @Test를 메서드명 순서대로 실행시킬 수 있음

addAttribute 과 addFlashAttribute의 차이
 - redirect를 했을 경우 주소창을 보면 차이를 느낄 수 있다
 - 사용 예 
   redirect -> "/board/list"
   추가할 attribute -> "result" : "success"
    - addAttribute 사용시 주소창 : /board/list?result=success
    - addFlashAttribute 사용시 주소창 : /board/list

=======================================
22.07.08 금 - 46일차

11장 화면처리

jsp파일을 WEB-INF 폴더 내에 저장하는 이유 -> 클라이언트에서 직접 접속하는 것을 막기위함

모달(Modal)창 보여주기
 - <div>를 이용하여 알림창을 활용하는 방법
 - 플러그인마다 코드가 달라질 수 있기때문에 개념을 익히도록 하자

<c:out value="${aaa}"/> 와 ${aaa}의 차이 -> 보안성 때문에 <c:out> 을 사용한다

<a> 태그에서 클릭시 새창으로 열고싶으면 target="_blank" 로 지정한다. target 속성은 기본이 "self"다

뒤로가기 함수 : history.back(-1) 또는 history.back() 
 - 기본값이 '-1'이다.
 - 숫자를 통해 뒤로가기 정도를 조절할 수 있음


13장 MyBatis와 스프링에서 페이징 처리

인덱스힌트 /*+INDEX_DESC(테이블명 인덱스명) */
 - SELECT절 첫줄에 인덱스힌트를 사용해서 조회할 때 사용할 인덱스를 부여할 수 있다
 - 주석에 꼭 "+"가 붙어야 힌트절이 실행된다
 - 사용 예 : /*+INDEX_DESC(board pk_board) */


복습
 - 기존의 HTML 템플릿을 기준으로 게시판 기능 구현하기
 - 각 순서마다 서버, 클라이언트 응답이 잘 이루어지는지 확인하기
 - 구현 순서 : 

1. HTML -> JSP로 변환 및 구역별 분할 (header, footer, body)
2. resouces 파일 연결
3. 게시판 목록 구현 -> EL표현식 및 <c:foreach> 사용
4. 글 생성 기능 연결 
 - JSP 생성 및 header, foot 연결
 - 필터 처리 (utf-8)
 - 글 생성에 필요한 파라미터들이 전송되어야함
5. 모달 창 기능 구현
6. 수정 및 삭제페이지 구현
 - 필요한 파라미터들이 전송되어야함
7. 각종 버튼 기능 구현 및 리팩터링

=======================================
22.07.11 월 - 47일차

13.2. BoardController와 BoardService 수정

14장 페이징 화면 처리

조회, 수정, 삭제페이지까지 페이지번호가 계속해서 유지되어야만 하기 때문에 끝까지 신경써야할 부분들이 많음

페이징 처리 과정
 - 브라우저 주소창에서 페이지 번호를 전달해서 결과를 확인하는 단계
 - JSP에서 번호를 출력하는 단계
 - 각 페이지 번호에 클릭 이벤트 처리
 - 전체 데이터 개수를 반영해서 페이지 번호 조절

14.1 페이징 처리할 때 필요한 정보들
 - 현재 페이지 번호(page)
 - 이전과 다음으로 이동 가능한 링크의 표시 여부(prev, next)
 - 화면에 보여지는 페이지의 시작 번호와 끝 번호(startPage, endPage)

=======================================
22.07.12 화 - 48일차

15장. 검색 처리

검색조건
 - <select> 태그를 이용하는 방법
 - <checkbox> 태그를 이용하는 방법

MyBatis의 동적 태그들
 - if
 - choose (when, otherwise)
 - trim (where, set)
 - foreach

<trim>, <where>, <set>은 단독으로 사용되지 않고 <if>, <choose>와 같은 태그들을 내포하여 SQL을 연결해줄 때 사용된다.

15.4 화면에서 검색 조건 처리
 - 페이지 번호가 파라미터로 유지되었던 것처럼 검색 조건과 키워드 역시 항상 화면 이동시 같이 전송되어야 한다.
 - 화면에서 검색버튼을 클릭하면 새로 검색한다는 의미이므로 1페이지로 이동한다.
 - 한글의 경우 GET 방식으로 이동할 때 문제가 생길 수 있으므로 주의해야 한다.

UriComponentsBuilder 클래스 
 - 여러개의 파라미터를 연결해서 URL 형태로 만들어주는 클래스 (스프링이 제공해줌)
 - builder 클래스의 경우 new 연산자를 사용을 못하고 메서드를 통해서 builder 인스턴스(객체)를 이용하는 경우가 많다.


Part 4. Rest 방식과 Ajax를 이용하는 댓글 처리
학습목표
 - REST api
 - Ajax

16장 REST 방식으로 전환

REST(Representational State Transfer)
 - 하나의 URI는 하나의 고유한 리소스(Resource)를 대표하도록 설계된다는 개념

REST 관련 어노테이션
 - @RestController : Controller가 REST 방식을 처리하기 위한 것임을 표시
 - @ResponseBody : 일반적인 JSP와 같은 뷰로 전달되는 것이 아니라 데이터 자체를 전달하기 위한 용도
 - @PathVariable : URL 경로에 있는 값을 파라미터로 추출할때 사용
 - @CrossOrigin : Ajax의 크로스 도메인 문제를 해결해주는 어노테이션 (★★★★)
 - @RequestBody : JSON 데이터를 원하는 타입으로 바인딩 처리

Ajax의 크로스 도메인 문제
 - 다른 서버와의 통신을 보안상의 문제때문에 클라이언트 단에서 차단되는 문제
 - 이를 해결하기 위한 것이 @CrossOrigin 이라는 어노테이션


REST 방식에서 기억해야할 것
 - 서버에서 전송하는 것이 순수한 데이터 형태이다!
 - JSP같은 뷰(view)로 전달하지 않는다.
 - 보통 JSON이나 XML로 처리한다.

REST관련 라이브러리
 - jackson-databind
 - jackson-dataformat-xml
 - gson

JSON의 구조
 - [] : 배열(array)을 의미
 - {} : 객체(object)를 의미

@GetMapping에 사용된 produce 속성 
 - 해당 메서드가 생산하는 MIME 타입을 의미함
 - 반드시 지정해야하는 것이 아니라서 생략도 가능하다 
 - 기본값은 XML (".json"을 붙여서 요청하면 json 형태로 받음)


16.2.2 객체의 반환
객체를 반환하는 작업은 JSON 이나 XML을 이용함

SampleVO에서 필드를 int가 아닌 Integer로 선언한 이유
 - 기본자료형을 쓸 경우 null값일 때 에러가 나는 경우가 있음 -> 때문에 데이터를 전달하는 경우에 int보다는 Integer클래스를 사용해야함.

16.2.4 ResponseEntity 타입
 - 데이터를 요청한 쪽에서 정상/비정상 데이터를 구분할 수 있는 확실한 방법을 제공해야한다.
 - ResponseEntity는 데이터와 함께 HTTP 헤더의 상태메시지등을 같이 전달하는 용도로 사용한다.

@RequestBody
 - JSON 데이터를 원하는 타입의 객체로 변환해야 하는 경우에 주로 사용

16.5 다양한 전송방식

GET/ POST 외에 다양한 방식으로 데이터를 전달한다
 - 등록 : POST
 - 조회 : GET
 - 수정 : PUT
 - 삭제 : DELETE

POST 방식도 그렇지만 PUT, DELETE 방식은 브라우저에서 테스트하기가 쉽지 않기때문에 다른 도구들을 이용해서 테스트하고 개발을 한다.


=======================================
22.07.13 수 - 49일차

REST API
 - client : server 독립적 구조
 - stateless : 서버에서 상태 미저장
 - cache : 서버의 응답을 cache에 저장 (빠른 응답)
 - layer(층) : 계층구조 (교체, 확장에 용이한 구조)
 - interface : 일관성

Restful (restful하다)
 - 자원식별
   : URI (http://abc.com/member/10)
 - 리소스 조작
   : json, xml (header) 지정
 - 메시지
   : method (get, post, put, delete...)를 이용하여 메시지 전달

method 구분
 - get : 리소스 취득
 - post : 리소스 생성
 - put : 리소스 갱신
 - delete : 리소스 삭제
 - head : 헤더 취득
 - options : 지원가능한 method 확인
 - trace : 요청 메시지 반환
 - connect : 프록시 동작의 접속으로 변경


protocol://destination:port/contextPath/URI
프로토콜://도메인[아이피]:포트번호/컨텍스트패스/경로
예시)
- https://game.naver.com:443/esports/news/all
- http[https]://localhost:8080/spring/test.do


커맨드객체(VO객체)를 이용하여 파라미터를 받고 데이터를 전송할때는 jackson 라이브러리가 있어야한다.
 - jackson 라이브러리가 커맨드객체를 json, xml 형태로 바인딩해서 전송해준다.

REST API 개발 툴 (크롬 확장프로그램)
 : Talend API Tester - Free Edition


요청 및 응답에서 문제가 생기는 경우
※ 클라이언트와 서버간 파라미터 표기법을 다르게 사용하는 경우 (카멜, 스네이크)  // 예 : 카멜로 요청하면 스네이크에서는 담기지 않음
 1. 클래스내 모든 필드 전체 적용 (@JsonNaming 어노테이션 사용)
    VO클래스에 @JsonNaming 어노테이션 사용해서 해결 가능
    예 : @JsonNaming(PropertyNamingStrategy.SnakeCaseStrategy.class)
    요청(스네이크) -> 처리(카멜, VO) -> 응답(스네이크)
  
 2. 필드별로 개별 적용 (@JsonProperty 어노테이션 사용)
    예 : @JsonProperty("nick_name")

※ 값이 없는 경우(null)
 1. VO클래스에 @JsonInclude 어노테이션 사용
    VO객체에 담을 데이터를 정할 수 있음
    예 : @JsonInclude(value = Include.NON_NULL) -> null이 아닌 값들만 json에 포함시킴



/api/board/list (spring 프로젝트 chap06 패키지)
-> 1페이지 게시물 10개, json으로 응답

1. 설정 (라이브러리, dbcp, mybatis) + 자바설정파일
2. xml (sql)
3. mapper
4. 컨트롤러에서 호출
5. 리턴


CORS(접근허용)
@CrossOrigin(origins = {"http://192.168.0.19:5500"})
 - 크로스도메인 접근문제를 해결하는 예시

1. 계좌관리 테이블 만들어서 구현
 - DB 이용
2. 계좌관리 + ajax (게시판 페이지 이동 ajax 구현)
3. 고양이 사진 사이트 + ajax 구현

=======================================
22.07.14 목 - 50일차

17장 Ajax 댓글 처리

브라우저에 있는 캐시 지우기
 - Ctrl + F5

=====================참고(시작)============================
자바 설정 프로젝트에서 인코딩 필터 추가하는 법
WebCongig.class 에서 onStartup()을 오버라이드해서 설정을 추가해야한다.

------구현 코드 내용(시작)-------
super.onStartup(servletContext); // 조상 생성자 호출
// 파라미터 인코딩 설정
FilterRegistration.Dynamic filter = servletContext.addFilter("encodingFilter", CharacterEncodingFilter.class);
filter.setInitParameter("encoding", "UTF-8");
filter.addMappingForServletNames(null, false, "dispatcher");
------구현 코드 내용(끝)------- 
======================참고(끝)============================

17.2.4. @Param 어노테이션과 댓글 목록

MyBatis에서 두 개 이상의 파라미터 전달 방법
1) 별도의 객체를 구성하기
2) Map을 이용하는 방식
3) @Param을 이용해서 이름을 이용하는 방식

@RequestMapping 속성 정리
 - value : mapping 경로
 - method : 요청받을 method 종류 선택 (get, post 등등) 
 - consumes : 전송받는 데이터의 형식
 - produces : 응답할때 전송할 데이터의 형식

@RequestBody : json 형식의 데이터를 객체형태로 받을 때 주로 사용하는 어노테이션 (파라미터를 정의할때 사용)

17.4 JavaScript 준비
JavaScript의 클로저를 이용하는 것은 관련 함수들을 하나의 모듈처럼 구성하는 대표적인 방법 중 하나이다.

자바스크립트 파일이 따로 분리된 경우 브라우저에서 확인시 캐시를 초기화(Ctrl + F5) 해줘야 반영되는 경우가 있다.

콜백함수 정리
1.
var aaa = function() {
    return "1";
}

- aaa의 자료형은 함수형임!

2.
var bbb = (function() {
    return "1";
})()

- bbb의 자료형은 함수형임
- 끝에 '()'가 들어가기때문에 bbb를 호출하면 함수가 바로 실행됨!

3.
var abc = (function() {
    function first() {
    }

    function second(param) {
    }

    function third(param, callback) {
    }
    
    return { 
        first : first, 
        second : second, 
        third : third, 
})()

- abc의 자료형은 함수가 됨!
- 끝에 ()가 있기때문에 호출시 바로 실행됨
- 함수 안에 함수가 있음
   - abc.first() : abc안에 first()가 실행됨
   - abc.second(1) : abc안에 second()가 1을 매개변수로 해서 실행됨
   - abc.third(a, function() {consol.log(222)})
     - abc 안에 third()가 매개변수를 가지고 실행됨
     - 정의된 매개변수 param 에 a가 대입되서 실행
     - 정의된 매개변수 callback에 익명함수가 대입되서 실행


$.getJSON() : get 방식 ajax통신을 간편하게 하기 위해 만들어진 메서드 ($.ajax()보다 형식이 간편함)


=======================================
22.07.15 금 - 51일차

스프링 게시판 댓글 화면처리



=======================================
22.07.18 월 - 52일차

17.5.3. 특정 댓글의 클릭 이벤트 처리

DOM에서 이벤트 리스너를 등록하는 것은 반드시 해당 DOM 요소가 존재해야만 가능하다
 - 동적으로 태그가 만들어진 이후에 이벤트를 등록해야하기때문에 일반적인 방식이 아닌 "이벤트 위임(delegation)"의 형태로 작성해야한다

이벤트 위임 : 이미 존재하는 요소에 이벤트를 검 -> 이후에 이벤트 대상을 변경
 - $('.chat').on("click", "li", funtion() {   });
 - 이벤트를 'chat' 클래스에 걸었으나 실제 이벤트 대상은 <li>태그가 되도록 한다.



복습
1. 이벤트 위임
 - 댓글 클릭시 수정, 삭제 이벤트 구현
2. 댓글 페이징 처리
 - 페이징 처리를 위한 SQL 수정
 - 해당 bno에 대한 댓글 숫자 파악 (SQL 및 관련 매서드 정의)
 - 페이징 관련 HTML을 추가하는 메서드 정의



프로젝트 예시
첫번째
 - 카페 검색, 평가, 순위
두번째
 - 동물병원
 - 예약, 입양
세번째 
 - 쇼핑몰
네번째
 - 편입 영어 기출 사이트

기획
 - 주제 선정
 - 레퍼런스
   - 검색엔진 추가 감안
   - 다양한 기능 (로그인 등등)
   - 데이터(공공데이터, API, 크롤링)
   - 주제 세분화

설계
 - 기능정의서 (기능단위로 분담)
 - 화면설계(스토리보드)
 - DB 설계(논리 -> 물리)

구현
 - 

테스트

배포(AWS, 카페24)

포트폴리오 문서


=======================================
22.07.19 화 - 53일차

스프링 게시판 복습 시작

어떻게 구현할지에 대해서 생각해보기---------
(1) 게시판 글 리스트 구현
 - 목록 조회에 필요한 SQL 및 관련 메서드 정의
 - 클라이언트 화면 내 기능 구현
(2) 상세페이지 구현
(3) 새글 작성 구현
 - 로그인 및 작성 권한 여부 확인
 - SQL 및 관련 매서드 정의
 - 백엔드 및 프론트엔드 연결
(4) 수정, 삭제 구현
(5) 검색기능 구현
(6) 로그인 기능 구현
(7) 댓글 기능 구현
(6) 회원가입 기능 구현
----------------------------------------------

게시판(/board)
- 목록(/index.do)
  - 전체카운트, 목록조회, 검색, 페이징처리
- 상세(/view.do)
  - 해당글 조회, 조회수 1증가
- 등록 insert.do (등록폼 write.do)
- 수정 update.do (수정폼 edit.do)
- 삭제 delete.do

mapper
- 전체 카운트
- 해당 페이지 조회 (검색 포함)
- 상세글 조회
- 조회수 +1
- 수정
- 삭제

테이블 생성
프로젝트 생성(spring legacy project)
스프링 설정 (스캔, db)
dependency (spring, db관련, junit, mysql, 롬복)
controller, service, mapper, xml, jsp
테스트


암호화
- password()함수
- MD5
(DB버전이 바뀌면서 암호화방식이 변하는 경우도 있다. 로그인 상에 문제가 생길 수 있음)

DB 테이블 생성

servlet-context.config 설정파일 따로 위치를 바꿈 (resources/config폴더로 이동)
 - web.xml 파일 내 위치 변경 (/WEB-INF/classes/config/servlet-context.xml)
 - root-context.config 파일 삭제 -> servlet-context.config로 통일
 - web.xml에서 <context-param>, <listener> 설정 삭제

Dependency 추가
 - 롬복, 스프링-테스트, mysql-커넥터-j, 스프링-tx, 스프링-jdbc, 히카리CP, 마이바티스, 마이바티스-스프링, log4jdbc
 - ojdbc는 oracle 관련 jdbc임

============= web.xml : beans 설정 (시작) ====================
맨 처음 부분에 있는 설정 관련
<beans xmlns="http://www.springframework.org/schema/beans http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mybatis-spring="http://mybatis.org/schema/mybatis-spring"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

이렇게 설정되어있으면 아래부분에서 태그 설정 시에 어떤 xmlns인지를 표현해줘야한다.
xmlns:xsi     -> <xsi:~~~>  </xsi:~~>
xmlns:context -> <context:~~~> </context:~~~>
xmlns:beans   -> <beans:~~~> </beans:~~~>

xmlns: 만 있는 경우에는 그냥 사용이 가능하다.
============= web.xml : beans 설정 (끝) ====================

board 테이블 컬럼 설정
 - 번호(pk) : no, int, auto_increment
 - 제목 : title, varchar(255)
 - 내용 : content, text
 - 작성일 : regdate, timestamp
 - 조회수 : viewcount, int
 - 회원pk : member_no, int
 - 첨부파일명(원본) : filename_org, varchar
 - 첨부파일명(실제) : filename_real, varchar

=======================================
22.07.20 수 - 54일차

게시판(/board)
- 목록(/index.do)
  - 전체카운트, 목록조회, 검색, 페이징처리
- 상세(/view.do)
  - 해당글 조회, 조회수 1증가
- 등록 insert.do (등록폼 write.do)
- 수정 update.do (수정폼 edit.do)
- 삭제 delete.do

mapper
- 전체 카운트*
- 해당 페이지 조회 (검색 포함)*
- 상세글 조회*
- 조회수 +1*
- 등록*
- 수정*
- 삭제*

service -> interface / impl(구현클래스)
- 목록 (카운트, 조회)
- 상세 (조회수+1, 상세글 조회)
- 수정폼 (상세조회)
- 수정처리 (수정)
- 삭제처리 (삭제)
- 등록처리 (등록)

mySQL의 특징
 - "ORDER BY" 보다 "LIMIT"가 더 나중에 실행된다.
 - LIMIT 시작인덱스, 페이지당개수

1페이지 : 0
2페이지 : 10
3페이지 : 20
4페이지 : 30

시작인덱스 = (페이지번호 -1) * 페이지당 개수

myBatis에 기본적으로 걸려있는 alias
 - int -> java.lang.Integer
 - map -> java.util.Map
 - string -> java.lang.String

Mapper 어노테이션이 있는 것만 Mapper Bean으로 등록되도록 하는 설정
 - annotation="org.apache.ibatis.annotations.Mapper" -> 매퍼스캔 설정에 추가 
 - 해당 설정이 없으면 스캔범위에 있는 모든 인터페이스 파일을 찾아서 빈으로 등록한다.
 
jsp파일이 아닌 다른 정적파일들에 대한 요청을 스프링이 인식할 수 있도록 하는 설정
- xml방식
 <mvc:default-servlet-handler/>
- 자바방식
 @Override
 public void configureDefaultServletHandling (DefaultServletHandlerConfigurer conf) { conf.enable(); }

=======================================
22.07.21 목 - 55일차

커맨드객체로 파라미터를 받으면 그 커맨드객체를 이용해서 EL 표현식을 사용할 수 있다.
 - (백엔드) BoardVO로 파라미터를 받을 경우 -> (프론트) ${boardVO.page} 와 같이 이용이 가능함


게시판(/board)
- 목록(/index.do)*
  - 전체카운트, 목록조회, 검색, 페이징처리*
- 상세(/view.do)*
  - 해당글 조회, 조회수 1증가*
- 등록 insert.do (등록폼 write.do)*
- 수정 update.do (수정폼 edit.do)*
- 삭제 delete.do*

mapper
- 전체 카운트*
- 해당 페이지 조회 (검색 포함)*
- 상세글 조회*
- 조회수 +1*
- 등록*
- 수정*
- 삭제*

service -> interface / impl(구현클래스)
- 목록 (카운트, 조회)*
- 상세 (조회수+1, 상세글 조회)*
- 수정폼 (상세조회)*
- 수정처리 (수정)*
- 삭제처리 (삭제)*
- 등록처리 (등록)*


board(게시판) 존재 -> news 게시판 만들기

=======================================
22.07.22 금 - 56일차

SQL에서 테이블명을 변수로 선언해서 하나의 SQL문을 여러 테이블에 같이 사용할 수 있다

VO 대신 Map을 이용할 수 있다.
 - @RequestParam Map map 을 사용하면 알아서 키:값 형태로 저장된다.

LinkedHashMap 은 순서가 있는 Map이다
 - 리스트 대신해서 사용할 수 있는 Map 형태다


파일 업로드
- dependency 추가
- xml 설정
- form enctype 추가
- 컨트롤러 MultipartFile 추가
- 파일명 변경
- vo set
- 다운로드

저장은 .metadata 내 경로에 저장된다.
 - clean Tomcat work directory를 실행하면 .metadata에 저장된 파일들이 다 사라지게 된다.


-----------스케쥴-----------------
오늘 : 회원가입
다음주 : 
 - 로그인
 - 로그인 체크 (인터셉터)
 - 글 작성(세션의 no 저장)
 - 댓글(ajax:json, html), 공용
 - 목록 댓글 수 출력
 - 답변게시판(계층형 게시판)

git
----------------------------------

회원가입
- 회원등록*
- 비밀번호 암호화*
- 이메일 중복체크(ajax) -> 쓰면 바로 체크되는 경우도 있음(keyup)
- 유효성 체크
- 주소(우편번호, 기본주소, 상세주소), 우편번호API

create table -> engine 타입
 - innoDB : 일반적인 형태
 - myISAM : DB가 파일형태로 있어서 옮기기 쉬움 -> 에러가 날때 있음

비밀번호 -> 암호화해야함, 복호화되어서는 안됨

카테고리로 나뉘는 것은 전부 정수형태로 저장해야한다.
 - 검색 및 정렬을 할때 인덱스를 사용해야하는데 텍스트는 인덱스 활용이 어려움
 - 생년월일같이 불가피한 경우 char를 사용한다 (자리수 불변 -> 인덱스 활용 가능)

SQL문 작성시 DB툴에서 컬럼명 복사한뒤, 편집기에 replace 기능 이용해서 쉽게 작성하자


암호화 : DB에 insert할때 MD5()함수를 이용해서 저장
 - 비교할때도 md5()를 적용해서 비교

우편번호 API : 카카오 우편번호 API 사용

=======================================
22.07.25 월 - 57일차


 - 이메일 중복 체크*
 - 이메일 형식 체크* (정규식 패턴 사용 -> 검색)

 - 로그인*
 - 로그인 체크 (인터셉터)
 - 글 작성(세션의 no 저장)
 - 댓글(ajax:json, html), 공용
 - 목록 댓글 수 출력
 - 답변게시판(계층형 게시판)


모든 제약조건을 코드를 새로 작성해서 구현하려고 하지 말고, 기존에 있는 태그들의 속성을 활용하자
 - <input> 태그 내 : maxlength, required 등등
 - required 속성의 경우 form 태그내 input[type='submit']을 이용할 시에 작용한다.

ajax 시간 차이에 의한 문제
 -> aysnc 속성을 false로 주면 통신이 완료된 후 다음으로 넘어감

ajax - success 함수 : return문
 - 콜백함수이기때문에 ajax 상위 함수가 return에 의해 종료되지 않음
 -> flag를 이용해서 불만족시 함수가 중지되도록 함

달력 사용하기
 - https://jqueryui.com/ 접속
 - jqueryui CDN 추가
    <script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
 - jqueryui css link 추가
    <link rel="stylesheet" href="//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
 - datepicker() 메서드 사용

간단히 이용하기
 - 구글 검색 : "jquery datepicker 사용법" 검색 후 적용


form태그의 onsubmit 속성
 - input type=submit 태그를 클릭할때 작용
 - return을 안쓰면 false를 리턴해도 전송이 됨
   예시 : onsubmit="return loginCheck();" -> loginCheck()가 false값 리턴해야 전송 X
          onsubmit="loginCheck();" -> 함수 실행여부와 상관없이 form이 전송 됨
 - return false가 되어야 전송이 안됨

input 태그 속성 - autocomplete
 - "off"로 설정 : 이전 입력 내역 안보이게 하는 설정

=======================================
22.07.26 화 - 58일차

 - 로그인 체크 (인터셉터)*
 - 글 작성(세션의 no 저장)*
 - 댓글(ajax:json, html), 공용
 - 목록 댓글 수 출력
 - 답변게시판(계층형 게시판)


##################################################
login관련 SQL을 짤때는 ${} 가 아닌 #{}을 사용해야한다.
 -> 보안문제가 있기때문에 PrepareStatement 방식을 이용해야한다
 - SQL Injection이 생길수있음
##################################################

세션 초기화하는 방법
 - sess.invalidate();
    세션 초기화
    (장바구니, 회원활동내역같은 것 들도 세션에 담겨있을 수 있기 때문에 보통 세션 초기화를 하는 편임)
 - sess.removeAttribute(String name);
    세션에 있는 해당 값만 삭제
    해당 값이 없으면 에러가 남


인터셉터(interceptor)
 - 핸들러로 요청이 도달하기 전에 낚아채서 추가적인 작업을 하는 것
 - 특정 Controller의 핸들러가 실행되기 전이나 후에 추가적인 작업을 할 수 있게 해줌
 - 로그인 체크와 같은 목적에 사용됨
 - 활용도 : 로그인체크, 접속 로그, 카운트, 요청처리시간 확인, 웹공격 차단 등등

(1) HandlerInterceptor 인터페이스 구현한 interceptor 클래스 생성
 사용할 수 있는 메서드 
 - preHandle :  컨트롤러 실행 전
 - postHandle : 컨트롤러 실행 후 (뷰 리턴 전)
 - afterCompletion : 뷰 실행 후 
(2) 로그인 체크시에는 preHandle 을 재정의
    세션 객체에서 loginInfo 이름으로 꺼내서 
    값이 있으면(로그인 상태) -> return true
    값이 없으면(로그아웃) -> return false
(3) servlet-context.xml 에서 interceptor 설정
 - <mvc:interceptors>
 -   <mvc:interceptor>
 -     <mvc:mapping path="/board/**/"/> -> 인터셉트할 요청
 -     <mvc:exclude-mapping path="/board/view.do"/> -> 인터셉트를 안할 요청
 -     <bean class="interceptor.MemberLoginInterceptor"/> -> 인터셉트해서 실행할 클래스 정보


-------------------------------
시큐리티
 - 인터셉터 기능 + 권한 부여
-------------------------------

글 작성(세션의 no 저장)
 - session에 저장된 "loginInfo" 객체의 no를 꺼낸다.
 - 두가지 방법
   - write.jsp 에서 input[type='hidden']으로 저장하는 방법
     -> 보안적으로 위험할 수 있음
   - session에 저장된 것을 서버에서 꺼내서 저장하는 방법

댓글 기능 정의*
 - 목록 (해당 게시물의 댓글, 페이징처리)
 - 등록
 - 삭제(본인이 작성한 댓글만)
 - ajax 처리

댓글 테이블 생성*

=======================================
22.07.27 수 - 59일차

 - 댓글(ajax:json, html), 공용 -> json이 아니라 jsp형태로 리턴
 - 목록 댓글 수 출력
 - 답변게시판(계층형 게시판)

댓글 기능
 - 목록 (해당 게시물의 댓글)*
 - 등록*
 - 삭제(본인이 작성한 댓글만)
 - ajax 처리*

------------------------
내일 할 것들
- 댓글 페이징
- 댓글 삭제
- 댓글, 게시물 작성자
- 게시물 목록 댓글 수 

- 아이디 / 비밀번호 찾기
------------------------

=======================================
22.07.28 목 - 60일차

##################################
이클립스 단축키
- ctrl + e : 열린 창 확인 후 이동
- ctrl + shift + r : 파일 열기
##################################

- 댓글 페이징*
- 댓글 삭제*
- 댓글, 게시물 작성자*
- 게시물 목록 댓글 수 *

- 아이디 / 비밀번호 찾기

AWS 회원가입
 - 보안자격증명 -> 멀티팩터 인증 (OTP 설정)
 - 지역(리전, region) 설정 : 서울
 - EC2 검색 -> 인스턴스 -> 인스턴스 -> 인스턴스 시작
    - 이름 : db
    - ubuntu : Ubuntu Server 22.04 LTS (HVM), SSD Volume Type 선택 (64비트 x86)
    - 프리티어 사용 가능한 것으로!
 - 키 페어 생성
    - 키페어이름 설정 : db 로 설정함
    - 생성되면 파일(*.pem)이 받아지는데 잘 보관하고 잇어야함
    - 리눅스에서는 보통 사용자계정/.ssh 폴더내에 보관함
      현재 (C:\Users\tjoeun-jr-902-02\.ssh\db.pem 에 저장시킴)
 - 보안그룹 생성
 - 에서 SSH 트래픽 허용(위치 무관) 체크
 - 스토리지 구성 그대로하고 "인스턴스 시작" 
 - 잠시 설정시간이 지나가면 인스턴스 실행 중인 모습을 확인할 수 있음
    - 인스턴스 상태가 종료되어야 실행시간에 적용 안됨 -> 요금 부과 안됨 (중지는 부과 가능)
 - "퍼블릭 IPv4 DNS", "퍼블릭 IPv4 주소"에 적힌 IP로 접속이 가능함

xshell 검색 후 다운 (다른 shell프로그램을 사용해도 무방함)
 - 무료 라이선스 페이지(비상업적 사용에 한해 무료) -> 이름 및 메일 입력 후 xshell 체크하고 다운 -> 메일로 발송된 링크를 통해 다운 -> 설치 (default값으로 진행)
 - 새로만들기 
    - 이름 설정 : db (임의 설정)
    - 프로토콜 : SSH
    - 호스트 : 서버 IP(퍼블릭 IP) -> 서버를 껐다 키면 바뀜
   - 사용자 인증 
     - 이름 : ubuntu (임의 설정)
     - 방법 -> 퍼블릭 키 설정 -> 받아둔 키페어 파일(*.pem) 찾아서 등록 (암호는 설정 안했음)
   - 완료하고나서 "연결" 

AWS 프리티어 
 - 1년간 750시간/월 무료
 - 반영되는 시간 -> 인스턴스 가동시간


 
=======================================
22.07.29 금 - 61일차

리눅스 최고관리자 계정 : "root"

리눅스 기본 명령어
 pwd : 현재 디렉토리 위치 출력(print working directory)
 ls : 파일/디렉토리 목록 출력(list, 윈도우는 dir)
 ls -a : 숨겨진 파일/디렉토리도 출력
 ls -l : 상세 정보 출력
 ls -al : 숨겨진 파일까지 상세정보 출력
 ls [대상] : 대상 경로에 있는 파일/디렉토리 목록 출력
 cd : 디렉토리 이동 (change directory)
 ('~'표시 : 내 계정의 home 디렉토리를 뜻함)
 ('-'표시 : 이전에 있던 디렉토리로 이동)
 touch 파일명
 - 크기가 0인 빈 파일을 생성
 - 파일이 존재하면 수정일시 업데이트
 mkdir : 디렉토리 생성 (make directory)
 cp : source파일을 destination에 복사(copy)
 - cp source destination
 mv : 파일 이동(move) + 이름변경도 가능
 - mv source destination
 rm : 삭제 (remove)
 - rm 파일명 : 파일 삭제
 - rm -r 디렉토리명 : 디렉토리 삭제
 - rm -f : 강제 삭제 (rm -rf : 강제로 하위디렉토리까지)
 cat : 파일 내용 출력
 head : 파일 내용 위에서 10줄
 tail : 파일 내용 밑에서 10줄
 more : 페이지 단위로 출력

############## ls 상세정보 화면 설명 ##############
(1)(2)      (3) (4)   (5)    (6)      (7)      (8)
  drwx------ 2 ubuntu ubuntu 4096 Jul 28 03:53 .ssh

(1) : 파일 유형 ( 일반파일 - / 디렉터리 d / 블록디바이스 b / 문자디바이스 c / 링크 l )
(2) : 파일허가권 
 - 권한 ( 읽기 r / 쓰기 w / 실행 x )
 - 문자 3개씩 구분 : 순서대로 (사용자/사용그룹/나머지사용자)
(3) : 링크의 수
(4) : 파일 소유권을 가진 소유 사용자명
(5) : 파일을 소유한 그룹의 이름
(6) : 파일의 크기
(7) : 파일의 최종 수정일시
(8) : 해당 파일의 이름
###################################################

-------------------------------------------------------
vi편집기 : 리눅스 편집기 중 하나
vi 파일명 (존재하면 해당파일이 열리고, 없으면 생성해서 열림)
 i : 편집모드
 esc : 명령모드
 :w - 저장
 :q - 종료
 :wq - 저장 후 종료
 :q! - 강제 종료 (저장X)
 :set number - 행번호 표시
 :행번호 - 해당 행번호로 이동
 /검색어 - 검색
     n : 다음 검색 결과로 이동
     shift + n : 이전 검색결과로 이동
 $ - 해당 라인의 마지막으로 이동
 ^ - 해당 라인의 처음으로 이동
 x - 현재커서위치의 문자하나 삭제
 dd - 현재 행 삭제
 yy - 현재 행 복사
 p - 현재 행 아래위치에 붙여넣기
 shift + g - 마지막 라인으로 이동
 gg - 첫 라인으로 이동

-------------------------------------------------------
AWS에 DB 설치하기 순서
xshell 실행
관리자권한으로 실행하는 법 : 명령어 앞에 "sudo"를 붙여서 실행
$ sudo apt-get update
$ sudo apt-get install mysql-server

$ sudo mysql
mysql> alter user 'root'@'localhost' identified with mysql_native_password by 'root1234';
mysql> \q

$ sudo mysql_secure_installation
Enter password for user root: -> root1234
Would you like to setup VALIDATE PASSWORD component? -> N (강한 비밀번호 방법을 설정할 것인지 묻는 질문)
Change the password for root ? -> N
Remove anonymous users? -> Y (비밀번호 없이 접속할 수 있는 계정들을 삭제할 것인지 묻는 질문)
Disallow root login remotely? -> N  (원격접속을 막을지에 대한 질문)
Remove test database and access to it? -> Y
Reload privilege tables now? -> Y

외부 접속 허용 설정
$ mysql -uroot -p
(root계정으로 비밀번호 입력한 뒤 mysql 실행하겠다는 의미, 비밀번호는 커맨드 실행 후 입력한다.)
mysql> create user 'root'@'%' identified with mysql_native_password by 'root1234';
  (원격으로 접속이 가능한 계정 생성하기
  mysql> select host, user from mysql.user;
  실행하면 host가 %인 root 계정이 생성된 것 확인할 수 있음
  host %값인 뜻 : host가 localhost가 아닌 모든 곳에서 접속할 수 있음
  )
mysql> grant all privileges on *.* to 'root'@'%' with grant option;
 (생성한 계정에 모든 권한 부여)
mysql> exit 
 (mysql 종료)

$ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf
(mysql 설정 변경하기 : 접속가능한 경로 수정하기)
/bind 검색 후 편집
 (수정전)bind-address      = 127.0.0.1 (해당 IP에서만 접속)
 (수정후)bind-address      = 0.0.0.0 (모든 IP에서 접속 가능)
:wq

$ sudo systemctl restart mysql
 (mysql 재시작)

- 같은 서버에 was와 DB가 있다면 같은 local에 속하기 때문에 ip 설정을 바꿀 필요가 없음
- was와 DB가 다른 서버에서 운영된다면 해당 IP에서 접속이 가능하게끔 설정함. (WAS 내 java가 실행되어서 DB에 접속하기때문에 WAS 위치가 중요함)
- 지금처럼 모든 IP에서 접속이 가능하게 설정을 바꾼 이유는 다른 PC에서 workbench를 통해 DB에 접속하기 위함.

workbench 실행
새로운 Connection 생성
 - Connection Name : aws
 - Hostname : aws 퍼블릭 IP (현재입력은 15.164.103.67)
 - 연결 테스트하면 오류남 -> 추가 설정이 필요함 (일단 connection 저장)
 - AWS 인스턴스 안에 ubuntu가 설치되어있기 때문에 현재 AWS 인스턴스 접속단계에서 차단된 상태임 -> 3306 포트를 열어서 3306포트는 모든 IP에서 접속이 가능하게끔 설정해야함
aws 홈페이지 로그인 -> EC2 -> 인스턴스 -> DB가 깔린 인스턴스 선택 -> 보안탭 -> 인바운드 규칙 (현재 22번 포트만 열려있음)
 - 보안그룹 -> 인바운드 규칙 편집 
   - 유형 : MYSQL/Aurora (포트번호 3306 확인)
   - 소스 : 0.0.0.0/0
   - 저장
 - 이제 workbench에서 접속하면 접속 성공


인바운드 규칙 : 외부에서 인스턴스로 들어오는 트래픽 관련
아웃바운드 규칙 : 인스턴스에서 외부로 나가는 트래픽 관련

=======================================
22.08.01 월 - 62일차

- 이메일 / 비밀번호 찾기
- 답변게시판

이메일 찾기*
 - 이름, 전화번호 입력
 - member 테이블에서 이메일 조회
 - 출력

 - get : 입력폼
 - post : 조회 (ajax로 조회)

비밀번호 찾기
 - 이메일, 이름, 전화번호
 - member 테이블에서 조회 (입력정보 확인을 위함)
 - 확인 후 임시비밀번호 생성 -> 메일로 발송

 - get : 입력폼
 - post : 조회, 메일발송

메일 관련 라이브러리 다운
mvnrepository.com 접속
"mail" 검색 -> JavaMail API (compat) -> 1.4.7버전
SMTP 25번포트 : 메일을 보낼때 사용하는 포트
POP3 110번 포트 : 서버에 도착한 메일을 클라이언트에 사용하는 포트 (가져오면 서버에 메일을 삭제)
IMAP 143번 포트 : POP3와 용도는 같음 (서버와 동기화)

메일 읽음 여부 확인하는 방법
 - 메일에 url을 추가해서 보낸다. (img태그 크기 0)
 - 이미지태그는 메일이 열릴때 자동으로 호출됨
 - url에 메일의 식별자가 되는 내용 포함 -> DB 업데이트

1. 메일 서버 정소 설정 (Properties 객체 설정)
 - 포트번호, SMTP 서버, ssl 사용여부, ssl 프로토콜 등
2. 인증을 위한 Session 객체 생성 
 - 매개변수 : Properties 객체, Authenticator 객체
 - Authenticator객체 : 발신자 계정 아이디 및 비밀번호 필요
3. MimeMessage 객체 생성
 - 발신자, 수신자, 제목, 내용 설정
4. 메일 발송 (Transport 클래스의 send 메서드 사용)

#############################
프로젝트
좋아요 기능
SQL 
 - (완료)insertRec (게시글/댓글 통합 매서드 : 게시글의 reply_no값은 0) 
 - (완료)cancleRec (게시글/댓글 통합 매서드 : 게시글의 reply_no값은 0) 
 - (완료)getRecCnt (게시글/댓글이 좋아요를 받은 개수)
 - (완료)getMemberRecTotalCnt (통계용 - 회원이 좋아요를 누른 개수)
 - (완료)getMemberRecList (통계용 - 멤버별 댓글리스트)

=======================================
22.08.02 화 - 63일차

답변게시판
컬럼 추가 (3개)*
- 그룹번호
- 순서
- 들여쓰기 정도

목록*
- 정렬기준 변화(→그룹번호 DESC, 순서 ASC)

등록*
1)
- max(그룹번호) +1 
- insert(그룹번호)
2) 
- insert, lsat_insert_id()
<insert>
    <selectKey keyProperty="no" resultType="int" order="AFTER">
        SELECT LAST_INSERT_ID()
    </selectKey>
</insert>
- update(그룹번호)

답변*
- 부모글의 그룹번호, 순서, 들여쓰기정도 가지고 옴
- (update)부모글의 그룹번호와 같고, 부모글의 순서보다 큰 순서에 +1 
- (insert)부모글의 그룹번호, 부모글의 순서에+1, 부모글의 들여쓰기정도에 +1


=======================================
22.08.03 수 - 64일차

사진첨부기능있는 웹에디터*
관리자페이지 소스*
개인포폴용UI*



스마트에디터2
https://naver.github.io/smarteditor2/
부트스트랩 summernote.org
https://summernote.org/

업로드 기능은 따로 구현해야함

업로드 기능이 구현된 스마트에디터 클래스룸에서 다운받기
 - 함께 올라온 자바스크립트 함수 : webapp/js/function.js 파일을 만들어서 함수 추가하기.

압축 풀어서 webapp 하위에 폴더 추가
- cos 라이브러리 디펜던시 추가
- SmartEditor2Skin.html -> 에디터 파일
- editor_upload.jsp 내 수정사항 : myFileRenamePolicy() -> defaultFileRenamePolicy()

에디터를 사용할 JSP에 추가(writer.jsp)
 - function.js, 제이쿼리, HuskyEZCreator.js
 - HuskyEZCreator.js내 함수를 function.js에서 사용하고 있기때문에 보다 위쪽에 있어야함 (해당 js파일은 네이버에서 제공하는 jindo 프레임워크에 속한(?/이용하는?) 파일임)

스프링이 아닌 JSP로 작성된 이유 -> 스프링에 종속되지 않도록 하기 위함


관리자 테이블은 따로 만들어야함 (개인정보보호법에 의함)
 - 인터셉터도 별개로
 - 로그인 내역 (접속 일시, 아이피,...등)

개인 포트폴리오 참조사이트
http://eservice.taiyoungship.co.kr/
클래스룸 -> 개인포폴용UI
프로젝트 이클립스에 import한 후 프로젝트 properties -> target runtimes을 바꿔줘야 오류없이 실행됨

property 클래스의 필드변수를 바꿔도 static 변수이기때문에 잘 반영되지 않음 (서버를 재시작해도 안될 경우 "clean Tomcat Work Directory"를 실행해야함)

=======================================
22.08.04 목 - 65일차

버전관리, 형상관리, 협업툴...
 - 파일 버전 관리
 - 협업

CVS (Current Version System)
SVN (SubVersion) - 아직 많은 프로젝트가 SVN을 쓰고있을 확률↑
Git 
 - 로컬저장소와 서버저장소가 분리되어있음


Git 설치
git-scm.com 에서 깃 다운로드 (64비트 windows)
- 기본 'next'
- Use Git from Git Bash only 선택 (Adjusting your PATH environment 창)

========================================================
git 명령어 (1)
사용자 설정
$ git config --global user.name "이름"
$ git config --global user.email "이메일"

gittest 폴더 생성 후 이동
$ mkdir gittest
$ cd gittest

저장소 설정 
$ git init
저장소에 파일 추가
$ git add 파일명
커밋
$ git commit 
- 편집모드(i)를 통해 커밋 메시지 작성 가능 -> ":wq" 저장후 종료
상태 출력
$ git status

브랜치 확인
$ git branch
브랜치 추가
$ git branch 브랜치명
브랜치 변경
$ git checkout 브랜치명
현재 브랜치에 해당 브랜치를 병합
$ git merge 브랜치명

.gitignore 파일 (버전관리가 필요없는 대상 제외)
gitignore.io 접속 -> "Java" 적용 후 텍스트 복사해서 .gitignore에 붙여넣기

충돌(conflict) 발생
- 두브랜치 간에 커밋이 된 상태
- 양쪽 동일한 코드를 다르게 수정한 상태에서 병합을 시도하면 충돌이 발생(같은 자리)
- 충돌이 발생하면 직접 수정 후 "다시 커밋"
    <<<<<<<<
    내코드
    ========
    다른 코드
    >>>>>>>>>

커밋된 내역 상세조회
$ git log -q 
커밋내용에 대한 통계정보 확인 가능
$ git log -stat
커밋 내용 수정파일의 이름만 보기
$ git log --name-only     
=======================================

=======================================
22.08.05 금 - 66일차

CI : 지속적인 통합(Continuous Integration), 빌드/테스트 자동화
CD : 지속적인 배포(Continuous Deployment), 배포 자동화

Jennifer : Java 모니터링 툴
Jenkins : 지속적인 통합 서비스를 제공하는 툴, 빌드자동과
Jira : 이슈 추적, 프로젝트 관리 프로그램

==============================
git 명령어 (2)

git clone : 원격저장소의 모든 내용을 로컬저장소로 복사
git remote : 로컬저장소를 원격저장소와 연결
git push : 로컬저장소의 변경사항을 원격저장소로 보냄
git fetch : 로컬저장소와 원격저장소의 변경사항이 다른 경우 비교해서 git merge로 해결
git pull : push와 반대, 원격저장소의 내용을 로컬저장소로 가져와서 자동으로 병합해줌

깃허브 repository 연결
$ git remote add 저장소이름 저장소URL

단축이름과 URL을 보여줌
$ git remote -v

로컬저장소의 작업내역을 원격 저장소로 올림(push)
$ git push 원격저장소명 로컬브랜치명(--all : 전체 브랜치)

==============================
github
- clone : 로컬저장소로 복사하는 것
- fork : 다른사람의 repository를 내 repository로 가져옴 (다른사람의 repository와 연결된 상태, 어떤 변화가 생기면 fetch나 rebase과정을 거쳐서 그대로 반영이 가능함)



이클립스에서 git 사용하기
프로젝트 우클릭 -> 'Team' -> 'Share Project' -> 경로 설정
Open Perspective -> Git -> 




(회원테이블)칼럼 추가 필요
- 회원종류
- 키

=======================================
22.08.08 월 - 67일차

이클립스에서 깃허브 push에 문제
github -> 계정 -> Settings -> Developer settings -> Personal access tokens -> generate new token -> 설정 모두 체크 -> 발행된 토큰을 복사해서 push 할때 password에 입력
* 토큰은 발생시에 

window -> preferences -> 'secure' 검색 -> Secure Storage -> contents 탭


깃허브에서 가져오기
git clone 후 프로젝트폴더 우클릭 -> import projects

=======================================
22.08.09 화 - 68일차

AWS에 프로젝트 배포
 - JDK 설치
    - openJDK 설치
 - 톰캣 설치
 - DB 백업
 - aws DB에 복원
 - aws 보안그룹 설정
 - 웹어플리케이션 배포(war)


========================================
AWS 인스턴스 설정을 복사해두는 법
 - 작업 -> 이미지 및 템플릿 -> 이미지 생성 
=========================================
준비
- AWS 콘솔 로그인
- 인스턴스 시작(Mysql 설치된) 시작
- SSH(xshell) 접속

1. 오픈JDK 설치하기
$ sudo apt-get install openjdk-11-jdk
 - 오픈JDK 11버전 설치(xshell에서 진행)
 - sudo : 관리자 권한으로 실행
 - apt-get : 리눅스에서 패키지를 설치하거나 삭제하는데 사용
 - (진행중에 커널 업데이트를 진행했었음)

$ java -version
 - 설치된 자바 버전 확인

2. 톰캣 설치하기
2-(ㄱ) 톰캣 다운
- https://tomcat.apache.org/ 접속
- 톰캣 9.0 -> Binary Distributions -> Core -> tar.gz파일 다운로드
2-(ㄴ) FTP 접속
 - 클라이언트 프로그램(Filezilla, 무료) 다운로드
 - https://filezilla-project.org/ 접속 -> client 다운로드 -> 설치 (설치 중에 브라우저 함께 설치하는 것 거절)
 - filezilla 실행
 - 사이트 관리자 -> 새 사이트
    - 프로토콜 : SFTP (SSH를 이용한 파일 전송)
    - 호스트 : aws 인스턴스 IP
    - 포트 : 공백 (FTP 프로토콜일경우 21번 포트)
    - 로그온 유형 : 키 파일
    - 사용자 : ubuntu
    - 키 파일 : aws 인스턴스 생성시 받았던 키 페어 파일(.pem)   - 다운받은 톰캣 파일을 "/home/ubuntu/" 디렉토리로 업로드

2-(ㄷ) 톰캣 설치 (2)
$ tar xvzf apache-tomcat-9.0.65.tar.gz 
- 톰캣 파일 압축 풀기
- 압축 푼 폴더 내 bin 디렉토리로 이동
    - ./startup.sh -> 서버 실행
    - ./shutdown.sh -> 서버 종료
$ ps -ef 
$ ps -ef | grep java
 - ps : 현재 실행중인 프로세스 목록을 보여줌 
 - "-e" (속성) : 모든 프로세스의 정보
 - "-f" (속성) : 프로세스의 자세한 정보
 - '| grep java' : 'java'가 들어있는 pid를 조회

3. 보안그룹 설정 (8080포트 인바운드 규칙 추가)
aws -> 대상 인스턴스 선택 -> 보안탭 -> 보안그룹 선택
인바운드 규칙 편집 (8080 포트를 열어줘야함)
 - 규칙추가 
    - 유형 : 사용자 지정 TCP
    - 포트범위 : 8080 
    - 소스 : 사용자지정 0.0.0.0/0
 - 규칙 추가후 publicIP:8080로 접속해서 접속이 잘 되는지 확인

4. DB 백업 (CLI 환경에서 백업하기)
명령프롬프트 열기
> mysqldump
 - mysql 백업프로그램 (경로 C:\Program Files\MySQL\MySQL Server 8.0\bin)
 - 환경변수 설정해서 실행하거나, 경로를 입력해서 실행

> mysql -h15.164.103.67 -uroot -p
 - -h : 해당 서버로 접속(15.164.103.67로 접속, 생략하면 local)
 - -u : 접속 계정 (root로 접속)
 - -p : 비밀번호 
 
 - quit 명령어를 사용하면 mysql 종료

> mysqldump -uroot -p project > project.dmp
 - 백업파일 생성 명령어 (mysqldump -u계정명 -p DB명 > 파일명)
 - (화살표 방향에 유의!)
 - project > project.dmp : project 데이터베이스를 파일명 "project.dmp"로 백업
 - 실행한 위치(명령프롬프트)에 백업파일이 생성됨

 - filezilla를 이용하여 백업파일을 리모트사이트(aws-ubuntu)에 업로드
========================================
MySQL Batch Insert 
 - mysql 다량의 데이터 넣기
 - DB에 insert해야하는 튜플이 많을 때 사용함, 한번에 수천개의 쿼리를 묶어서 넣어준다
 - 100,000건 이상의 데이터를 넣을때 사용하는것이 좋음
=========================================

5. aws DB에 복원 (xshell에서 진행)

$ mysql -uroot -p
- 접속 명령어

mysql> create database db명;
- db 생성
- mysql> create database project; 를 통해 생성된 DB 확인
- mysql> \q (-> mysql 종료 (quit도 사용 가능))

$ mysql -uroot -p project < project.dmp
 - DB 복원 명령어 (화살표 방향에 유의!)
 - $ mysql -u계정명 -p DB명 < 백업파일명

6. project 웹어플리케이션 배포(war)

db와 톰캣이 같은 인스턴스에 올라간 경우 프로젝트내 DB 설정을 localhost에서 변경할 필요가 없다. (단, 접속계정 정보는 바꿔야할 수 있음)


(이클립스)대상 프로젝트 우클릭 -> Run As -> Maven Install
 - target 디렉토리에 가면 war파일이 생성되어있음
 - 생성된 war 파일을 aws의 톰캣/webapps 디렉토리에 업로드 -> 자동으로 디렉토리가 생성되면서 배포됨
 - (생성된 디렉토리명을 ROOT로 바꾸면 컨텍스트패스 없이 접속됨)

-------------------------------------------------------
서버 시간 설정 (방법1)
$ tzselect
 -> 4) asia -> 24 (south)Korea -> Yes
 - 타임존 셀렉트 명령어

$ sudo vi /etc/profile

   TZ='Asia/Seoul';
   export TZ
 - ↑↑↑ 파일 맨 아래에 추가 (공백 없이!)

$ source /etc/profile
 - 컴퓨터 재시작 없이 설정 파일 적용

-----------------------------------------------------
서버 시간 설정 (방법 2)
 - crontab 설정해서 매일 0시에 시간을 불러오기 (배우지는 않음)
 - crontab : 리눅스 작업스케쥴러 (예약된 작업을 주기적으로 실행시킬 수 있음)

-----------------------------------------------------
DB 시간 설정(MySQL)
$ sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf 
default-time-zone="+09:00"  (파일 하단에 추가)

$ sudo systemctl restart mysql.service

-----------------------------------------------------

=======================================
22.08.10 수 - 69일차

프로젝트 본격 시작!

aws 컴퓨터가 느려짐을 느낄때! 
- 인스턴스 중지 후 시작 (-> IP주소가 바뀜)

탄력적 IP
 - EC2 -> 탄력적IP 주소 -> 탄력적 IP 주소 할당 -> "할당"
 - 탄력적 IP 주소 -> 할당된 IPv4주소 선택 -> 탄력적 IP 주소 할당 -> 탄력적 IP 주소 연결 -> 인스턴스 : 사용하고 있는 인스턴스 선택 -> 연결
- 할당받아두고 연결시켜두지 않으면 과금됨!!


##########################################
##########################################
SpringBoot (스프링부트)
 - 스프링프레임워크(레거시)와 관련 라이브러리를 조합해서 웹어플리케이션을 빠르게 구축할 수 있게 해주는 프레임워크
 - 최소한의 설정으로 빠르게 구현하는 것이 목표
 - 레거시는 자바어플리케이션 개발 목적, 스프링부트는 자바웹어플리케이션(SpringMVC) 개발 목적

이클립스보다 STS, IntelliJ가 스트링부트를 사용하기 편함

https://spring.io
 - STS(Spring Tool Suite) 다운로드 (다운 당시 : STS4 4.15.2 - 윈도우버전)
 - 다운받은 jar 파일 압축 풀기 -> 안에 있는 contents.zip 압축 풀기 -> 생성된 "sts-4.15.2.RELEASE" 폴더를 원하는 경로로 이동 -> SpringToolSuite4.exe 로 실행 가능
 - workspace 지정 : workspace는 다른 프로그램과 겹치지 않는 경로에 생성!
 - File -> new -> new Spring Starter Project
    - type : Gradle Project
    - Packaging : Jar
    - Java Version : 11
    - Package : (기본 패키지이름 설정)
    - next 선택
 - 원하는 Dependencies 설정
    - Developer Tools : Spring Boot DevTools, lombok
    - SQL : MyBatis Framework, MySQL Driver
    - Template Engines : Thymeleaf
    - Web : Spring Web
    - next 선택 -> finish!

dependency에 추가적으로 알면 좋을 것들
 - Spring Batch
 - Google Cloud Platform (클라우스서비스 3대장 : AWS, MS Azure, GCP)
 - Spring Security
 - JPA


파일 설명
- build.gradle : pom.xml 역할
    - dependencies {} : 필요한 라이브러리 추가

서버 실행하면 에러남 
 - 에러메시지 : DataSource가 설정되어있어야함
 - src/main/resources -> application.properties 파일에 내용 입력   
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://localhost:8080/project
spring.datasource.username=testuser
spring.datasource.password=test1234
(기본으로 되어있는 설정이 어떻게 되어있는지 확인할 수 없음, 위 파일에서 추가하거나 기본설정에 override는 가능함)


초기 설정한 패키지의 하위경로는 모두 스캔을 하고 있음
템플릿엔진을 타임리프로 설정했으므로 html 위치는 "resources/templates"에서 시작함
html, jsp.. 파일 생성이 안됨 (file로 생성은 가능하나 작업하는데 불편하기때문에 marketplace에서 받아야함)
 - "web Developer" 검색 -> "Eclipse Enterprise Java and Web Developer Tools" 설치 (Enterprise 버전으로 설치해야 jsp 편집이 가능)

thymeleaf는 엔진이라서 수정 후에 서버 재시작을 해줘야 한다.
정적파일 절대경로는 "static"에서 부터 시작한다. (css, js, image...)
 - scr="/js/script.js" 에 있는 파일은 "static/js/script.js"에 위치함
thymeleaf 사용법
 - 상단 HTML 태그에 설정 추가 
    -> <html xmlns:th="http://www.thymeleaf.org">
 - HTML 태그에다가 직접 사용함
    -> 예1 : <tr th:each="data, index:${list}"></tr>
    -> 예2 : <td th:text="${data.no}">1</td>

---------------------------------------------
(SpringBoot)뷰를 JSP로 사용해보기

# jasper dependency 추가
 - mvnrepository에서 "tomcat" 검색 -> "Tomcat Embed Jasper" 선택 -> 설치된 톰캣과 동일한 버전으로 다운
# jstl dependency 추가
# thymeleaf dependency 제거 또는 주석처리 (충돌되기때문에 없어야함)
# view 설정(prefix, suffix)
 - application.properties 파일에 설정 추가
spring.mvc.view.prefix=/WEB-INF/view/
spring.mvc.view.suffix=.jsp
 - src/main 경로에 "webapp/WEB-INF/view" 폴더를 추가한뒤 jsp 파일 작업

템플릿엔진은 트랜드에 민감하나 JSP가 기본적은 개념으로 적용되어있음

jar 파일로 빌드하기
프로젝트 우클릭 -> run as -> Run Configurations -> Gradle Tasks  - Gradle Tasks : "bootJar" 입력 (실행가능한 jar를 빌드하는 태스크)
 - Working Directory : Workspace 선택 후 입력
 - Apply -> Run
 - 해당 프로젝트 내 build/libs에 jar 파일 생성된 것 확인 가능

서버에 jar 파일을 옮긴 후 "java -jar" 명령어로 실행하면 실행된다.

jsp는 스프링부트에서 지원하지 않아서 jar로 빌드할 경우 임의로 생성한 "/WEB-INF/.../" 경로가 들어가지 않기때문에 jar를 이용해서 jsp를 생성한 프로젝트를 배포하면 jsp 실행이 되지 않는다 -> war로 빌드해서 배포할 경우에는 문제가 되지 않음


=======================================
22.08.11 목 - 70일차
프로젝트 진행 

=======================================
22.08.12 금 - 71일차
프로젝트 진행 

=======================================
22.08.16 화 - 72일차

프로젝트 진행 : 오픈채팅목록 구현

=======================================
22.08.17 수 - 73일차

프로젝트 진행 : 오픈채팅방 구현

=======================================
22.08.18 목 - 74일차

프로젝트 진행 : 오픈채팅방 구현 완료 / 좋아요 기능 구현


조건 1 : 멤버리스트를 가져온다
조건 2 : 멤버별 취미리스트를 가져와야한다. (멤버-취미 테이블은 1:N의 관계)

한번의 SELECT문으로 처리가 불가능하다.
-> 멤버리스트를 가져온 후 for문을 돌면서 해당 멤버의 취미리스트를 ArrayList로 가져오는 select문을 실행해서 담는다.



=======================================
22.08.19 금 - 75일차

이전글, 다음글 처리 (no로 하면 검색시에 제대로 적용되지 않음)
- sql에서 row_number을 통해 번호 부여
 
현재글의 rownum 가져오기
- rownum-1 가져오기 (이전글)
- rownum+1 가져오기 (다음글)

=======================================
22.08.22 월 - 76일차


=======================================
22.08.23 화 - 77일차

예약 과정
- 가능여부 체크 -> 부모테이블 insert -> (select key를 이용해서) 자식테이블 insert

여러명이 동시에 예약을 할때는 어떻게 할 것인지?

Java : 메서드 앞에 synchronized 키워드를 적어준다
 synchronized : 멀티스레드에서도 동기화처리를 해준다

방법들
 - synchronized 키워드 (java)
 - 트랜잭션 
 (트랜잭션 설정하는 순간 db에 lock이 걸려 느려질 수 있기 때문에 꼭 필요한 경우에만 설정한다)
 (synchronized 와 트랜잭션을 동시에 사용하면 문제가 생김)

트랜잭션 사용하기 (project에서 실습 진행)
(1) spring-tx 디펜던시 추가
(2) 설정파일(servelet-context.xml)에서 
   - tx 설정 추가 (namespace에서 추가)
   - 관련 빈 추가 및 설정
<tx:annotation-driven transaction-manager="transactionManager"/>
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <!-- dataSource 필드에 Hicari 관련 설정에서 만든 dataSource 객체를 넣어줌 -->
    <property name="dataSource" ref="dataSource"></property>
</bean>

   - 트랜잭션을 적용해야하는 메서드에 '@Transactional' 어노테이션 적용
     - rollbackFor 속성 적용
       (rollbackFor = Exception.class)
       (예외 클래스 지정, 지정 안하면 기본값이 runtime exception이기 때문에 따로 지정해주는 것이 좋음)   
     - propagation 속성 적용 (전파)
       (propagation = Propagation.REQUIRED)
       - REQUIRED : 부모트랜잭션이 있으면 포함, 없으면 새로 생성 (일반적으로 사용되는 설정)
       - REQUIRES_NEW : 무조건 새로 생성
       - MANDATORY : 부모트랜잭션이 있으면 포함, (없으면 에러)
       - NESTED : 부모트랜잭션에 중첩되서 생성 (롤백시 해당 트랜잭션 시작 시점으로 감, 부모트랜잭션과 별개)
       - NEVER : 트랜잭션 미생성
     - isolation 속성 (격리) : 격리수준 설정
       - READ_UNCOMMITED : 트랜잭션 중 커밋되지 않은 데이터도 read 가능
       - READ_COMMITED : 트랜잭션이 커밋된 데이터만 read 가능
       - REPEATABLE_READ : 트랜잭션이 커밋될때까지 모든 데이터가 LOCK이 됨 (SELECT 불가)
       - SERIALIZABLE : 완벽한 격리, 성능이 저하됨, 트랜잭션이 커밋될때까지 모든 데이터가 LOCK이 됨 (SELECT 불가)

=======================================
22.08.24 수 - 78일차

=======================================
22.08.25 목 - 79일차

일별 거래건수 구하기
합계 구하기

조인에 사용할 달력 테이블 미리 만들어두고 SQL을 조인해서 사용하는게 편하다
 - 테이블 만들때 PK를 만들 필요가 없음
 - DataType : CHAR(10)     (정확한 시간이 필요없고, 날짜만 필요한 경우 date, timestamp 같은 걸 사용할 필요 없음)
 - 날짜 관련한 util 클래스 및 매서드 만들어서 테이블에 데이터를 넣도록 하면 편함

('calendar' java 프로젝트에서 실습 진행)

=======================================
22.08.26 금 - 80일차

=======================================
22.08.29 월 - 81일차

=======================================
22.08.30 화 - 82일차


=======================================
22.08.31 수 - 83일차


=======================================
22.09.01 목 - 84일차

파이썬 수업 시작

커리큘럼
파이썬(파이참 : 기본문법) -> Jupyter(데이터분석 : 이론, 전처리, 수집, 저장, 수학{선형대수, 행렬, 확률, 통계, 미분, 가설검정}, 실습{가설검정, 회귀분석, 요약분석) -> 머신러닝 -> 딥러닝

기본문법 교재 : Let's 실전 예제로 배우는 파이썬프로그래밍
데이터분석 교재 : 기타 강의자료
딥러닝 이후 수업 교재 : 파이썬 데이터분석 실무테크닉 100


파이썬의 특징
 - 하이브리드 언어 : 대화형 인터프리터 언어
 - 동적인 자료형 결정 : 타입을 선언하지 않음
 - 플랫폼 독립적 언어 : 대부분의 운영체제(윈도우, 리눅스, 유닉스)에서 동작
 - 간결하고 쉬운 문법
 - 풍부한 라이브러리와 오픈소스
 - 메모리 자동 관리


파이썬 설치하기
최신버전 설치파일 다운로드 (www.python.org)
설치파일 실행
- PATH 설치 체크 안한채로 설치 
  (파이썬이 여러개 설치되면 경로가 꼬일수 있음, 이 부분은 선택사항임)
- Customize installation -> next -> 설치경로 설정 (현재 E:\kdigital_a\python\python310)
- Disable path length limit 클릭 후 close

파이참 설치하기
'pyCharm' 검색 후 공식사이트 접속 -> community 버전 다운
(현재 설치경로 : E:\kdigital_a\python\pycharm\)
설정들 체크하지 않고 next->intsall

new project -> 경로 (E:\kdigital_a\python\workspace\project)
python 패키지 만들고 python 파일 생성


##############################################################
파이참 단축키

esc : 에디터창으로 이동
F12 : 실행창으로 커서 이동
shift + esc : 실행창 최소화

1. 실행(Run)
   현재소스 실행     : Ctrl + Shift + F10
   최근소스 재실행  : Shift + F10
   소스선택 실행     : Alt + Shift + F10
2. 편집
   수정취소/되돌리기(Undo)   : Ctrl + z
   수정취소 재실행(Redo)      : Ctrl + Shift + z
   현재라인 위/아래 라인으로이동      : Alt + ↑ 또는 Alt + ↓
   최근 실행파일 열기      : Ctrl + e
   파일 열기                  : Ctrl + Shift + n, Ctrl + n
   파일간 이동               : Alt + ← 또는 Alt + →
   선택내역 복제    : Ctrl + d (Shift로 선택후 실행시 전체, 미선택시 1줄 복제)
   블럭단위 선택    : Ctrl + w
   삭제        : Crtl + y
   복사        : Ctrl + c
   붙여넣기   : Ctrl + v
   ( )소괄호 밖 탈출     : Ctrl + Shift + Enter
   주석처리(#)            : Ctrl + /(영역선택후)
   글자 이동(Tab간격)  : 순방향: Tab, 역방향 : Shift + Tab(영역선택후)   
   전체화면 이동         : Ctrl + 방향키
3. 기타
   소스(탭)간 이동        : Alt + 좌/우방향키 Ctrl + Tab (2개탭사이만 이동)
   폴더, 새파일 생성     : Alt + Insert
   폴더, 파일이름 변경  : Shift + F6
   파일 목록열기         : Ctrl + e
   편집창 닫기            : Ctrl + F4
   파이참 종료            :  Alt + F4
4. Debugging
   Break point
   한줄씩 실행     : F8
   함수로 이동     : F7
   run to cursor   : Run
###################################################################

# 자료형
# 정수(int)
# 실수(float)
# 문자열(string)
# 논리(bool)
# 파이썬에서는 기본자료형이라는 말을 사용하지 않음 -> 모든 것이 객체임

print() 함수 설명
# dynamic type : 동적 자료형
print(1,2,3,4,5)   # 매개변수 여러개 출력 (기본값이 공백)
print(1,2,3,4,5, sep='-')   # 구분값 지정
# print함수는 end 속성 기본값이 출력 후 줄바꿈을 함 (end='\n')
print(1, end='')

# None Type
c = None    # 아직 값이 없지만 변수를 선언하고 싶을때 None를 사용
print(type(c))

# 같은 변수를 다시 선언해도 에러가 나지 않는다 -> 디버깅하기 어려운 이유 중 하나
# 변수 선언 방법
a,b = 1,2
# 두 변수의 값을 교체
a = 1
b = 2
a, b = b, a     # 두 변수의 값을 간단하게 교체할 수 있음   

# 자료형 변환 -> 함수 이름이 자료형 이름임
a = '3.14'
print(type(a))
b = float(a)
print(type(b))

a = False    # boolean은 첫 글자가 대문자
b = int(a)
print(b)

# 값이 있으면 True, 없으면 False (0도 False)
print(bool(1))  -> True
print(bool(''))  -> False
print(bool('a'))  -> True
print(bool(0))  -> False
print(bool(31))  -> True

print(10//3)    # // : 몫
print(10%3)     # % : 나머지
print(2**8)     # ** : 제곱

논리연산자
 and, or, not   (&&, ||, ! 사용X)

# 이진수 연산에 &가 사용됨
a = 2
b = 3
print(a & b)
#   10
# & 11
# True, False (10) -> 2가 됨

# bin() 이진수로 표현하는 함수 
print(bin(a))   # 0b10 (a가 2)
print(bin(b))   # 0b11 (b가 3)
print(bin(a&b)) # 0b10

# input() : 값 입력 (문자열로 리턴함)
number = input('숫자를 입력하세요')

# 연결해서 사용할때는 변환해줘야함
number1 = 10
print('number1에 들어있는 숫자는 ' + str(number1) + '입니다.')

# help() : 함수의 관련 정보를 보여주는 함수
help(print)

# 포맷팅 3가지 방법 ('{}'.format(변수명), '%s'%(변수명), f'{변수명}')
name = '홍길동'
age = 30
tel = '010'
'{}'.format(변수명)
 - introduce = '이름은 {}이고, 나이는 {}살이며, 전화번호는 {}입니다'.format(name, age, tel)
'%s'%(변수명)
 - introduce = '이름은 %s이고, 나이는 %d살이며, 전화번호는 %s입니다'%(name, age, tel)
f'{변수명}'
 - introduce = f'이름은 {name}이고, 나이는 {age}살이며, 전화번호는 {tel}입니다'

다른 형태
'이름:{name}, 나이: {age}, 전화번호 : {tel}'.format(name='010', age='홍', tel='50')

# 실수 포맷팅 (전체자리수.소수점자리수
print('원주율:%.3f' % 3.141592)

# 문자열
# '', "" 둘 다 사용 가능
# ''', """ 는 여러줄 표현이 가능함
introduce = """안녕하세요
나는 홍길동입니다
반갑습니다"""

# 문자열 인덱싱
# 맨끝 인덱스 -1
string = '안녕하세요'
print(string[4], string[-1])

# 문자열 * 연산
print('-' * 10)

# 문자열 슬라이싱
# 문자열[시작인덱스 : 끝인덱스 전 : 증감값]
string = '안녕하세요'
print(string[0:2])  # 안녕
print(string[:2])   # 안녕, 0은 생략이 가능함
print(string[2:])   # 하세요
print(string[::2])  # 안하요

# string은 immutable! : 변경되지 않는 자료형!
# string[0] = '간' # immutable하기 때문에 변경할 수 없음
sitrng = '간' + string[1:]
print(string)

# 문자열 처리 함수
# 형식 : 문자열객체.함수([인수])

oneLine = "this is one line string"
# (1) 특정 글자 수 반환 - count()
print('t 글자 수 : ', oneLine.count('t'))

# (2) 접두어 문자 비교 판단 - startswith()
print(oneLine.startswith('this'))
print(oneLine.startswith('that'))

# (3) 문자열 교체 - replace()
print(oneLine.replace("this", "that"))  # oneLine이라는 변수 자체가 바뀌는 것이 아니다
print(oneLine)

# (4) 문자열 분리(split) : 문단 -> 문장 - split()
multiLine = """this is
multi line
string"""
sent = multiLine.split('\n')    # 리스트로 리턴
print('문장 : ', sent)

# (5) 문자열 분리(split) 2: 문장 -> 단어
words = oneLine.split(' ') # sep = ' ' : default
print('단어 : ' , words)

# (6) 문자열 결합(join) : 단어 -> 문장 - join()
sent2 = ','.join(words)     # '구분자'.join(string)
print(sent2) # this, is, one, line, string

# 길이
len()

# 위치(포함여부) - index(), find()
# print(oneLine.index('oxne'))  # 존재하지 않으면 에러
print(oneLine.find('oxne'))     # 존재하지 않으면 -1 리턴

# 에러가 안난다고 좋은 것은 아님, 오류 확인하기가 더 어려울 수 있음
if oneLine.count('oxne') > 0:
    print(oneLine.index('oxne'))

=======================================
22.09.02 금 - 85일차

3장 제어문 - 원하는대로 작업순서 바꾸기 

3.2 조건문
if, elif, else

# in 연산자
# if문, else문 사이에 아무것도 없으면 에러가 남 -> pass 예약어 사용
if 'go' in lan:
    pass    # 아무 실행이 안됨
else:
    print('배우자')

# if문의 조건이 bool이 아닌 경우
# 값이 있으면 True, 없으면 False
# None, 0, 0.0, '', []: 빈 리스트, {}: 빈 딕셔너리, (): 빈 튜플 -> False
# 각 타입의 기본값은 False

파이썬에서는 삼항연산자는 없다고 여겨진다
조건부표현식이라는 말을 사용한다
 - 형식 : 변수 = 참 if 조건문 else 거짓

3.3 반복문 - while, for
3.3.1 while
형식
while 조건식 : 
    실행문

3.3.2 random 모듈
choice(seq)
choices(population, k)
randint(a,b)
random(...)
sample(population, k)
seed()
uniform(a,b)
normalvariate(mu, sigma) : 정규분포를 따르는 난수를 반환 (mu : 평균, sigma : 표준편차)

3.3.4 for
형식 : 
for 변수 in 열거형 객체 : 
    실행문

별도의 조건식 없이 열거형 객체를 사용한다

# 인덱스가 필요한 경우 : enumerate()
for idx, val in enumerate(lstset):    # lstset = [1, 2, 3, 4, 5]
    print(idx, val)     # index와 값을 같이 출력해줌

# range() 객체 활용
# range(start)
# range(start, stop)
# range(start, stop, step)

# List Comprehension (내포된 for문)
# - 리스트를 간편하게 만들어주는 방법
# - 일반 for문보다 속도가 빠름
lst = [0, 1, 2, 3]
result = [v**2 for v in lst]


4장 자료구조 - 여러 모양의 자료 만들기

4.2.2 리스트(list)
파이썬에는 배열이 없음
list는 가변길이 순차자료구조임
 - 길이가 변경될 수 있음
 - 순서를 가짐
 - 값의 자료형은 숫자형, 문자형, 논리형 등이 함께 사용될 수 있음
 - index를 이용할 수 있으며, 슬라이싱, 연결, 반복, 요소 검사가 가능하다
 - 값을 추가, 삽입, 수정, 삭제가 가능
 - mutable함 

# append() - 리스트에 원소 추가
# remove() - 리스트에 원소 삭제
# insert() - 리스트에 원소 삽입 (특정 위치 지정 가능)

# sort() - 정렬
# reverse() - 내림차순을 하는것이 아니라 그냥 있는 순서를 바꿈
# index() - 해당 요소의 인덱스값 리턴
# pop() - 마지막 값을 리턴하고 삭제
# count() - 해당 요소의 개수 리턴

해당 리스트에 원하는 요소가 있는지 확인하는 방법 2가지
(1) count() 사용하기
(2) in 연산자 사용하기
 ex) if 타겟 in 리스트: ...


append()와 extend()의 차이
 - append() : 원소 하나를 추가
 - extend() : 하나가 아니라 모든 것을 추가


스칼라 : 0차원
벡터 : 1차원
행렬 : 2차원
텐서 : 3차원 이상

4.2.4 튜플(tuple)
 - 열거형 객체를 생성할 수 있음
 - 값을 추가, 삽입, 수정, 삭제가 불가능
 - 리스트보다 빠르다

list vs tuple
list 
 - 길이가 가변
 - 다양한 자료형을 요소로 저장
 - mutable
 - [] : 대괄호 사용

tuple
 - 변경 불가
 - 메모릭 공간이 리스트에 비해 적음
 - immutable
 - () : 소괄호 사용
 

# 함수가 리턴을 여러개 할 수 있는게 아니라 튜플형태로 리턴하는 것이다.

4.3 비순서 자료구조 - set, dict
4.3.1 셋(set)
 - 중복을 허용하지 않음
 - 순서가 없기때문에 index 사용 불가

union() : 합집합
difference() : 차집합
intersection() : 교집합
add() : 원소 추가
discard() : 원소 삭제

4.3.2 딕트(dict)
 - {'키':'값'} 쌍의 형태
 - 키 : 중복 불가, 값 : 중복 허용
 - index 대신에 키를 이용해서 값을 참조한다.

자료구조 복제
 # id() : 변수가 저장된 주소를 확인할 수 있음
얕은 복사 : 내용, 주소 동일 -> 같은 객체의 주소를 참조하게 됨

깊은 복사 : 내용 동일, 주소는 다름
 - copy.deepcopy()

4.5 알고리즘(algorithm)
https://school.programmers.co.kr/learn/challenges?tab=algorithm_practice_kit
프로그래머스 -> 코딩테스트 고득점 Kit -> 해시, 정렬

=======================================
22.09.05 월 - 86일차

5장 프로그램 블록 만들기

5.1 모듈과 패키지
모듈 : 파일
패키지 : 폴더

5.3 내장함수
builtins 모듈의 경우에는 import 명령어를 사용하지 않아도 된다.

import 하는 2가지 형식
 1) import 모듈명
 2) from 모듈명 import 함수명1, 함수명2...

1)의 방식처럼 import 시킬 경우에는 모듈파일에 있는 함수가 실행

__변수명__ : python 내부에서 사용하는 변수명(사용자 정의 변수와 구분하기 위해서 __가 추가되어있음

# 현재 파일에서 실행하면 실행, import시에는 실행 안됨
if __name__ == '__main__':  
    print(__name__)

# 특정 함수/클래스 import
from moduleTest import plus
print(plus(10, 20))

# alias
import moduleTest as m

# 패키지 포함 import
import packageTest.moduleTest as m2
예전에는 패키지 내부에 '__init__.py' 파일이 있어야 패키지로 인식이 됐으나 최신버전에서는 해당사항이 없다.

5.3.2 builtins 내장함수
abs(x) : x를 절대값으로 반환하는 함수
all(iterable) : 모든 요소가 True일때 True를 반환, 0이 아닌 숫자는 True로 해석
any(iterable) : 하나 이상의 요소가 True일때 True를 반환, 숫자 0은 False로 해석
bin(number) : 10진수를 2진수로 변환, '0b'문자열로 시작함
dir(x) : 객체 x에서 재공하는 변수, 내장함수, 내장클래스의 목록을 반환함
eval(expr) : 문자열 수식을 인수로 받아서 계산 가능한 파이썬 수식으로 변환
hex(number) : 10진수를 16진수로 반환, '0x'문자열로 시작
oct(number) : 10진수를 8진수로 반환, '0o'문자열로 시작
ord(charactor) : character를 아스키 값으로 반환함
pow(x, y) : x에 대한 y제곱을 반환
round(number) : 반올림한 수를 반환
sorted(iterable) : 반복가능한 원소들을 오름차순 또는 내림차순으로 정렬해서 반환
zip(iterable*) : 반복가능한 객체와 객체간의 원소를 묶어서 튜플형태로 반환, 반환된 결과를 확인하려면 list 클래스를 이용하여 리스트 자료구조로 변환해야함

5.4 사용자 정의 함수

형식
def 함수명(매개변수) :
    실행문
    실행문
    return 값

중심극한정리(The Central Limit Theorem)
 - 표본의 크기가 커질수록 근사적으로 표본의 평균이 모평균과 같고, 분산이 모분산과 같은 정규분포를 취한다 
 - 표본의 크기 : 보통 30 이상

5.5 특수함수
5.5.1 가변인수함수
 - 매개변수가 여러개일 수 있는 함수

형식
def 함수명(매개변수, *매개변수, **매개변수):

*, ** 기호설명
- *매개변수 : 튜플형태의 매개변수
- **매개변수 : 딕트(dict) 자료구조의 매개변수

# 매개변수를 직접 지정할 수 있음, 순서와 관계 없음
minus(y=1,x=2)

# 매개변수 기본값 설정
def member(name, age, gender='남자'):
    print(f'제 이름은 {name}이고, 나이는 {age}살이고, 성별은 {gender}입니다.')

# 가변인수
# 파라미터 개수를 알 수 없을 때 사용
# 가변인수는 라이브러리를 만들때 주로 사용하고, 보통 개발할 경우에는 잘 사용하지 않는다.
# *args : 파라미터들을 튜플로 전달
# **kwargs : 파라미터들을 딕셔너리(dict)로 전달

# lambda
# 단일문으로 된 익명함수(일회성)
형식 
lambda 매개변수 : 실행문(반환값)

# callback
# 계산기 함수
def calc(func, a, b):   # func : 함수
    r = func(a, b)      # 함수 실행
    return r


원핫인코딩(One-Hot Encoding)
 - 단어 집합의 크기를 벡터의 차원으로 하고, 표현하고 싶은 단어의 인덱스에 1의 값을 부여하고, 다른 인덱스에는 0을 부여하는 단어의 벡터 표현 방식

1학년 2학년 3학년 4학년
 1     0     0     0
 0     1     0     0
 0     0     1     0
 0     0     0     1

라벨인코딩
 - 범주형 변수를 수치형 변수로 변환
 - 소 -> 0 / 중 -> 1 / 대 -> 2

5.5.3 스코프(Scope)
형식
def 함수명(인수):
    global 전역변수

함수에서 전역변수는 잘 사용하지 않음 -> 함수가 특정 전역변수에 종속되어버리기 때문

5.6 중첩함수
외부함수, 내부함수

파이썬의 특징 중 하나
 - 함수를 리턴할 수 있음

5.6.1 일급함수와 함수 클로저
# 일급함수 : 변수에 외부함수 또는 내부함수를 저장할 수 있음

# Closure(클로저)
# 독립적인 공간
# 내부함수 개념을 이용해서 별도 스코프 존재
# 함수 클로저는 외부함수가 종료되어도 내부함수에서 선언된 변수가 메모리에서 소멸되지 않은 상태로 내부함수를 사용할 수 있음

def test2(name):
    text = f'안녕하세요 저는 {name}입니다.'
    return lambda: text


t1 = test2('홍길동')
t2 = test2('김길동')
print(t1())     # 함수가 종료되어도 '홍길동'이 저장되어있는 상태로 메모리 어디엔가 저장되어있음
print(t2())     # 함수가 종료되어도 '김길동'이 저장되어있는 상태로 메모리 어디엔가 저장되어있음

5.6.3 획득자(getter), 지정자(setter), nonlocal
5.6.4 함수장식자 - decorator
# 함수 내의 코드를 변경하지 않고, 기능을 추가(앞, 뒤)할때 사용

5.7 재귀함수
재귀함수(Recursive function) : 자기 자신을 반복적으로 호출하는 함수


6장 객체지향프로그래밍

함수(Function) : 독립된 기능을 수행하는 코드들의 집합
메서드(Method) : 클래스에 포함되어 있는 함수

6.2 클래스 구성
클래스 : 변수와 함수들을 하나로 묶어놓은 집합체

생성자 : __init__

# Docstring
# 함수의 설명
def test():
    'test 함수에 대한 설명중...'
    return 1


# 멤버변수 
# 변수를 선언하지 않고 생성자에서 정의를 해도 기능상에 문제는 없다.

__del__(self):
- 소멸자(Destructor) : 생성자의 반대역할을 하는 소멸자
- 파이썬 자체에서 메모리 관리를 자동으로 해주기때문에 많이 사용되지는 않는다.

6.2.5 클래스 멤버 (@classmethod)
클래스 이름으로 호출할 수 있는 클래스 변수 및 클래스 메서드 (java의 static과 유사함)
객체를 생성하지 않아도 사용할 수 있다.

# property() 내장함수 : 첫번째 인수에 getter, 두번째 인수에 setter메서드를 넘겨주면
# 일반 필드에 접근하는 것처럼 보이나, getter, setter 메서드를 호출하여 사용할수 있게됨
fname = property(getName, setName)
print(m.fname)
m.fname = '길동'


파이썬으로 계좌프로그램 만들어보기

=======================================
22.09.06 화 - 87일차

6.3.2 상속
형식
class 자식클래스(부모클래스):
    pass

생성자는 상속의 대상이 아니다
# super : 부모클래스
# self : 자기자신

파이썬은 다중상속이 가능하다
# 동일한 메서드인 경우 상속할 때 앞에 써놓은 클래스의 메서드가 우선순위를 가짐

magic method (각 연산을 재정의해서 사용할 수 있음)
비교
    __eq__ -> ==     # 대소문자 구분없이 비교할 수 있게 매서드 재정의가 가능
    __ne__ -> !=
    __lt__ -> <
    __gt__ -> >
    ...
연산
    __add__ -> +
    __sub__ -> -
출력
    __repr__
    __str__	# java에서 toString()와 유사함


7장 정규표현식 (정규식)
배울 중점 내용
 - 메타문자의 의미!
 - 문자열을 치환 및 전처리
 - 문자열의 패턴을 검사

re모듈 내 함수
 - compile(pattern, flags=0)
 - findall(pattern, string, flags=0) : string에서 패턴과 일치하는 모든 문자열을 리스트로 반환
 - sub(pattern, repl, string, count=0, flags=0) : 문자열에서 패턴과 일치하는 문자열을 repl로 대체하여 (new_string, 숫자)형식의 튜플 반환

기본 패턴
- 'a', 'A', 1, ... 등등 문자(숫자)와 정확히 일치
. : 한개의 문자
\w : 한개의 문자 [a-zA-z0-9_]
\d : 숫자

메타문자
- 대괄호 [] 안에 
[abc] : a 또는 b 또는 c
[a-z] : 모든 소문자
[A-Z] : 모든 대문자
[0-9] : 숫자
[a-zA-Z0-9] : 모든 알파벳과 숫자
[^0-9] : 숫자가 아닌 것

escape문자 + 대문자를 사용하면 기존의미에 반대의 뜻이 된다
\s : 공백문자
\S : 공백이 아닌 문자
\d : 숫자
\D : 숫자가 아닌 문자
\W : [^a-zA-Z0-9_]

반복패턴
* : 0번 이상 반복
+ : 1번 이상
? : 0번 또는 1번

그룹핑
()를 사용해서 그룹핑
매칭 결과를 그룹별로 분리 가능
m = re.search(r'(\w+)@(.+)', 'hello hong@gmail.com')
print(m)
print(m.group(0))   # 전체, hong@gmail.com
print(m.group(1))   # 첫번째 묶은 그룹, hong
print(m.group(2))   # 두번째 묶은 그룹, gmail.com

반복횟수
+, *, ? 도 반복이지만 횟수 제한 불가
{4} -> 4번 반복
{3, 4} -> 3~4번 반복
{3,} -> 3번 이상 반복

반복패턴이 greedy(최대한 매칭되는 것을 찾음)
{} 뒤에 ?
greedy하지 않게 찾기 : +, * 뒤에 ?를 붙여서 지정
print(re.search(r'a{3,5}', 'aaaaaaaaaaaaa'))    # match='aaaaa', greedy
print(re.search(r'a{3,5}?', 'aaaaaaaaaaaaa'))   # match='aaa', 최소조건으로 찾음

match()
문자열 시작부터 패턴 비교(시작이 패턴과 일치하지 않으면 None 리턴)
search()에 비해서 잘 사용하지 않음
findall()
- 매칭되는 전체 패턴의 문자열을 리스트로 리턴

자주 사용되는 빈도
findall() > search() > match()

sub()
- 매칭되는 문자열을 치환(replace)
- 치환된 결과를 리턴
- count 매개변수 : 치환횟수 (0은 전체/기본값)
sub(pattern, repl, string[, count=0, flags=0])

compile()
- 정규식 패턴을 미리 컴파일
- 패턴을 컴파일 해두고 반복을 돌리는 속도가 훨씬 빠르다


8장 파일처리와 패키지 설치
텍스트파일, 엑셀파일, csv파일, JSON 처리

8.1 예외처리
형식 
try:
    예외 발생 코드
except 예외처리 클래스 as 변수:
    예외 처리 코드
finally:
    항상 실행시킬 코드

8.2.1 텍스트파일 입출력
io모듈에서 제공하는 open()함수를 이용

형식
open(file, mode, encoding)

mode 
 - r : read
 - w : write (덮어씌움)
 - a : add (추가)
 - b : binary (rb, wb, wa,...)

파일 종류 
 - 텍스트, 바이너리

파일 읽기
readline() : 한줄 읽기
readlines() : 여러 줄 읽기(리스트로 리턴)
read() : 전체를 하나의 문자열로 읽기

JSON
[] : 배열(JSON) -> 리스트(python)
{} : 객체(JSON) -> 딕셔너리(python)

f = open('test.json', 'r', encoding='utf-8')
# print(f.read())
import json
text = json.loads(f.read())

인코딩 : json.dumps(객체)
- 파이썬 객체를 json 문자열로 변환하는 과정

디코딩 : json.loads(json문자열)
- json 문자열을 파이썬의 딕트나 리스트로 변환하는 과정

##############################
외부 라이브러리 설치
pip install 라이브러리명

파이참에서 설치
File > settings > Project:workspace > Python Interpreter > + 버튼 > 검색 > install

외부 json 읽기
 - url 접속해서 읽어오기
 - requests 모듈(패키지, 라이브러리) 설치
###############################

Pickle (python 내장 모듈)
- 객체를 바이너리 형태의 파일로 저장(직렬화)
- 단순 파일 저장보다 속도가 빠름

pickle.dump(객체, 파일) 로 저장하고
pickle.load(파일) 로 로딩


########/과제#########
네이버 API 사용
영화 제목, 링크 출력

네이버 API 샘플소스 사용
clientid, secret 작성
url을 movie로 변경
문서를 참고해서 응답결과 확인
응답 결과를 JSON으로 변환
응답받은 데이터의 제목, 링크 출력
########과제/#########

=======================================
22.09.07 수 - 88일차

앞으로 배울 내용
- numpy, pandas
- 엑셀 다루기
- 데이터 수집(웹 크롤링)
- 데이터 처리(pandas) 분석
- 시각화
- 수학(선형대수, 행렬, 미분), 가설검정
- 데이터 분석 실습
- 머신러닝
- 딥러닝

웹로그 분석 논문 (강사님 논문)
 - 

아나콘다 설치
1. https://www.anaconda.com/products/distribution 접속 후 다운로드
2. 설치파일 실행
 - 경로 설정(E:\kdigital_a\anaconda3\)
 - PATH 추가에도 체크 (default python은 원래 체크되어있음)

spyder : 파이참과 비슷한 프로그램
Anaconda Powershell Prompt : 아나콘다 권한으로 실행되는 Powershell
 - 가상환경별로 파이썬을 실행시킬 수 있음
 - (base)는 기본 파이썬 실행
Jupyter : 웹 기반 파이썬 툴

jupyter 초기 시작경로 : c:/Users/사용자명/
#############/ jupyter 기본경로 변경하기##################
방법 1
annaconda prompt 실행
 - 'jupyter notebook --generate-config' 실행
 - 실행하면 출력되는 경로에 설정파일이 생성됨 -> 생성된 파일 실행
 - "# c.NotebookApp.notebook_dir = ''" 코드 찾아서 주석 풀고 설정할 경로 저장
명령프롬프트에서 jupyter notebook 실행

방법 2
메뉴파일에서 경로 변경하기
jupyter 아이콘 마우스 우클릭 -> 자세히 -> 파일위치 열기 -> 아이콘 우클릭-속성 -> 대상위치 "%USERPROFILE%" -> "시작경로"

방법 3
명령프롬프트에서 명령어 실행
jupyter notebook "시작경로"

#############jupyter 기본경로 변경하기 /##################

서버에서 파이썬 실행하는 법(명령프롬프트로 실행하기)
 - 명령어 : python 파일명.py


주피터 파일 확장자 : .ipynb (파이썬 파일이 아니라서 파이썬에서 실행은 불가능함) 
셀 단위로 파이썬이 실행됨
모드 전환
 - 명령모드 -> 편집모드 : enter
 - 편집모드 -> 명령모드 : esc
마지막 라인에 있는 코드가 출력됨

File -> Download as
 - Python(.py) : 파이썬 확장자 형태로 다운로드가 가능함
 - HTML(.html) : 다른 프로젝트에 추가해서 보여줄때 유용함 (iframe, ...)

Kernel 메뉴 (웹기반이기때문에 가끔 먹통이 될때 사용)
 - Restart & Clear Output : 서버 재시작 및 output 초기화
 - Restart & Clear Output : 서버 재시작 및 모든 셀 실행 

실행단축키
shift + enter : 실행 -> 하단 셀로 이동 (하단 셀이 없을 경우 추가)
alt + enter : 실행 -> 하단셀 추가 -> 하단셀로 이동
ctrl + enter : 실행 -> 현재 셀 선택된 상태로 명령모드 진입
(명령모드) a : 현재 셀 위에 셀 추가
(명령모드) b : 현재 셀 아래에 셀 추가
(명령모드) dd : 현재셀 삭제
(명령모드) z : 되돌리기
(명령모드) m : 마크다운
(명령모드) y : 코드

tab : 자동완성 (한번 실행이 되어야 메모리에 로드되어서 자동완성이 가능함)


마크다운 사용 기초(마크다운.ipynb)

SQLite
import sqlite3
conn = sqlite3.connect('test.sqlite')

# 한 행을 딕셔너리로 출력하기 위해
# 함수를 만들어서 conn.row_factory 매서드에 오버라이드
def dictFactory(cursor, row):
    d={}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d
conn.row_factory = dictFactory

cur = conn.cursor()
cur.execute("SELECT * from mvcboard")
result = cur.fetchall()
result

Mysql
# pymysql 설치
# !를 붙이면 콘솔창에 명령어 실행시키는 것과 같음
!pip install pymysql
# 설치 중에 콘솔창에서 추가로 명령어를 입력해야하는 경우에는 사용하면 안됨

# dict로 출력하기
cur = conn.cursor(pymysql.cursors.DictCursor)


Oracle
# 패키지 설치
!pip install cx_Oracle
import cx_Oracle
conn = cx_Oracle.connect("testuser/test1234@localhost:1521/xe")
==========/에러날 경우===========
오라클 instant client 다운로드
https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html
압축해제
커넥트(conn) 전에
cx_Oracle.init_oracle_client(lib_dir= r"해당경로")
==========에러날 경우/===========

'''
cur.description을 이용해서
반복문 안에서 딕셔너리로 변환해서 r['name'] 출력
'''

for r in result:
#     r = dictFactory(cur, r)
    r = dict(zip([d[0] for d in cur.description], r))
    print(r['TITLE'], r['NAME'])


Numpy 

- 숫자와 관련된 작업 도구
- numpy array 자료형 : 파이썬의 리스트와 유사
- 리스트는 자료형 제한없음, array는 동일한 자료형만 가능
- 리스트보다 코드량도 적고, 속도도 빠름

numpy array 생성방법 
# 1. 리스트를 변환 (상단에서 했음)
arr = np.array([[1,2,3],[4,5,6]])

# 2. 동일한 값으로 생성
arr = np.full(10,7)

# 3. 모든 값이 0으로 생성
arr = np.zeros(10, dtype=int)

# 4. 모든 값이 1로 생성
arr = np.ones((5,2), dtype=int)

# 5. 랜덤값으로 생성
np.random.random(10)    # 0~1 사이의 실수를 뽑아줌
np.random.randint(1,7, size=(2,5))

# 6. 범위값으로 생성
np.arange(10)


인덱싱 / 슬라이싱
# 인덱싱
arr[0], arr[-1]
# 인덱스 각각
# 1번, 3번
arr[[1,3]]

# 슬라이싱
arr[1:4]  # 1부터 4 전까지
arr[:4]   # 맨 앞에서부터 4 전까지
arr[3:]   # 3부터 맨 끝까지
arr[:]    # 맨 앞에서부터 맨 끝까지
arr[::2]  # 맨 앞에서부터 맨 끝까지 2개 요소마다

arr2 = np.array([1,2,3,'4',5,6])
arr2  # 하나라도 문자열이 섞여있으면 전체가 문자열이 됨 (동일한 자료형이어야 해서..)

연산

벡터, 스칼라 연산시 -> 스칼라가 벡터로 변환됨
# 1이 [1,1,1,1,1,1,1,1,1,1] 변환해서 연산 -> 브로드캐스팅
# 요소개수가 다르면 연산이 안됨

# bool 연산
# 조건에 만족하는 인덱스 찾기
np.where(arr1 % 2 == 0)


=======================================
22.09.08 목 - 89일차

파이썬은 import하는 위치가 어디에 있으나 상관이 없다


Numpy
자주 사용되는 함수
arr = np.arange(20)
arr.max() : 최대값
arr.min() : 최소값
arr.mean() : 평균
np.median(arr) : arr의 중앙값
arr.var() : 분산
arr.std() : 표준편차



Pandas : 대표적인 파이썬 데이터 분석 라이브러리

pandas 안에 numpy 사용
데이터프레임(DataFrame)이라는 2차원의 표 형식
데이터프레임은 2차원 배열(행,열)
행 : 로우, 인덱스, 레코드 
 (인덱스: 일반적으로 언급되는 인덱스와는 다르게 행을 의미할때 사용됨)
열 : 컬럼, 필드, 속성, 피쳐(특징, Feature), 변수

numpy array, data frame 차이점
- numpy array는 숫자 인덱스만 가능
data frame은 문자 인덱스도 가능, 열 단위로 동일한 자료형

# 데이터프레임 생성하기
pd.DataFrame(plist)   # plist는 리스트

# 열 이름 지정해서 데이터프레임 생성하기 (columns 속성 지정)
pd.DataFrame(plist, columns=['name', 'age', 'class'])

# 행 이름 지정해서 데이터프레임 생성하기 (index 속성 지정)
pd.DataFrame(plist, index=['hong', 'kim', 'choi'])

# csv 읽어들이기 
df = pd.read_csv('iphone.csv', index_col=0)    
# index_col : 특정 컬럼을 인덱스로 지정할때 사용
# header : 가 없는 경우에 사용 (ex : header=None)

'''
DataFrame 인덱싱, 슬라이싱
iloc -> 인덱스로 위치 지정
loc -> 레이블로 위치 지정
loc[행, 열]
'''

df.loc['iPhone 8', '메모리']
df.iloc[2,2]

# 전체 데이터의 메모리
df.loc[:,'메모리'] 
 - 데이터 타입 Series : 데이터가 한 열(컬럼)상태로 있는 자료형을 뜻함

# iPhone 8 ~ iPhone X의 디스플레이~출시 버전
df.iloc[2:5, 1:4]
df.loc['iPhone 8':'iPhone X', '디스플레이':'출시 버전']   
 - loc는 슬라이싱시 지정한 컬럼까지 포함됨 (iloc는 그 전까지.)

# bool 연산
df.loc[df['디스플레이'] >= 5]    # 해당 조건값이 True인 것만 가져옴

# 디스플레이가 5인치 이상이고, 메모리가 4GB
# and 연산 : &
# or 연산 : |
df.loc[(df['디스플레이'] >= 5) & (df['메모리'] == '4GB')]

# 값 변경
# iPhone X의 출시 버전을 iOS 12.0 으로 변경
df.loc['iPhone X', '출시 버전'] = 'iOS 12.0'

tip
- 지속적으로 전처리를 할때 중간에 백업을 만들어두는 것이 좋다.
- 안할경우 중간에 실수했을때 스크립트를 처음부터 다시 실행해야함 
- 얕은 복사가 아닌 깊은 복사로 백업을 만들어야함

# DataFrame에 데이터 추가 (행)
# 존재하지 않는 행(로우) 인덱스로 대입
df.loc['iPhone 14'] = ['2022-10-01', 8, '16GB', 'iOS 14.0', 'Yes']

# DataFrame에 열 추가
df['제조사'] = 'Apple'

# DataFrame 데이터 삭제 : drop()
# axis 기본값이 0 (0: index, 1: columns)
# inplace 기본값이 False -> 삭제한 결과를 리턴 (원데이터 자체가 삭제되는게 아님)
df.drop('iPhone 14')

# 원데이터프레임을 삭제
# 방법 1. inplace=True
df.drop('iPhone 14', inplace=True) # 리턴 안함
# 방법 2. 다시 대입
df = df.drop('iPhone 14')

# 순번으로 삭제 -> df.index를 이용
df.drop(df.index[[0,2]])

# df.index : DataFrame의 index를 리턴 (리스트 형태와 유사한 자료형으로 동작)
# df.columns : DataFrame의 전체 컬럼

=======================================
22.09.13 화 - 90일차

colab - 구글에서 만든 웹기반 도구 (주피터와 유사)
 - 설치없이 사용할 수 있기때문에 연습용으로 사용할때 좋음

Pandas로 엑셀 다루기

# csv로 저장
df.to_csv('score.csv')  # 인덱스명 제외 (, index=False)

df2 = pd.read_csv('score.csv', index_col=0) # 첫번째 열을 인덱스로 지정

# 한글 깨지는 문제 
# 인코딩을 ms949/cp949
df.to_csv('score2.csv', encoding='ms949') # 엑셀에선 안깨지지만, 주피터에서는 깨짐
# 메모장은 두가지 다 깨짐없이 열어볼 수 있음

# 유니코드가 아니면 아예 읽어오지 못함, 인코딩 옵션 줘야함
df3 = pd.read_csv('score2.csv', encoding='ms949', index_col=0) 

# 합계 출력
df3.iloc[:, 1:4].sum(axis=1)

# 평균 출력
df3.iloc[:, 1:4].mean(axis=1)

# 평균 열을 추가
df3['평균'] = df3.iloc[:, 1:4].mean(axis=1)

# 과목평균
df3.iloc[:, 1:].mean(axis=0)

# 과목 평균행 추가
df3.loc[3] = df3.iloc[:, 1:].mean(axis=0)

# 두번째 시트
df2 = pd.read_excel('학생성적.xlsx', sheet_name=1)
df2

Excel 저장
- ExcelWriter 객체 생성
- DataFrame 객체를 지정된 시트에 쓰기
- ExcelWriter 객체 저장

# 객체 생성
ew = pd.ExcelWriter('학생성적2.xlsx', engine='xlsxwriter')
# 시트에 쓰기
df1.to_excel(ew, index=False, sheet_name='중간고사') #시트명 지정
df2.to_excel(ew, index=False, sheet_name='기말고사')
# 저장
ew.save()


필요한 파일명들만 가지고 올때 사용하는 모듈 - glob
import glob
glob.glob('./*')
glob.glob('./XX푸드_*.xlsx') 

엑셀에 차트 넣기 (참고 URL)
https://xlsxwriter.readthedocs.io/

빅데이터 분석
 - DB에 있는 데이터, csv데이터, 엑셀 등등을 가져와서 분석결과를 내는 것
 - 모든 데이터를 다 정형화 시켜서 DB에 넣는게 중요한 게 아님

스크래핑
- 웹 문서에 있는 정보를 추출하는 기술
- 웹 문서 구조 분석 포함

크롤링
- 웹사이트를 정기적으로 접속해서 정보를 추출하는 기술
- 프로그램을 크롤러 또는 스파이더라고 부름

데이터분석에서 사용할 수 있는 데이터 구조
- 데이터베이스(테이블)
- 파일(csv, excel, json...)
- 웹문서(html) : html(dom) 구조를 파악해서 추출

파이썬 라이브러리 (2가지 방법)
- requests 모듈
- urllib 라이브러리

BeautifulSoup
- html, xml에서 원하는 데이터를 추출
- 다운로드 안됨
- 아나콘다에 내장되어있음

urllib + BeautifulSoup 조합


=======================================
22.09.19 월 - 91일차

웹브라우저를 이용해서 스크래핑
- Selenium
  - 웹 테스트 도구

# selenium 설치
- !pip install selenium
# 크롬드라이버 설치
- https://chromedriver.chromium.org/downloads
- 현재 설치된 크롬버전과 일치하는 파일 다운로드 
 - 크롬 정보에서 버전 확인 (버전 105.0.5195.102 -> 105 버전 설치)
 - 압축 풀어서 해당파일을 실행할 파이썬파일 폴더에 넣으면 경로지정할때 용이함


selenium 사용하기 
 - 브라우저를 직접 실행하여 다소 느리지만 대부분의 크롤링이 가능함

from selenium import webdriver
br = webdriver.Chrome('chromedriver.exe') # 크롬창이 새로 실행됨

# url 이동하기
br.get('http://www.daum.net')

selenium 메서드
- 요소 추출 메서드
  - find_element_by_id(아이디)
  - find_element_by_name(name)
  - find_element_by_css_selector(선택자)
- 조작 메서드
  - get(url) : url로 이동
  - click() : 클릭
  - send_keys(값) : 값 입력
  - quit() : 종료
  - implicitly_wait(초) : 최대 대기 시간(초) (로딩 대기시간을 기다리고 동작할수 있게 함)


# 응답받은 소스
br.page_source

selenium에서 특정 element의 로딩 대기
- WebDriverWait 객체를 통해 로딩 대기
- 이 기능을 활용하면 거의 모든 사이트에 크롤링 가능
  from selenium.webdriver.support.ui import WebDriverWait
  from selenium.webdriver.support import expected_conditions as ec
obj = WebDriverWait(br, 5).until(ec.presence_of_element_located((By.CSS_SELECTOR, '.u_cbox_count')))


from tqdm import tqdm_notebook
for i in tqdm_notebook(range(100)):
    pass
- for문이 도는 동안 진행상황을 bar 형태로 보여줌



스케줄링
Windows : 작업스케줄러 (windows 관리도구 > 작업스케줄러)
linux : cron

작업스케줄러
기본 작업 만들기 -> 작업명, 트리거 시간 설정 -> 작업 : 프로그램 시작 
 - 프로그램/스크립트 : "python.exe파일위치"(E:\kdigital_a\anaconda3\python.exe)
 - 인수 추가(파라미터) : exchange.py
 - 시작 위치(실행할 파일 위치) : E:// 


크롤링 과제
http://www.weatheri.co.kr/
과거기상 > 일별검색
서울의 2021년 1월 1일부터 2021년 12월 31일까지
평균기온, 최고기온, 최저기온 데이터 수집(출력)


=======================================
22.09.20 화 - 92일차

Pandas 깊게 파기 
df = pd.read_csv('../data/gapminder.tsv', sep='\t')
1. 기초
1-1. 데이터 살펴보기
df.head() # 상위 5개 출력 (기본값이 5개)
df.tail() # 하위 5개 출력

type(df) # DataFrame : 행렬 형태의 2차원 자료구조
df.shape # 행, 열
df.info() # 데이터프레임 기본정보
 - Non-Null Count : null값이 아닌 데이터 수
 - Dtype : 데이터타입
df.columns # 컬럼 확인
df.dtypes # 컬럼별 데이터 타입 확인

df.describe() # 기술통계량(요약 통계) - 총계, 평균, 표준편차, 최대, 최소, 사분위수
df.count() # 데이터의 개수(컬럼별)
df['country'].value_counts() # 범주형데이터의 각 범주별 개수 -> Series 타입으로 반환됨

1-2. 통계함수
df[['lifeExp', 'pop']].mean() # 특정 컬럼 평균
df.mean() # 평균
df['lifeExp'].median() # 중앙값
df['lifeExp'].max(), df['lifeExp'].min() # 최대값, 최소값
df['lifeExp'].var(), df['lifeExp'].std() # 분산, 표준편차
df['lifeExp'].sum() # 합계

df.corr() # 상관계수
 - 두 변수(컬럼)간의 관계 (인과관계는 아님)
 - -1~1 사이
 - 1에 가까우면 양의 상관관계, -1에 가까우면 음의 상관관계

1-3. 데이터 추출
열 추출 : ['열이름']     
 - 1개 -> 시리즈, 2개이상 -> 데이터프레임
행 추출 : loc, iloc
df.loc[0] # 인덱스명
 - df.loc[-1] -> 키 에러
df.iloc[0] # 인덱스번호 
 - df.iloc[-1] -> 마지막 행 추출

1-4. 그룹핑 
(groupby를 쓰면 그룹함수를 사용한다고 생각하자)
df.groupby('year')['lifeExp'].mean() # 연도별 기대수명 평균
df.groupby(['year','continent'])[['lifeExp','gdpPercap']].mean() # 연도별, 대륙별 기대수명과 gdp 평균
df.groupby(['continent'])['country'].count() # 대륙별 국가 개수
df.groupby(['continent'])['country'].nunique() # 대륙별 국가 개수(유니크)


2. 시리즈와 데이터프레임
시리즈 생성
pd.Series(['홍길동', 80])
pd.Series(['홍길동', 80], index=['name', 'score']) # 인덱스명 부여해서 생성

차원이 줄어들때마다 자료타입이 바뀜
1차원(Str, int,...) -> 2차원(Series) -> 3차원(DataFrame)

member : DataFrame
member.index = ['hong', 'kim']  # 데이터프레임에 인덱스 부여
first = member.loc['hong'] # 데이터프레임에서 시리즈형태로 특정 데이터 추출
first.index, first.keys() # 시리즈의 인덱스
first.values # 시리즈의 값

예제에 사용된 데이터파일 : df = pd.read_csv('../data/scientists.csv')
df[df['Age'] > df['Age'].mean()] # 평균 나이보다 많은 사람 추출
df[df['Age'] > df['Age'].mean()]['Age'].min() # 평균 나이보다 많은 사람 중에서 제일 어린 나이 추출

age = df['Age']
age2 = pd.Series([1,2])
age + age2  # 서로 길이가 다른 시리즈로 연산하기
 -> 같은 인덱스 값만 연산되고 나머지는 NaN(결측값) 처리됨

age.sort_index(ascending=False) # 인덱스로 정렬하기
age + age.sort_index(ascending=False) # 정렬 여부와 상관없이 같은 인덱스끼리 연산

데이터 타입 변환하기 (object -> 날짜)
 - 날짜데이터는 연산이 가능함
print(df.['Born']) # object 타입
pd.to_datetime(df['Born']) # 날짜 타입으로 데이터 변환
df['born_dt'], df['died_dt] = pd.to_datetime(df['Born']), pd.to_datetime(df['Died'] # 날짜 타입으로 변환 후 DataFrame에 컬럼 추가
df['days'] = df['died_dt'] - df['born_dt'] # 날짜끼리 연산 후 컬럼 추가

3. 데이터 합치기
사용한 파일
df1 = pd.read_csv('../data/concat_1.csv')
df2 = pd.read_csv('../data/concat_2.csv')
df3 = pd.read_csv('../data/concat_3.csv')

concat_df = pd.concat([df1, df2, df3]) # 위/아래로 합치기(수직)
 - (기본값)열이름이 같아야 함
 - 한행만 합치는 경우 append를 이용해도 됨
concat_df.reset_index() # 인덱스 리셋, 반영은 하지 않고 리턴만 함
pd.concat([df1, df2, df3], ignore_index=True) # 인덱스를 새로 지정하면서 합침

col_df = pd.concat([df1, df2, df3], axis=1) # 수평 합치기(가로/열방향)
pd.concat([df1, df2, df3], axis=1, ignore_index=True) # 열이름 새로 지정

concat() - join 속성
 - 기본값 : outer
 - pd.concat([df1, df3], join='inner') # inner조인


concat : row나 columns을 기준으로 단순하게 이어붙이기
merge : 특정 값을 기준으로 병합
- pd.merge(left, right, on='기준컬럼', how='left|right|inner|outer')
pd.merge(df, df3, left_on='이름', right_on='성명', how='left') # 기준컬럼명이 다를 경우

4. 결측값처리
4-1 fillna() 
 - na값을 fill(채워주는) 함수 (리턴값을 돌려줌, 원데이터에 반영 x)
 - 원데이터에 반영하려면 inplace=True 속성 사용

결측치를 치환할 때 자주 사용되는 대표값
 - 평균, 중앙값(수치형) + 최빈값(범주형)
df['키'].mean() : 평균 
df['키'].median() : 중앙값
df['키'].mode() : 최빈값 -> Series 형태로 리턴
 - df['키'].mode()[0] : 값만 빼내는 방법

4-2 결측값이 있는 행을 제거
df.dropna() # 하나라도 결측치가 있으면 그 행을 삭제
df.dropna(axis=1) # 하나라도 결측치가 있는 열을 삭제
 - how 옵션 : any - 하나라도 있으면 삭제, all - 전부 결측치면 삭제

4-3 컬럼의 중복값을 제거
df['키'].drop_duplicates() # 중복된 값이 있으면 제거
 - keep 옵션 : first | last

df.drop_duplicates('키') # 행 단위로 제거하기 (파라미터가 중복값 판정 기준)

5. 데이터 가공
5-1 피벗테이블
- 엑셀 피벗테이블
- 컬럼 중에서 두개를 골라서 행 인덱스, 열 인덱스로 사용해서 데이터를 펼처 놓은 것
- index : 행, columns : 열, values : 값 (기본값은 평균)
# aggfunc : 추가 계산 옵션(np.mean: 기본값)
 - numpy import 필요
pd.pivot_table(df, index='그룹', columns='혈액형', values='브랜드평판지수', aggfunc = np.sum)

5-2 자료형 변환
# 키 (실수 -> 정수)
astype()
df['키'] = df['키'].fillna(df['키'].mean()).astype(int)
- 결측치가 있는 경우 결측각 처리해줘야 에러 안남
- 변환한 값을 리턴만 해주므로 다시 대입

# 날짜변환
df['생년월일'] = pd.to_datetime(df['생년월일'])
- 변환한 값을 리턴만 해주므로 다시 대입

날짜타입으로 변경해주는 이유
 - 년, 월, 일, 요일... 추출 가능
 - 날짜 연산 가능

카테고리 자료형
 - 범주형
 - 용량, 속도에 이점이 있음

문자열 처리
샘플데이터 : df = pd.read_excel('../data/불량 기록 데이터.xlsx')

# 시리얼번호 : 공정-제품-식별자
# 공정이 S인 제품개수
df['시리얼번호'].str.contains('S').sum() # True는 1, False는 0

# '-' 기준으로 분할하기 (expand : 컬럼별로 분할)
df['시리얼번호'].str.split('-', expand=True)

# 컬럼명 변경(원하는 컬럼만 변경)
df2.rename({0:'공정', 1:'제품', 2:'식별자'}, axis=1, inplace=True)

# 불량데이터의 공정별, 제품의 개수
pd.pivot_table(df2.loc[df2['불량 여부'] == '불량'], index='공정', columns='제품', values='불량 여부', aggfunc='count')

apply() 메서드
df = pd.DataFrame({'a': [10, 20, 30], 'b': [20, 30, 40]})
df['a'].apply(func_sq)   # 함수를 매개변수로 넘겨줄 수 있음 (callback함수처럼 사용 가능)

def avg(row):
    total = 0
    for r in row:
        total += r
    return total / len(row)

df.apply(avg) # 컬럼별 평균 확인 가능

라벨인코딩(Label Encoding)
# map (값 매핑)
gender_map = {'남자':1, '여자':2}
df['성별'].map(gender_map)

원핫인코딩 (One-Hot Encoding)
pd.get_dummies(df['혈액형'], prefix='혈액형')
pd.concat([df, pd.get_dummies(df['혈액형'], prefix='혈액형')], axis=1)


=======================================
22.09.21 수 - 93일차

6. 데이터 가공실습
실습데이터 : data/온라인_판매기록.csv

# 피벗테이블로 행:제품, 열:쇼핑몰 유형, 값: 판매금액
# 평균소수점 2자리
- 방법 1 : 전체에 round(2)
- 방법 2 : aggfunc= 속성 이용 (함수 정의해서 사용)
- 방법 3 : aggfunc= 속성 이용 (lambda 이용)

# 쇼핑몰 유형별 판매금액, 수량, 평균 최대값
(피벗테이블의 aggfunc 속성과 유사하게 groupby에서도 agg함수 사용이 가능)
df.groupby('쇼핑몰 유형')[['판매금액', '수량']].agg(['mean', 'max'])


실습과제
주택도시보증공사_전국 신규 민간 아파트 분양가격 동향_20200331.csv
1. 컬럼명 변경
분양가격(m2) -> 분양가격
2. 결측치 확인 : 0으로 치환
3. 통계값 확인
4. 분양가격 자료형을 int로 변환
5. 규모구분에 '전용면적 ' 문자열 제거
6. 분양가격이 없는 데이터(0) 삭제
7. 지역별 평균 분양가격 확인
8. 지역별 가장 비싼 분양가격 확인
9. 연도별 평균 분양가격 확인
10. 연도별 규모구분별 평균 분양가격 확인

실습과제 2 - 패밀리레스토랑 데이터 분석 과제
https://codro.notion.site/a8bcd12fb866494680ca57bc07bbacc7

=======================================
22.09.22 목 - 94일차

수집 -> 저장 -> 전처리(+시각화) -> 분석 -> 결과(시각화)

파이썬 시각화 라이브러리 - matplotlib, seaborn


pandas 내장 그래프
- plot() 메서드를 통해서 kind 옵션으로 그래프 종류 지정
- 그래프 종류
  - line : 선그래프 (기본값)
  - bar : 바그래프(수직)
  - barh : 바그래프(수평)
  - hist : 히스토그램
  - box : 박스플롯
  - kde : 커널 밀도 그래프
  - area : 면적
  - pie : 파이차트
  - scatter : 산점도
  - hexbin : 고밀도 산점도

파이썬에서 기본적으로 사용하는 matplotlib는 한글처리가 되어있지 않음
한글처리를 따로 해줘야함


행과 열을 바꾸기(전치행렬)
df2_t = df2.T # transpose()


import matplotlib.pyplot as plt
 - 대부분 경우 사용되는 라이브러리

# 결측치 처리 (앞 데이터로 채우기) - ★★★★
df = df.fillna(method='ffill')

# 차트 스타일 지정
plt.style.use('ggplot') # 사용가능한 스타일은 plt.style.available에서 확인 가능
# 크기 지정
plt.figure(figsize=(15,4))
# x축 이름 회전
plt.xticks(rotation='vertical') # 회전각도 숫자 또는 'vertical', 'horizontal' 가능
# 마커
plt.plot(df_seoul.loc['경기도'], color='red', marker='s') # marker : ^, *, o, + 등등 help 확인
# 축이름
plt.xlabel('연도')
plt.ylabel('인구수')
# 제목
plt.title('서울->경기도')
# 범례 
plt.legend(labels=['서울->경기'])
plt.show()



# 그래프 여러개 사용하기 (방식이 조금 다름)
# 크기 지정
fig = plt.figure(figsize=(15,10)) # 큰 도화지
ax1 = fig.add_subplot(2, 1, 1) # 첫번째 그래프 (행, 열, 순서)
ax2 = fig.add_subplot(2, 1, 2) # 두번째 그래프 (행, 열, 순서)
# 마커
ax1.plot(df_seoul.loc['경기도'], color='red', marker='s') 
ax2.plot(df_seoul.loc['충청남도'], color='blue', marker='P')
# x축 이름 회전 (메서드가 달라짐)
ax1.set_xticklabels(df_seoul.loc['경기도'].index, rotation='vertical')
ax2.set_xticklabels(df_seoul.loc['충청남도'].index, rotation='vertical')

# y축의 범위(최소, 최대)
ax1.set_ylim(50000, 800000)
ax1.legend(labels=['서울->경기'], loc='upper left') # loc옵션 : 위치 지정
plt.show()


워닝메시지 무시하는법
import warnings
warnings.filterwarnings("ignore")


하나의 axe객체에 여러개의 그래프 추가하기
fig = plt.figure(figsize=(15,4)) # 그래프 크기 지정,
ax = fig.add_subplot(1,1,1) # 객체 생성
# 마커, 데이터 추가
ax.plot(df_seoul.loc['전라남도'], color='red', marker='s')
ax.plot(df_seoul.loc['충청남도'], color='blue', marker='X')
ax.plot(df_seoul.loc['충청북도'], color='green', marker='o')
plt.show()


누적영역그래프
df2 = df_seoul.loc[['전라북도','전라남도','충청북도','충청남도']].T
df2.plot(kind='area', alpha=0.5)

지도시각화 - folium
!pip install folium
import folium

folium.Map(location=[37.5697987, 126.9837167], zoom_start=12, tiles='Stamen Terrain') # 지도 시각화, 위치 지정

# 지도에 마커 추가하기
df = pd.read_excel('데이터수집/data/서울지역 대학교 위치.xlsx', index_col=0)
for lat, lng, name in zip(df['위도'], df['경도'], df.index):
    folium.Marker([lat, lng], popup=name ).add_to(seoul)
seoul

# 행정구역 데이터 기반으로 지역 구분하기
df = pd.read_excel('데이터수집/data/경기도인구데이터.xlsx', index_col=0)
import json
geo = json.load(open('데이터수집/data/경기도행정구역경계.json', mode='r', encoding='utf-8'))
geo
gg = folium.Map(location=[37.5697987, 126.9837167], zoom_start=9, tiles='Stamen Terrain')
folium.Choropleth(geo_data=geo, data=df[2017], 
                  columns=[df.index, df[2017]],
                  fill_color='Reds', 
                  fill_opacity=0.7,
#                   bins=[40000, 100000, 300000, 500000, 700000],
                  threshold_scale=[40000, 100000, 300000, 500000, 700000],
                 key_on='feature.properties.name').add_to(gg)
gg


gg.save('gg.html') # html로 저장하기

=======================================
22.09.23 금 - 95일차

시각화 - seaborn
import matplotlib.pyplot as plt
import seaborn as sns

# 데이터 로드
tips = sns.load_dataset('tips')

# 그래프 종류
sns.violinplot(data=tips, x='day', y='total_bill') # 바이올린플롯 
sns.countplot(x=tips['day']) # 카운트(개수)플롯
sns.relplot(data=tips, x='tip', y='total_bill') # 산점도
sns.lmplot(data=tips, x='tip', y='total_bill') # 산점도 + 리니어(선)
sns.heatmap(tips.corr(), annot=True, linewidths=1, cmap='Reds') # 히트맵
sns.barplot(data=tips, x='day', y='total_bill', palette='rainbow') # 막대그래프, 상단 중앙에 선은 신뢰구간을 의미함, palette : rainbow, coolwarm, 등등 여러가지 있음
sns.catplot(data=tips, x='sex', y='total_bill', hue='smoker') # catplot : 범주형 변수와 수치형 변수간의 관계
sns.catplot(data=tips, x='sex', y='total_bill', hue='smoker', kind='bar') # catplot 막대그래프형태로 출력
sns.catplot(data=tips, x='sex', y='total_bill', hue='smoker', kind='bar', col='time') # col 옵션 : 설정한 변수별로 그래프 출력
sns.scatterplot(x, y, size=z, sizes=(z.min(), z.max()), hue=z, palette='coolwarm') # 산점도, size 옵션 : 값에 따라 크기 변함 (z=x*y*1000 으로 설정함)
 - pyplot에 산점도와 비교
 - plt.scatter(x, y, s=z, c=np.arange(50))
sns.pairplot(tips, hue='size', palette='rainbow') # pairplot : 그리드 형태(히스토그램 + 분포도)
sns.jointplot(data=tips, x='total_bill', y='tip') # 보고싶은 것만 선택해서 (히스토그램 + 산점도)
 - kind 옵션 
   - reg : 회귀선
   - hex : 밀도
   - kde : 등고선 형태

# 상관계수 확인
tips.corr()


파이차트
# 옵션 explode : 파이차트에서 한 조각이 튀어나오는 비율
labels = ['삼성', '애플', '화웨이', '샤오미', '기타']
values = [40, 30, 20, 7, 3]
explode = [0.1, 0, 0, 0, 0]
# startangle : 시작각도
# autopct : 퍼센트 표기
plt.pie(values, labels=labels, shadow=True, explode=explode, startangle=90, autopct='%.1f%%')
plt.show()


타이타닉 데이터로 히트맵 표현해보기
titanic = sns.load_dataset('titanic') # 데이터셋 로드
sns.heatmap(titanic.corr(), annot=True, linewidths=1, cmap='Reds')


공공데이터 자료 사이트
https://www.aihub.or.kr/

=======================================
22.09.26 월 - 96일차

수학 이론 수업


로그함수를 많이 사용하는 이유
 - 어떤 함수에 로그를 적용해도 함수의 최고점, 최저점의 위치는 변하지 않음
 - 0부터 1사이의 작은 값을 확대시켜줌


=======================================
22.09.27 화 - 97일차

선형대수2

풀랭크가 아니면 역행렬이 안구해지고, 회귀분석도 잘 안됨

=======================================
22.09.28 수 - 98일차

수학 - 확률

파이썬 자료형
set : mutable 자료형
frozenset : immutable 자료형


가설검정

t검정 순서
 - 가설설정 -> 데이터 정규성 검정 -> 분산 동질성(등분산성) 검정 -> T-test -> 결론

---------문제-----------
날씨(맑음, 비, 흐림) 3가지 분류라고 가정
같은 날씨가 연속될 확률이 60%,
연속되지않고 변할 확률 40%
(단, 맑음->흐림, 비->흐림, 흐림->맑음 확률은 70%)

1) 오늘 날씨가 맑음일때, 모레의 날씨가 비일 확률
 -> 17.76%
2) 조깅을 맑음일때는 80%의 확률로, 흐림인 날에는 40%의 확률로, 비인 날에는 조깅을 안함. 
오늘(맑음)과 내일 이틀 연속해서 조깅할 확률
 -> 47.36%
------------------------끝


=======================================
22.09.29 목 - 99일차

가설검정 
ANOVA 검정 : 세 집단 이상을 검정할때 사용
ANOVA 분석 -> 분산분석(Analysis of Variance)

데이터분석,머신러닝 이론

Scikit-Learn(사이킷-런)
 - 파이썬의 대표적인 머신러닝 라이브러리
 - 다양한 모델 알고리즘
 - 성능평가도구
 - Numpy, Pandas 기반
 - Jupyter notebook 설치시 포함

머신러닝
 - 데이터를 기반으로 패턴을 학습하여 결과를 추론하는 것

MSE(Mean Squared Error) 
 - 실제 회귀분석에서 평가지표로 사용됨


사이킷-런 홈페이지(Scikit-Learn)
https://scikit-learn.org/stable/


일반적인 머신러닝 코드 (임포트 -> 모델 객체 생성 -> 학습 -> 예측 )
# 임포트
from sklearn.linear_model import LinearRegression
# 모델 객체 생성
model = LinearRegression()
# 학습
model.fit(x,y)
# 예측
pred = model.predict([[10], [20]])

데이터를 쪼개주는 함수 (training set - 학습용 / test set - 평가용)
from sklearn.model_selection import train_test_split

스케일링
 - 정규화(Normalization)
 - 표준화(Standardization; Z-score 정규화)


=======================================
22.09.30 금 - 100일차

분류 - 의사결정나무, 로지스틱 회귀, KNN, 나이브 베이지안, 퍼셉트론, 인공신경망, 다층신경망, 혼동행렬, 분류보고서, 교차검증

회귀


스케일링 - StandardScaler, MinMaxScaler, RobustScaler
# StandardScaler
# 평균 : 0, 표준편차 : 1

# MinMaxScaler
# 0~1 사이로 정규화

# RobustScaler
# 중앙값 : 0, IQR : 1
# 이상치(Outlier) 처리에 유용함


파이프라인

다음주 배울 내용
앙상블, 비지도학습, 파라미터 수정하기, 데이터가 불균형할때


=======================================
22.10.04 화 - 101일차
앙상블(Ensemble)
여러 머신러닝 모델들을 이용해서 최적의 답을 찾아내는 기법
종류
- voting(보팅) : 투표를 통해 결과 (다른 모델)
- bagging(배깅) : 샘플 중복 생성을 통해 결과 (하나의 모델, 샘플이 여러개)
- boosting(부스팅) : 이전 오차를 보완해나가는 형태
- stacking(스태킹) : 여러 모델들이 예측한 결과를 다시 학습해서 최종 예측

RandomForest
- DT(트리) 기반의 배깅 모델
- 단일모델로 여러개의 샘플 조합

자주 사용하는 파라미터
- n_estimators : 트리 갯수
- random_state : 랜덤 시드값
- n_jobs : CPU 사용갯수 지정 (-1:전체)
- max_depth : 최대깊이 (과적합 감소)
- max_features : 최대 feature 개수 (과적합 감소)
- max_sample_split : 분할시 최대 샘플개수 (과적합 감소)

boosting
이전에 학습한 예측값 중 잘못 예측한 값(오차)를 보완해나가는 방식
- 장점 : 성능이 우수
- 단점 : 보완해 나가는 방식이므로, 이상치에 민감하고, 학습시간이 오래걸림
대표적인 부스팅 모델
- AdaBoost
- GradientBoost
- LightGBM
- XGBoost (제일 유명함)

XGBoost
성능이 우수
사이킷런에 없음(별도 설치 필요) - 실기시험에는 설치가 되어있는 환경임

LightGBM
성능도 좋은 편, 속도도 빠른 편
사이킷런에 없음

Stacking
개별 모델들이 예측한 결과를 가지고 최종 학습 예측
성능을 최대한 올려야하는 경우
과적합 유발 가능성 높음

Weighted Blending
각 모델들의 "예측값"에 가중치(weight)값을 지정
가중치의 합은 1

=======================================
22.10.05 수 - 102일차

캐글사이트에서 실습하기
https://www.kaggle.com/

타이타닉 데이터 - 분류
https://www.kaggle.com/competitions/titanic


train.isnull().sum() # 결측치 확인
train.describe() # 요약 통계 -> 수치형 데이터에 대한 요약통계
train['Survived'].value_counts() # 특정 컬럼에 대한 value 확인
train.corr() # 상관관계 테이블

대략적으로 데이터를 파악한 후에 시각화를 통해 추가로 살펴보자


=======================================
22.10.06 목 - 103일차

회귀 실습
자전거 수요예측 - 회귀
https://www.kaggle.com/competitions/bike-sharing-demand

비지도학습
- 지도학습과는 다르게 결과값(y값, 목표값...)이 없는 경우
- 차원축소 : PCA, LDA...
- 군집화(Clustering) : K-Means Clustering, DBSCAN
- 군집화 평가 : 실루엣

차원축소
- feature의 개수를 줄임
- 특징을 추출하는 역할
- 계산량이 감소하는 효과

K-means, DBSCAN 애니메이션 참고 사이트
https://medium.com/@phil.busko/animation-of-k-means-clustering-31a484c30ba5


비대칭 데이터
- 불균형 데이터, imbalanced data
- target 데이터의 비율이 차이가 많이 나는 경우 (암 양/악성, 반도체 고장여부)
- 정확도는 높지만, 재현율이 낮아지는 현상

해결방법
- over-sampling : 적은 데이터를 증가(많이 사용)
- under-sampling : 많은 데이터를 제거


AB테스트 실습 -> 모바일게임 리텐션 분석



내일 할 것
 - 텍스트 분석
다음주 : 딥러닝

=======================================
22.10.07 금 - 104일차

텍스트 분석 
"/데이터수집/데이터수집_응용_teacher.ipynb"

NLTK (Natural Language ToolKit)
 - 교육용으로 개발된 자연어 처리 및 문서 분석용 파이썬 패키지
Corpus
 - 말뭉치, 문서 집합

불용어 리스트 (구글 검색 : github stopwords ko)
https://github.com/stopwords-iso/stopwords-ko


=======================================
22.10.11 화 - 105일차

연관규칙(Association Analysis/Rule)
 - 지지도(Support)
 - 신뢰도(Confiendce)
 - 향상도(Lift)

감정분석
 - 학습한 객체를 pickle로 저장 -> Flask로 API를 만듬 -> 사용자가 Flask로 만든 API를 이용하여 요청함 -> Flask가 학습된 객체를 이용하여 예측한 뒤 결과값을 사용자에게 리턴해줌


머신러닝 -> 사이킷런
딥러닝 -> Tensorflow, PyTorch

Tensorflow 
 - 가장 많이 사용되는 딥러닝 오픈소스 프레임워크
 - 구글에서 개발
 - 파이썬 API
 - numpy array와 호환성 우수함
 - PC/서버 외에도 클라우드, 모바일, 웹,... 등등에서 모두 사용 가능
 - Keras 포함

Tensorflow, PyTorch 비교
Tensorflow 
 - 라이브러리를 사용하는 느낌
 - 실무에서 주로 사용

PyTorch : 
 - 파이썬으로 코딩하는 느낌
 - 연구소에서 많이 사용


오늘 배운 것 : 연관분석, 사이킷런 전처리, 감정분석_with NSMC, 딥러닝 기본문법

=======================================
22.10.12 수 - 106일차

딥러닝

3가지 모델 구현 방법
1. 시퀀셜
2. 클래스 상속
3. 함수형


CNN(합성곱 신경망, Convolutional Neural Network)
 - input
 - 중간에 추가되는 작업 : 합성곱 레이어, 풀링 레이어, 활성화함수, 평탄화 작업
 - 히든레이어
 - ouput

합성곱 Conv2D 매개변수
filters : 특징맵의 차원
kernel_size : 필터의 크기(튜플), 스칼라값도 가능
padding : 'same' -> 입력과 출력 형태가 동일
activation : 활성화함수(relu)
input_shape : 입력데이터의 차원

성능개선
Regularizer
- 규제함수
- 모델의 복잡도를 제한해주는 함수
- L1규제 : 가중치 절대값의 합
- L2규제 : 가중체 절대값 제곱의 합
- 보통 L2 사용

BatchNormalization
- 데이터의 범위를 제한
- 배치정규화 후 활성화함수 적용

Dropout
- 레이어의 특정 가중치를 제외
- 비율은 보통 : 0.2~0.5 사이

=======================================
22.10.13 목 - 107일차

Early Stopping : 기준값이 역행하면 학습 조기 중지
Model Choice (Model Checkpoint) : 가장 좋았던 모델을 저장


RNN(Recurrent Neural Network, 순환신경망)
- 텍스트/시계열 데이터에서 많이 사용
- 기존 알고리즘들은 변수들이 독립적(가정)
- 텍스트/시계열 데이터는 서로 연관성 높음

LSTM 
 - 순환 신경망 기법의 일종
 - 셀, 입력 게이트, 출력 게이트, 망각 게이트를 이용해 기존 순환 신경망의 문제인 기울기 소멸 문제를 방지하도록 개발됨

GRU
 - 장단기 메모리(LSTM)와 달리 출력 게이트가 없는 간단한 구조
 - 한국인인 뉴욕대학교 조경현 교수가 제안한 순환 신경망


교재로 수업 시작
교재 : 파이썬 데이터 분석 실무 테크닉 100 

데이터는 꼭 확인해보자
 - data.info()
 - data.head() or data.tail()
 - data.describe()
 - data.isnull().sum()

=======================================
22.10.14 금 - 108일차

2장 - 데이터 가공

데이터 불러오기
데이터 오류 파악하기
오류가 있는 상태로 집계해보기
상품명 오류를 수정하기
금액에 결측치를 수정하기
고객 이름 오류 수정하기
날짜 오류 수정하기
두개의 데이터 조인하기
가공 및 정제된 데이터 덤프하기(백업하기)
데이터 집계하기

수정한 후에 제대로 수정되었는지 꼭 확인하도록 하자


2부 실전편 - 머신러닝
3장 - 고객의 전체 모습을 파악하는 테크닉

데이터 읽어들이고 확인하기
고객데이터를 가공하기
고객데이터를 집계하기
최신 고객 데이터 집계하기
이용이력 데이터 집계하기
이력 데이터로부터 정기이용 플래그 작성하기
고객 데이터와 이력 데이터 결합하기
회원 기간 계산하기
각종 통계량 파악하기
탈퇴회원과 지속회원의 차이 파악하기


=======================================
22.10.17 월 - 109일차

4장 고객의 행동을 예측하는 테크닉10 (K-means, PCA, 선형회귀분석)
데이터를 읽어들이고 확인하기
클러스터링으로 회원 그룹화하기
클러스터링 결과 분석하기
클러스터링 결과를 가시화하기
클러스터링 결과를 바탕으로 탈퇴회원의 경향을 파악하기
다음 달의 이용횟수 예측을 위해 데이터를 준비하기
특징이 되는 변수 추가하기
다음달 이용 횟수를 예측하는 모델 구축하기
모델에 기여하는 변수를 확인하기
다음달의 이용횟수를 예측하기

5장 회원 탈퇴를 예측하는 테크닉10 (의사결정나무)
데이터를 읽어들이고 이용데이터를 수정하기
탈퇴 전월의 탈퇴 고객 데이터를 작성하기
지속 회원의 데이터를 작성하기
예측할 달의 재적기간을 작성하기
결측치를 제거하기
문자열 변수를 처리할수 있도록 가공하기
의사결정 트리를 사용해서 탈퇴 예측 모델을 구축하기
예측모델을 평가하고 모델을 튜닝해보기
모델에 기여하는 변수를 확인하기
회원 탈퇴를 예측하기

빅분기 실기 참고내용
model.predict_proba()로
 - 해당 함수를 사용해서 제출해야하는 경우가 대부분임


(오후) API 응용하는 과제
project DB에 board 테이블
게시판 API 개발(목록)

URL : /api/board/list
METHOD : GET
Param : 페이지번호, 페이지당출력개수, 검색타입, 검색어
Res : 총개수, 총페이지수, 현재페이지번호, items라는 속성 안에 [번호, 제목, 조회수, 작성자, 작성일]
 - {
    총개수 : 100,
    총페이지수 : 10,
    현재페이지번호 : 1,
    items :
    [
        {
            번호 : 43
            제목 : "제목1"
            조회수 : 235
            작성자 : 42
            작성일 : "2022-10-20"
        },
        {
            번호 : 44
            제목 : "제목2"
            조회수 : 131
            작성자 : 43
            작성일 : "2022-10-22"
        },
        {
            번호 : 45
            제목 : "제목3"
            조회수 : 21
            작성자 : 8
            작성일 : "2022-10-25"
        }
    ]
}

=======================================
22.10.18 화 - 110일차

3부 실전편(2) - 최적화 문제

6장 물류의 최적경로를 컨설팅하는 테크닉 10
물류 데이터를 불러오기
현재 운송량, 비용을 확인해보기
네트워크를 가시화해보기
 - networkx (네트워크 가시화에 유용한 라이브러리)
네트워크에 노드를 추가해보기
경로에 가중치를 부여하기
운송 경로 정보를 불러오기
운경 경로 정보로 네트워크를 가시화하기
운송 비용 함수 작성하기
제약 조건 만들기
운송경로를 변경해서 운송 비용 함수의 변화 확인하기


7장 물류 네트워크 최적 설계를 위한 테크닉 10
운송 최적화 문제를 풀어보기
 - pulp : 최적화모델 작성할때 사용하는 라이브러리
 - ortoolpy : 목적함수를 생성해서 최적화문제를 풀때 사용하는 라이브러리
최적운송경로를 네트워크로 확인하기
최적운송경로가 제약조건을 만족하는지 확인하기
생산계획 데이터 불러오기
이익을 계산하는 함수 만들기
생산 최적화문제를 풀어보기
최적 생산 계획이 제약조건을 만족하는지 확인하기
물류 네트워크 설계 문제를 풀어보기
최적 네트워크의 운송비용과 그 내역을 계산하자
최적네트워크의 생산비용과 그 내역을 계산하기

=======================================
22.10.19 수 - 111일차

8장 수치 시뮬레이션으로 소비자의 행동을 예측하는 테크닉
인간관계 네트워크를 가시화하기
 - networkx vs network
 - networkx는 position을 따로 설정 안해주고 중심이 되는 노드가 가운데로 온다
입소문에 의한 정보 전파 모습을 가시화해보기
입소문 수의 시계열 변화를 그래프화 해보기
회원 수의 시계열 변화를 시뮬레이션 해보기
파라미터 전체를 '상관관계'를 보면서 파악해보기
실제 데이터를 불러오기
링크 수의 분포를 가시화하기
시뮬레이션을 위해 실제 데이터로부터 파라미터를 추정하기
실제 데이터와 시뮬레이션 비교하기
시뮬레이션으로 미래를 예측해보기


4부 - 발전편 : 이미지처리 / 언어처리

9장 잠재고객을 파악하기 위한 이미지인식 테크닉 10
이미지 데이터를 불러오기
동영상 데이터를 불러오기
동영상을 이미지로 나누고 저장하기
이미지 속에 사람이 어디에 있는지 검출해보기
이미지 속의 사람 얼굴을 검출해보기
이미지 속 사람의 얼굴이 어느쪽을 보고있는지 검출해보기
검출한 정보를 종합해서 타임랩스를 만들어보기
전체모습을 그래프로 가시화하기
거리의 변화를 그래프로 확인해보기
이동평균을 계산해서 노이즈를 제거하기
 - 오차 : 계산해야할 사람을 계산하지 않아서 생기는 오차 or 계산하지 않아도 될 것을 계산해서 생기는 오차

=======================================
22.10.20 목 - 112일차

10장 앙케이트 분석을 위한 자연어 처리 테크닉
데이터를 불러서 파악해보기
불필요한 문자를 제거하기
문자수를 세어서 히스토그램으로 표시하기
형태소 분석으로 문장을 분해하기
형태소 분석으로 문장에서 '동사', '명사'를 추출하기
형태소 분석으로 자주 나오는 명사를 확인하기
관계없는 단어를 제거하기
고객만족도와 자주 나오는 단어의 관계를 살펴보기
의견을 특징으로 표현하기
비슷한 설문지를 찾아보기


=======================================
22.10.21 금 - 113일차
 - (완료)Service 테스트 : list, view, insert, delete, edit
 - (완료)게시판 템플릿 완료
 - (완료)상세페이지 템플릿 완료
 - (완료)썸머노트에디터 구현

 - 게시글 쓰기(write.do[작성페이지, get] / write.do[삽입, post]
 - 로그인 여부 체크 메서드 구현-> 백엔드? 프론트엔드? (둘다 하자)
 - 수정 (edit.do[수정페이지, get] / edit.do[수정, post]
 - view (view.do - get)
 - 경로 구현

썸네일에디터
 - Thumbnailator (https://github.com/coobird/thumbnailator)


=======================================
22.10.24 월 - 114일차

(완료)게시글 쓰기(write.do[작성페이지, get] / write.do[삽입, post])
(완료)수정 (edit.do[수정페이지, get] / edit.do[수정, post]
(완료)view (view.do - get)
(완료)관리자 테이블 생성

(구현중)파일 첨부 구현

 - 로그인 여부 체크 메서드 구현-> 백엔드? 프론트엔드? (둘다 하자)

썸네일에디터
 - Thumbnailator (https://github.com/coobird/thumbnailator)

댓글 구현
총 댓글수 view sql에 추가

/insert.do
임시경로에 저장 먼저 하고, 
board테이블에 먼저 insert한 이후에 
file테이블에 bno값을 받아서 저장할 수 있도록 구현하기

=======================================
22.10.25 화 - 115일차

(완료)파일 첨부 구현 - 작성, 수정 (에디터, 첨부파일란 추가 완료)
(완료)회원가입 구현 중


로그인 여부 체크 메서드 구현-> 백엔드? 프론트엔드? (둘다 하자)

썸네일에디터
 - Thumbnailator (https://github.com/coobird/thumbnailator)

댓글 구현
총 댓글수 view sql에 추가

=======================================
22.10.26 수 - 116일차

프로젝트 오늘 일정
(완료)에디터 p태그 제거
(완료)인증번호 재발송시 session 초기화
(완료)인증성공하면 email 수정 막기
(완료)아이디 중복체크
(완료)닉네임 중복체크
(완료)회원가입 완료
(완료)로그인페이지 레이아웃 잡기
(완료)로그인 구현
(완료)로그아웃 구현

회원정보 수정
로그인 체크

=======================================
22.10.27 목 - 117일차

NoSQL
 - Not Only SQL
 - 비관계형 데이터베이스 (NoREL)
 - 비정형(반정형)데이터 저장 용도
 - 수평적 확장
 - 관계형 데이터베이스에 비해 유연
 - 제약조건/무결성 유연
 - ACID 결여
 - 쓰기 속도 빠름
 - join 없음 (완전히 없다고 할 수는 없음...)

종류
 - column 기반 : HBase, Cassandra
 - document 기반 : "mongoDB", couchbase
 - key-value 기반 : DynamoDB, "Redis"
 - graph 기반 : Neo4j

MongoDB
 - C++로 만들어진 document기반 데이터베이스
 - NoSQL 중 1위

NoSQL	vs	RDB
document(문서)	==	recode(하나의 데이터)
collection	==	table

JSON 구조


==== MongoDB 설치 ====
https://www.mongodb.com 접속
product -> Community Edition -> 윈도우버전 다운로드
설치파일 실행 -> custom -> 경로변경 (E:\kdigital_a\mongodb6.0)
 -> Run service as Network Service User -> (MongoDB Compass는 설치해도 되고 안해도 됨) -> install
(이번에는 MongoDB Compass 같이 설치함)

MongoDB Compass
기본 포트번호 : 27017
접속 : connect
기본 데이터베이스 3개 (admin, config, local)


Robomongo 설치 (다른 클라이언트 프로그램 설치)
https://robomongo.org/
다운로드 Studio 3T Free -> 압축 풀고 실행 -> 경로(E:\kdigital_a\Studio 3T)
설치 완료 후 실행 -> Use Studio 3T's default password encryption -> Shell-centric 테마 
-> Do not import existing connection setting
-> 가입 및 등록
-> Manually configure my connection settings
connection name : local

--------------------
개인프로젝트 오늘 일정
(완료)properties 설정
(완료)아이디 찾기
(완료)비밀번호 찾기
(완료)회원정보 수정
(완료)비밀번호 수정기능

로그인 체크
방문자 카운트

=======================================
22.10.28 금 - 118일차

Stduio 3T 실습
주석 : //
커서칸 실행 : ctrl + enter

db 확인 : show dbs;
db 선택 : use db명;
선택된 db 확인 : db;
컬랙션 생성 (collection은 RDB의 table 역할을 수행함)
 : db.createCollection('컬렉션명')

컬렉션 확인 : show collections;
데이터 저장
db.컬렉션명.insert(JSON);

db.컬렉션명.insertOne() : 한건 {}
db.컬렉션명.insertMany() : 여러건 [{}, {}, {}]
db.컬렉션명.insert() : 한건도 되고, 여러건도 됨 (편리함)

변수사용 : j = {'id':'lee', 'name':'이길동', 'age':10};

데이터 조회 : 
db.student.find(); (조건 없이 검색 가능)

컬렉션 삭제 : db.컬렉션명.drop();
db 삭제(현재 선택된 db) : db.dropDatabase();
데이터 삭제 : db.컬렉션명.remove({'속성명':'속성값'}); 

검색 조건
$eq - equal
$gt - greater than >
$gte - greater than or equal >=
$lt - less than <
$lte - less than or equal <=
$in
$nin - not in
$or
$and

LIKE 검색(정규식)
/검색어/ - %검색어%
/^검색어/ = 검색어%
/검색어$/ - %검색어

예시
 - db.student.find({'age':{$gt:30}});
 - db.student.find({$and:[{'age':{$gt:30}}, {'age':{$lt:60}}]});

조회결과에서 필드 선택
db.student.find({criteria}, {projection})
예시 - db.student.find({'id':{$in:['hong', 'kim']}}, {'_id':false, 'id':true, 'name':true});

정렬 : sort() (1:오름차순, -1: 내림차순)
db.student.find().sort({'name':-1, 'id':1});

조회개수 : limit()
db.student.find().sort({'name':1}).limit(2);

LIKE 검색 예시
db.student.find({'id':/o/});
db.student.find({'name':/^김/});
db.student.find({'name':/동$/});

수정
아이디가 hong인 학생의 나이를 40으로 변경
document 전체가 수정됨 (document는 RDB에서 튜플에 대응됨)
db.student.update({'age':30}, {'id':'hong', 'name':'홍길똥','age':50});
db.student.find();

원하는 값만 수정 ($set)
multi 옵션 : 질의결과가 여러개일때 multi 옵션을 true
db.student.update({'id':'hong'}, {$set:{'age':30}}, {multi:true});
upsert 옵션 : 있으면 수정, 없으면 등록
db.student.update({'id':'hong'}, {$set:{'age':31}}, {upsert:true});

save : upsert 옵션과  유사하게 있으면 수정, 없으면 등록
bulkWrite : 등록, 수정, 삭제를 한번에 수행


함수
페이징 방법(시작값: skip(), 개수:limit())
db.student.find().skip(3).limit(3);

페이징 처리 함수 만들기(매개변수 : 시작값, 개수)
function page(idx, count) {
    return db.student.find().skip(idx).limit(count);  
}
page(3,3);

자바스크립트처럼 익명함수로 사용하기
var page2 = function(idx, c) {
    return db.student.find().skip(idx).limit(c);  
}
page2(0,2);

파이썬으로 MongoDB 사용해보기

JAVA로 MongoDB 사용해보기
mvnrepository.com 디펜던시 추가
"Legacy MongoDB Driver" 검색 
 - 4.2.0 버전 pom.xml에 추가 (spring 5.2.22버전)
"mongodb spring data" 검색 
 - Spring Data MongoDB Core 클릭 -> 3.1.0 버전 추가

servlet-context.xml 설정
 - namespace 추가 : mongo
<mongo:mongo-client id="mongoClient" connection-string="mongodb://localhost:27017/test"/>
<mongo:db-factory id="mongoFactory" dbname="test" mongo-client-ref="mongoClient"/>
<bean id="mongoTemplate" class="org.springframework.data.mongodb.core.MongoTemplate">
	<constructor-arg value="mongoFactory"/>
</bean>

bean으로 설정한 mongoTemplate를 주입받아서 DB 조작할 수 있다.

======================
개인프로젝트
(완료)방문자 카운트(DB에 방문자 기록 남기기)
(30% 완료)헤더 정리

로그인 체크 (인터셉터)
페이징 처리
이전글, 다음글
댓글게시판 구현

=======================================
22.10.31 월 - 119일차

JSON.stringify() : 값이나 객체를 JSON 문자열로 변환해주는 함수

var param = {"sword":$("#sword").val()} // param은 객체
JSON.stringify(param) // 객체를 JSON 형태로 변환함

MongoDB 수업 종료
==================================
엘라스틱 서치 교육 시작
교재 : "엘라스틱 스택 개발부터 운영까지"

ELK (Elasticsearch, Logstash, Kibana) : 합쳐서 엘라스틱 스택이라 부름
 엘라스틱서치 : 검색, 분석, 데이터 저장소 역할
 로그스태시 : 데이터를 수집 및 가공
 키바나 : 시각화, 관리기능
 (비츠 : 데이터 수집을 담당)

엘라스틱 서치 
 - 내부적으로 각 도큐먼트를 인덱싱하고 빠르게 검색하는데 사용함
 - 검색엔진이면서 데이터베이스이기도 하고 다양한 데이터 타입을 지원함
 - 기본적인 사용 경험은 몽고디비같은 도큐먼트 기반의 NoSQL과 유사하나 뛰어난 검색기능과 성능이 엘라스틱서치의 특징임
 - 연관도에 따른 정렬도 또 하나의 특징임

단점 
 - 저장공간이 크게 압축되지 않고, 시스템 리소스를 많이 사용함
 - DSL 쿼리를 채용하여 사실상 JOIN 쿼리가 어렵고, 반정규화가 기본임
 - 인덱스가 불변의 자료구조여서 도큐먼트 수정 삭제시 비용이 저렴하지 않음
대량의 데이터를 빠르게 검색하고 집계하기 위해서는 이같은 제약은 피할 수 없음

키바나
 - 핵심 기능 : 시각화, 대시보드 

로그스태시 
 - 이벤트 수집과 정제를 위한 도구
 - 가장 손이 많이 가는 작업이 데이터를 적재하는 작업인데 그 기능을 제공함
 - 인덱싱 성능 최적화하기 위한 배치처리와 병렬처리가 가능함
 - 데이터양이 급증하는 부하 상황에서도 안정성을 보장해줌

비츠
 - 엣지단에서 동작하는 경량 수집 도구
 - 가볍기 때문에 로그스태시와 비츠를 혼합하여 사용함

엘라스틱 스택의 용도
 - 전문(Full Text) 검색 엔진
 - 로그 통합 분석
 - 보안 이벤트 분석
 - 애플리케이션 성능 분석
 - 머신 러닝 (유료 라이선스 구매시 사용 가능)

2장 윈도우 실습 환경 구성
각 제품이 크로스플랫폼을 지원하는 언어를 기반으로 만들어져있음
운영체제에 대한 종속이 없는 편임

엘라스틱서치 7.10.1 버전 설치
https://www.elastic.co/kr/downloads/past-releases#elasticsearch 접속
elasticsearch-7.10.1-windows-x86_64 버전 다운로드 후 압축 풀기


엘라스틱서치 실행
cmd 실행 후 압축 푼 경로로 이동
.\bin\elasticsearch.bat 실행
실행됐는지 테스트
완료되면 "curl -X GET localhost:9200/?pretty" 실행시 응답결과가 있으면 실행 된것임

키바나 설치하기
https://www.elastic.co/kr/downloads/past-releases#elasticsearch 접속
Kibana 선택 후 7.10.1 버전 선택 다운로드 후 압축 풀기
cmd 실행 후 압축 푼 경로로 이동
.\bin\kibana.bat

실행여부 확인
엘라스틱 서치 실행, 키바나 cmd로 실행 후 localhost:5601 접속 하면 키바나가 실행 됨

==================
개인 프로젝트
 - 로그인체크 구현
 - 교회소개 페이지 작성
 - 페이징 처리 구현




소비자 인식 조사
제조공정 빅데이터
시험, 실험관련 빅데이터

지하철 유동인구 조사 -> 부동산 관련?
자연어 처리
이미지 처리












비밀댓글
회원관리
핀터레스트형 갤러리



추가 공부 키워드
AOP
트랜잭션
Security
JPA
Thymeleaf
SpringBoot
전자정부 프레임워크

데이터크롤링 프레임워크 : Scrapy(스크래피; 추가로 공부할 내용)

백엔드 개발자로서 역량(?)
 - 데이터를 어떻게 다루느냐
 - 어떤 형식으로 가공하고 저장하는지..

수료 후 장점이 될 수 있는 것들
 - 엘라스틱 서치
 - Ajax 비동기 기능 구현
 - 스프링 시큐리티(?)


검색이 필요한 프로젝트로
프로젝트 주제는 익숙한걸로(?)
사용되는 기술이 중요(?)

자주 사용되는 버전 
 - 스프링 4~5
 - 톰캣 7~8

코드너리
 - 기술스택에 대한 정보를 확인할 수 있는 사이트

사람인, 잡코리아, 원티드, 점핏, 프로그래머스, 잡플래닛
잡코리아 취업 정보 찾기
 - 직무 : 웹프로그래머 > 웹프로그래머, java, jsp, Servlet
 - 지역 : 서울, 경기
 - 경력 : 신입
 - 학력 : 무관